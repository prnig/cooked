<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cooked</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

/* ── Theme tokens ── */
[data-theme="dark"] {
  --bg: #06060a; --bg-card: rgba(24,24,27,.74); --bg-card-hover: rgba(31,31,35,.82);
  --bg-input: rgba(9,9,11,.72); --bg-overlay: rgba(0,0,0,.58);
  --bg-solid: #141418;
  --border: #27272a; --border-focus: #6366f1;
  --text: #fafafa; --text-secondary: #a1a1aa; --text-muted: #71717a;
  --accent: #135bec; --accent-hover: #2b6df0; --accent-subtle: rgba(19,91,236,.14);
  --green: #22c55e; --red: #ef4444;
  --shadow-card: 0 1px 3px rgba(0,0,0,.4);
  --shadow-lg: 0 8px 32px rgba(0,0,0,.5);
  --bg-grad-1: rgba(34,197,94,.42);
  --bg-grad-2: rgba(148,163,184,.3);
  --bg-grad-3: rgba(245,158,11,.2);
}
[data-theme="light"] {
  --bg: #cfd8e2; --bg-card: rgba(207,218,229,.94); --bg-card-hover: rgba(214,224,233,.98);
  --bg-input: rgba(201,213,224,.96); --bg-overlay: rgba(0,0,0,.30);
  --bg-solid: #c8d3df;
  --border: #97a8ba; --border-focus: #3347c7;
  --text: #0f1a27; --text-secondary: #273a4e; --text-muted: #3f566f;
  --accent: #135bec; --accent-hover: #0f4dcc; --accent-subtle: rgba(19,91,236,.1);
  --green: #16a34a; --red: #dc2626;
  --shadow-card: 0 1px 3px rgba(0,0,0,.06);
  --shadow-lg: 0 8px 32px rgba(0,0,0,.12);
  --bg-grad-1: rgba(110,231,183,.22);
  --bg-grad-2: rgba(203,213,225,.2);
  --bg-grad-3: rgba(251,191,36,.12);
}

:root { --mono: 'SF Mono', SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace; --sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; --radius: 10px; }

#ambient-bg { position: fixed; inset: 0; z-index: 0; pointer-events: none; overflow: hidden; background: var(--bg); }
#ambient-bg::before, #ambient-bg::after { content: ''; position: absolute; inset: -12vmax; }
#ambient-bg::before {
  background:
    linear-gradient(110deg, var(--bg-grad-1) 0%, var(--bg-grad-2) 38%, var(--bg-grad-3) 72%, var(--bg-grad-1) 100%);
  background-size: 220% 220%;
  animation: bg-slide-x 95s ease-in-out infinite alternate;
}
#ambient-bg::after {
  background:
    linear-gradient(90deg, transparent 0%, rgba(255,255,255,.035) 50%, transparent 100%);
  background-size: 200% 100%;
  opacity: .7;
  animation: bg-slide-sheen 140s ease-in-out infinite alternate;
}
[data-theme="light"] #ambient-bg::after {
  background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,.08) 50%, transparent 100%);
}
#ambient-grain {
  position: absolute;
  inset: 0;
  opacity: .05;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='140' height='140' viewBox='0 0 140 140'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='140' height='140' filter='url(%23n)' opacity='.9'/%3E%3C/svg%3E");
  background-size: 240px 240px;
}
[data-theme="light"] #ambient-grain { opacity: .025; }
body { font-family: var(--sans); background: var(--bg); color: var(--text); min-height: 100vh; transition: background .2s, color .2s; -webkit-font-smoothing: antialiased; position: relative; }
@keyframes bg-slide-x {
  0% { background-position: 0% 50%; }
  100% { background-position: 100% 50%; }
}
@keyframes bg-slide-sheen {
  0% { background-position: 12% 50%; }
  100% { background-position: 88% 50%; }
}
@media (prefers-reduced-motion: reduce) {
  #ambient-bg::before, #ambient-bg::after, .logo, .claude-credit { animation: none !important; }
}
body.low-power #ambient-bg::before,
body.low-power #ambient-bg::after,
body.low-power .logo,
body.low-power .claude-credit,
body.low-power .flow-link,
body.low-power .flow-particle,
body.low-power .live-dot,
body.low-power .spinner {
  animation: none !important;
}
body.low-power #ambient-bg::after { opacity: .24; }
body.low-power #ambient-grain { opacity: .018; }
body.low-power .flow-particle { display: none !important; }
body.low-power .flow-link { background-size: 100% 100%; box-shadow: none; }
body.low-power .glass, body.low-power .studio-header { backdrop-filter: none; }

/* ── Header ── */
.header { background: var(--bg-card); border-bottom: 1px solid var(--border); padding: 0 20px; height: 52px; display: flex; align-items: center; justify-content: space-between; position: sticky; top: 0; z-index: 40; transition: background .2s, border-color .2s; }
.header-left { display: flex; align-items: center; gap: 12px; }
.logo { font-size: 2rem; font-weight: 900; letter-spacing: -.03em; background: linear-gradient(90deg, #6366f1, #ec4899, #f59e0b, #22c55e, #06b6d4, #6366f1); background-size: 220% auto; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; animation: rainbow-shift 5s linear infinite; line-height: 1; }
.tagline { font-size: .85rem; color: var(--text-muted); border-left: 1px solid var(--border); padding-left: 12px; display: none; }
@media(min-width:640px){ .tagline { display: block; } }
.header-right { display: flex; align-items: center; gap: 6px; }
.hdr-btn { background: none; border: 1px solid var(--border); color: var(--text-secondary); width: 38px; height: 38px; border-radius: 8px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all .15s; }
.hdr-btn:hover { background: var(--accent-subtle); border-color: var(--accent); color: var(--accent); }
.hdr-btn svg { width: 18px; height: 18px; }
.hdr-text-btn { background: none; border: 1px solid var(--border); color: var(--text-secondary); height: 38px; padding: 0 16px; border-radius: 8px; cursor: pointer; font-size: .88rem; font-weight: 600; font-family: var(--sans); transition: all .15s; display: flex; align-items: center; gap: 5px; }
.hdr-text-btn:hover { background: var(--accent-subtle); border-color: var(--accent); color: var(--accent); }

/* ── Main layout ── */
.main { max-width: 860px; margin: 0 auto; padding: 24px 16px 60px; display: flex; flex-direction: column; gap: 16px; position: relative; z-index: 1; }
@media(min-width:640px){ .main { padding: 32px 24px 80px; gap: 20px; } }

/* ── Cards ── */
.card { background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius); box-shadow: var(--shadow-card); transition: background .2s, border-color .2s; }
.card-body { padding: 16px; }
@media(min-width:640px){ .card-body { padding: 20px; } }
#output-card { order: -1; }

/* ── Pattern input ── */
#pattern { font-family: var(--mono); font-size: 1rem; border: 1px solid var(--border); border-radius: 8px; padding: 12px 14px; width: 100%; background: var(--bg-input); color: var(--text); outline: none; transition: border-color .15s, box-shadow .15s; resize: vertical; min-height: 110px; line-height: 1.6; }
#pattern:focus { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-subtle); }
#pattern::placeholder { color: var(--text-muted); }
.pattern-help { font-size: .82rem; color: var(--text-muted); margin-top: 8px; line-height: 1.5; }
.pattern-help kbd { background: var(--accent-subtle); color: var(--accent); padding: 2px 6px; border-radius: 4px; font-family: var(--mono); font-size: .78rem; font-weight: 600; }
.flow-hint {
  margin-top: 8px;
  border: 1px solid color-mix(in srgb, var(--accent) 38%, var(--border) 62%);
  border-radius: 8px;
  background: color-mix(in srgb, var(--accent-subtle) 70%, transparent);
  color: var(--text-secondary);
  font-size: .72rem;
  padding: 6px 8px;
}

/* ── Column preview ── */
.col-preview { display: flex; flex-wrap: wrap; gap: 6px; min-height: 0; margin-top: 10px; }
.col-preview:empty { margin-top: 0; }
.col-tag { display: inline-flex; align-items: center; gap: 4px; background: var(--accent-subtle); color: var(--accent); border: 1px solid rgba(99,102,241,.2); font-family: var(--mono); font-size: .82rem; padding: 4px 12px; border-radius: 20px; white-space: nowrap; max-width: 200px; overflow: hidden; text-overflow: ellipsis; }
.col-tag .col-num { background: var(--accent); color: #fff; width: 16px; height: 16px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-size: .6rem; font-weight: 700; flex-shrink: 0; }
.col-tag.col-more {
  background: color-mix(in srgb, var(--bg-solid) 85%, var(--accent) 15%);
  color: var(--text-secondary);
  border-color: color-mix(in srgb, var(--border) 65%, transparent);
  font-weight: 600;
}
.col-sep { color: var(--text-muted); font-size: .65rem; font-weight: 700; }

/* ── Generate bar ── */
.gen-bar { display: flex; gap: 8px; margin-top: 14px; }
.btn { display: inline-flex; align-items: center; justify-content: center; gap: 6px; padding: 12px 24px; border-radius: 8px; border: none; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all .15s; font-family: var(--sans); }
.btn-primary { background: var(--accent); color: #fff; flex: 1; }
.btn-primary:hover { background: var(--accent-hover); box-shadow: 0 0 20px rgba(99,102,241,.25); }
.btn-primary:disabled { opacity: .45; cursor: not-allowed; box-shadow: none; }
.btn-ghost { background: transparent; color: var(--text-secondary); border: 1px solid var(--border); }
.btn-ghost:hover { background: var(--accent-subtle); border-color: var(--accent); color: var(--accent); }
.btn-danger { background: rgba(239,68,68,.1); color: var(--red); border: 1px solid rgba(239,68,68,.2); display: none; }
.btn-danger:hover { background: rgba(239,68,68,.2); }
.shortcut-hint { font-size: .68rem; color: rgba(255,255,255,.5); font-weight: 400; margin-left: 2px; }

/* ── Sections ── */
.preset-row { display: grid; grid-template-columns: 1.4fr 1fr auto; gap: 8px; align-items: center; }
@media(max-width:640px){ .preset-row { grid-template-columns: 1fr; } }
.preset-select, .preset-name { font-family: var(--mono); font-size: .9rem; border: 1px solid var(--border); border-radius: 6px; padding: 8px 10px; background: var(--bg-solid); color: var(--text); outline: none; width: 100%; }
.preset-select:focus, .preset-name:focus { border-color: var(--accent); }
.preset-actions { display: flex; gap: 6px; }
.preset-btn { padding: 8px 12px; font-size: .82rem; }
.preset-meta { margin-top: 8px; display: flex; align-items: center; gap: 10px; flex-wrap: wrap; color: var(--text-muted); font-size: .78rem; }
.preset-meta label { display: inline-flex; align-items: center; gap: 5px; cursor: pointer; }
.section-head { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
.section-head .field-label { margin-bottom: 0; }
.help { position: relative; width: 17px; height: 17px; border: 1px solid var(--border); color: var(--text-muted); border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-size: .68rem; font-weight: 700; cursor: help; user-select: none; }
.help:hover { border-color: var(--accent); color: var(--accent); background: var(--accent-subtle); }
.help::after { content: attr(data-tip); position: absolute; left: 50%; bottom: calc(100% + 8px); transform: translateX(-50%); min-width: 190px; max-width: 260px; background: var(--text); color: var(--bg); border-radius: 8px; font-size: .72rem; font-weight: 500; line-height: 1.4; padding: 7px 9px; white-space: normal; opacity: 0; pointer-events: none; transition: opacity .15s ease; z-index: 120; }
.help:hover::after { opacity: 1; }

/* ── Dynamic rows ── */
.dyn-row { display: flex; gap: 6px; align-items: center; margin-bottom: 6px; }
.dyn-row input[type="text"], .dyn-row select { font-family: var(--mono); font-size: .9rem; border: 1px solid var(--border); border-radius: 6px; padding: 7px 10px; background: var(--bg-solid); color: var(--text); outline: none; transition: border-color .15s; }
.dyn-row input[type="text"]:focus, .dyn-row select:focus { border-color: var(--accent); }
.dyn-row .name-input { width: 90px; flex-shrink: 0; }
.dyn-row .val-input { flex: 1; min-width: 0; }
.icon-btn { width: 30px; height: 30px; border-radius: 6px; border: 1px solid var(--border); background: transparent; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: .85rem; color: var(--text-muted); transition: all .12s; flex-shrink: 0; }
.icon-btn:hover { background: rgba(239,68,68,.1); border-color: rgba(239,68,68,.3); color: var(--red); }
.add-btn { background: transparent; border: 1px dashed var(--border); border-radius: 6px; padding: 9px 16px; font-size: .88rem; color: var(--text-muted); cursor: pointer; font-family: var(--sans); transition: all .12s; width: 100%; text-align: center; }
.add-btn:hover { border-color: var(--accent); color: var(--accent); background: var(--accent-subtle); }

/* ── Options grid ── */
.options-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
@media(max-width:560px){ .options-grid { grid-template-columns: 1fr; } }
.opt-field label { display: block; font-size: .78rem; color: var(--text-muted); margin-bottom: 4px; font-weight: 500; text-transform: uppercase; letter-spacing: .04em; }
.opt-field select, .opt-field input[type="text"] { font-family: var(--mono); font-size: .9rem; border: 1px solid var(--border); border-radius: 6px; padding: 7px 10px; background: var(--bg-solid); color: var(--text); width: 100%; outline: none; transition: border-color .15s; }
.preset-select option, .dyn-row select option, .opt-field select option { background: var(--bg-solid); color: var(--text); }
.opt-field select:focus, .opt-field input[type="text"]:focus { border-color: var(--accent); }

/* ── Examples ── */
.examples-row { display: flex; flex-wrap: wrap; gap: 6px; }
.example-chip { background: var(--bg-card); border: 1px solid var(--border); border-radius: 8px; padding: 8px 16px; cursor: pointer; transition: all .15s; display: flex; align-items: baseline; gap: 8px; }
.example-chip:hover { border-color: var(--accent); background: var(--accent-subtle); }
.ex-pattern { font-family: var(--mono); font-size: .85rem; color: var(--text); font-weight: 600; white-space: nowrap; }
.ex-desc { color: var(--text-muted); font-size: .78rem; white-space: nowrap; }
.warn { margin-top: 7px; padding: 8px 10px; border: 1px solid rgba(245,158,11,.35); background: rgba(245,158,11,.08); color: #d97706; border-radius: 8px; font-size: .78rem; display: none; }
[data-theme="dark"] .warn { color: #fbbf24; }

/* ── Autocomplete ── */
.ac-box { position: fixed; z-index: 420; min-width: 250px; max-width: 420px; max-height: 240px; overflow-y: auto; background: var(--bg-solid); border: 1px solid color-mix(in srgb, var(--border) 70%, #000 30%); border-radius: 10px; box-shadow: var(--shadow-lg); display: none; }
.ac-item { display: flex; align-items: center; justify-content: space-between; gap: 8px; padding: 8px 10px; cursor: pointer; border-bottom: 1px solid var(--border); }
.ac-item:last-child { border-bottom: none; }
.ac-item.active { background: var(--accent-subtle); }
.ac-main { display: flex; align-items: center; gap: 6px; min-width: 0; }
.ac-code { font-family: var(--mono); font-size: .8rem; font-weight: 700; color: var(--accent); }
.ac-desc { font-size: .74rem; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.ac-fav { border: 1px solid var(--border); background: transparent; color: var(--text-muted); width: 24px; height: 24px; border-radius: 6px; font-size: .75rem; cursor: pointer; flex-shrink: 0; }
.ac-fav.on { color: #f59e0b; border-color: rgba(245,158,11,.5); background: rgba(245,158,11,.12); }

/* ── Output ── */
.output-head { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid var(--border); flex-wrap: wrap; gap: 8px; }
@media(min-width:640px){ .output-head { padding: 12px 20px; } }
.output-title { font-size: .95rem; font-weight: 700; color: var(--text-secondary); }
.output-meta { display: flex; align-items: center; gap: 10px; }
.output-stats { font-size: .78rem; color: var(--text-muted); }
.output-stats .count { font-weight: 700; color: var(--accent); }
.output-actions { display: flex; gap: 4px; }
.output-actions .btn { padding: 8px 16px; font-size: .88rem; font-weight: 500; }
.progress-bar { display: none; align-items: center; gap: 8px; padding: 10px 20px; background: var(--accent-subtle); border-bottom: 1px solid rgba(99,102,241,.15); font-size: .78rem; color: var(--accent); }
.progress-bar.active { display: flex; }
.spinner { width: 14px; height: 14px; border: 2px solid rgba(99,102,241,.2); border-top-color: var(--accent); border-radius: 50%; animation: spin .6s linear infinite; flex-shrink: 0; }
@keyframes spin { to { transform: rotate(360deg); } }
#output-area { padding: 16px 20px; font-family: var(--mono); font-size: .9rem; white-space: pre; line-height: 1.6; color: var(--text-secondary); overflow-x: auto; min-height: 120px; max-height: 50vh; overflow-y: auto; }
.empty-state { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 48px 20px; text-align: center; min-height: 120px; }
.empty-state .empty-icon { font-size: 2rem; margin-bottom: 10px; opacity: .25; filter: grayscale(1); }
.empty-state h3 { font-size: .88rem; color: var(--text-muted); font-weight: 600; margin-bottom: 4px; }
.empty-state p { font-size: .76rem; color: var(--text-muted); opacity: .7; max-width: 280px; line-height: 1.5; }

/* ── Toast ── */
.toast { position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%) translateY(80px); background: var(--text); color: var(--bg); padding: 10px 22px; border-radius: 8px; font-size: .82rem; font-weight: 600; opacity: 0; transition: all .3s ease; z-index: 200; pointer-events: none; }
.toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

/* ── Method modal ── */
.modal-overlay { display: none; position: fixed; inset: 0; background: var(--bg-overlay); z-index: 100; align-items: flex-start; justify-content: center; padding: 60px 16px; }
.modal-overlay.open { display: flex; }
.modal { background: var(--bg-solid); border: 1px solid color-mix(in srgb, var(--border) 70%, #000 30%); border-radius: 14px; box-shadow: var(--shadow-lg); width: 100%; max-width: 520px; max-height: 70vh; display: flex; flex-direction: column; overflow: hidden; }
@media(max-width:560px){ .modal { max-height: 85vh; border-radius: 14px 14px 0 0; position: fixed; bottom: 0; left: 0; right: 0; max-width: 100%; } .modal-overlay { align-items: flex-end; padding: 0; } }
.modal-head { display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--border); }
.modal-head h3 { font-size: .95rem; font-weight: 700; }
.modal-close { background: none; border: none; cursor: pointer; color: var(--text-muted); font-size: 1.2rem; padding: 4px; line-height: 1; }
.modal-close:hover { color: var(--text); }
.method-search { width: calc(100% - 40px); margin: 12px 20px 8px; border: 1px solid var(--border); border-radius: 8px; padding: 8px 12px; font-size: .82rem; outline: none; font-family: var(--sans); background: var(--bg-solid); color: var(--text); transition: border-color .15s; }
.method-search:focus { border-color: var(--accent); }
.method-list { overflow-y: auto; padding: 4px 20px 16px; flex: 1; }
.method-cat { font-size: .68rem; font-weight: 700; color: var(--accent); text-transform: uppercase; letter-spacing: .06em; margin-top: 16px; margin-bottom: 4px; padding-bottom: 4px; border-bottom: 1px solid var(--border); }
.method-cat:first-child { margin-top: 8px; }
.method-item { font-size: .78rem; color: var(--text-secondary); padding: 5px 6px; line-height: 1.5; cursor: pointer; border-radius: 6px; margin: 1px -6px; transition: background .1s; }
.method-item:hover { background: var(--accent-subtle); color: var(--text); }
.method-item code { background: var(--accent-subtle); color: var(--accent); padding: 1px 6px; border-radius: 4px; font-family: var(--mono); font-size: .72rem; font-weight: 600; }

/* ── Preview2 Method Modal Variant ── */
.method-modal-overlay { background: rgba(4,8,18,.72); }
.method-modal {
  max-width: 1040px;
  max-height: 84vh;
  border-radius: 24px;
  background: linear-gradient(180deg, rgba(15,23,42,.96), rgba(9,14,24,.96));
  border: 1px solid rgba(148,163,184,.25);
}
[data-theme="light"] .method-modal { background: rgba(238,243,248,.98); border-color: rgba(148,163,184,.35); }
.method-modal-head { padding: 16px 20px; }
.method-modal-head h3 { font-size: 1.16rem; color: #eef2ff; letter-spacing: -.01em; }
[data-theme="light"] .method-modal-head h3 { color: #1f2937; }
.method-sub { font-size: .78rem; color: #94a3b8; margin-top: 2px; }
.method-head-row { display: flex; align-items: center; justify-content: space-between; gap: 14px; }
.method-nav {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px;
  border: 1px solid rgba(148,163,184,.22);
  border-radius: 11px;
  background: rgba(255,255,255,.03);
}
[data-theme="light"] .method-nav { background: rgba(255,255,255,.7); }
.method-nav-btn {
  border: 0;
  background: transparent;
  color: #94a3b8;
  padding: 6px 10px;
  border-radius: 8px;
  font-size: .7rem;
  font-weight: 700;
  letter-spacing: .02em;
  cursor: default;
}
.method-nav-btn.active {
  background: rgba(37,99,235,.95);
  color: #eff6ff;
  box-shadow: 0 6px 14px rgba(30,64,175,.28);
}
[data-theme="light"] .method-nav-btn:not(.active) { color: #64748b; }
.method-top-search { padding: 12px 20px; border-top: 1px solid rgba(148,163,184,.14); border-bottom: 1px solid rgba(148,163,184,.14); background: rgba(255,255,255,.02); }
[data-theme="light"] .method-top-search { background: rgba(255,255,255,.45); }
.method-top-search .method-search { width: 100%; margin: 0; border-color: rgba(148,163,184,.25); border-radius: 10px; padding: 10px 12px; background: rgba(2,6,23,.4); color: #e2e8f0; }
[data-theme="light"] .method-top-search .method-search { background: rgba(255,255,255,.88); color: #1f2937; }
.method-shell { display: flex; min-height: 0; flex: 1; }
.method-sidebar { width: 196px; border-right: 1px solid rgba(148,163,184,.16); padding: 12px; display: flex; flex-direction: column; gap: 6px; overflow-y: auto; background: rgba(255,255,255,.02); }
[data-theme="light"] .method-sidebar { background: rgba(255,255,255,.35); }
.method-side-title { font-size: .63rem; color: #64748b; letter-spacing: .08em; text-transform: uppercase; margin: 8px 6px 4px; font-weight: 700; }
.method-side-item { width: 100%; text-align: left; border: 1px solid transparent; border-radius: 8px; background: transparent; color: #a8b3c7; padding: 8px 10px; font-size: .82rem; cursor: pointer; transition: all .15s; }
[data-theme="light"] .method-side-item { color: #4b5563; }
.method-side-item:hover { background: rgba(99,102,241,.12); color: #e2e8f0; }
[data-theme="light"] .method-side-item:hover { color: #1f2937; }
.method-side-item.active { background: rgba(19,91,236,.22); border-color: rgba(59,130,246,.35); color: #eff6ff; }
[data-theme="light"] .method-side-item.active { color: #1e3a8a; }
.method-panel { flex: 1; min-width: 0; overflow-y: auto; padding: 14px; }
.method-grid { display: grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap: 12px; }
@media(max-width:1040px){ .method-grid { grid-template-columns: repeat(2, minmax(0,1fr)); } }
@media(max-width:840px){ .method-grid { grid-template-columns: 1fr; } .method-sidebar { width: 140px; } }
@media(max-width:640px){ .method-shell { flex-direction: column; } .method-sidebar { width: 100%; border-right: 0; border-bottom: 1px solid rgba(148,163,184,.16); flex-direction: row; flex-wrap: wrap; } .method-side-title { width: 100%; } .method-side-item { width: auto; } }
.method-card {
  border: 1px solid rgba(148,163,184,.2);
  border-radius: 16px;
  padding: 14px;
  background: linear-gradient(180deg, rgba(15,23,42,.65), rgba(15,23,42,.4));
  cursor: pointer;
  transition: border-color .15s, background .15s, transform .15s, box-shadow .15s;
}
[data-theme="light"] .method-card { background: rgba(255,255,255,.72); }
.method-card:hover { border-color: rgba(96,165,250,.55); transform: translateY(-2px); box-shadow: 0 10px 26px rgba(2,6,23,.22); }
.method-card.active { border-color: #2563eb; box-shadow: 0 0 0 1px rgba(37,99,235,.35) inset; background: rgba(37,99,235,.12); }
.method-card-name { font-family: var(--mono); font-size: .98rem; color: #93c5fd; font-weight: 700; margin-bottom: 6px; }
[data-theme="light"] .method-card-name { color: #1d4ed8; }
.method-card-desc { font-size: .82rem; color: #a5b4c7; line-height: 1.55; min-height: 52px; }
[data-theme="light"] .method-card-desc { color: #4b5563; }
.method-card-meta { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
.method-alias { font-family: var(--mono); font-size: .66rem; border: 1px solid rgba(148,163,184,.28); color: #94a3b8; border-radius: 999px; padding: 2px 7px; }
[data-theme="light"] .method-alias { color: #64748b; }
.method-param { margin-top: 8px; font-size: .72rem; color: #93a4bf; background: rgba(15,23,42,.36); border: 1px dashed rgba(148,163,184,.24); border-radius: 7px; padding: 6px 8px; }
[data-theme="light"] .method-param { color: #64748b; background: rgba(15,23,42,.04); }
.method-card-ex { margin-top: 9px; border: 1px solid rgba(148,163,184,.2); border-radius: 8px; background: rgba(2,6,23,.38); padding: 7px 8px; font-family: var(--mono); font-size: .74rem; color: #94a3b8; }
[data-theme="light"] .method-card-ex { background: rgba(15,23,42,.06); color: #64748b; }
.method-empty { color: #94a3b8; font-size: .86rem; border: 1px dashed rgba(148,163,184,.3); border-radius: 10px; padding: 18px; text-align: center; }
.method-footer { border-top: 1px solid rgba(148,163,184,.16); padding: 10px 14px; display: flex; align-items: center; justify-content: space-between; gap: 10px; background: rgba(255,255,255,.03); }
[data-theme="light"] .method-footer { background: rgba(255,255,255,.45); }
.method-hints { color: #94a3b8; font-size: .72rem; display: flex; align-items: center; gap: 6px; }
.method-hints span { opacity: .45; }
.method-hints kbd { font-size: .62rem; background: rgba(15,23,42,.46); border: 1px solid rgba(148,163,184,.35); border-radius: 5px; padding: 2px 5px; color: #cbd5e1; font-family: var(--mono); }
.method-actions { display: flex; gap: 8px; }
.method-actions .btn { padding: 8px 13px; font-size: .82rem; }
.examples-modal-overlay { background: rgba(4,8,18,.72); }
.examples-modal {
  max-width: 1120px;
  max-height: 84vh;
  border-radius: 24px;
  background: linear-gradient(180deg, rgba(15,23,42,.96), rgba(9,14,24,.96));
  border: 1px solid rgba(148,163,184,.25);
}
[data-theme="light"] .examples-modal { background: rgba(238,243,248,.98); border-color: rgba(148,163,184,.35); }
.examples-modal-head { padding: 16px 20px; }
.examples-modal-head h3 { font-size: 1.16rem; color: #eef2ff; letter-spacing: -.01em; }
[data-theme="light"] .examples-modal-head h3 { color: #1f2937; }
.docs-modal-overlay { background: rgba(4,8,18,.74); }
.docs-modal { max-width: 1360px; width: min(98vw, 1360px); max-height: 92vh; border-radius: 20px; overflow: hidden; background: linear-gradient(180deg, rgba(15,23,42,.97), rgba(8,12,20,.97)); border: 1px solid rgba(148,163,184,.28); }
[data-theme="light"] .docs-modal { background: rgba(240,245,251,.98); border-color: rgba(148,163,184,.42); }
.docs-shell { display: grid; grid-template-columns: 260px minmax(0, 1fr); min-height: 72vh; }
.docs-sidebar { border-right: 1px solid rgba(148,163,184,.18); padding: 14px; background: rgba(255,255,255,.02); }
[data-theme="light"] .docs-sidebar { background: rgba(255,255,255,.5); }
.docs-side-item { width: 100%; text-align: left; border: 1px solid transparent; background: transparent; color: var(--text-secondary); padding: 10px 12px; border-radius: 10px; cursor: pointer; font-size: .82rem; margin-bottom: 6px; }
.docs-side-item.active, .docs-side-item:hover { border-color: color-mix(in srgb, var(--accent) 46%, var(--border) 54%); color: var(--accent); background: var(--accent-subtle); }
.docs-main { padding: 16px; overflow-y: auto; overflow-x: hidden; }
.docs-block { border: 1px solid color-mix(in srgb, var(--border) 74%, transparent); border-radius: 14px; padding: 14px; margin-bottom: 12px; background: color-mix(in srgb, var(--bg-card) 88%, transparent); }
.docs-block h4 { margin: 0 0 8px; font-size: .98rem; color: var(--text); }
.docs-block p { margin: 0 0 8px; color: var(--text-secondary); font-size: .86rem; line-height: 1.5; }
.docs-list { margin: 0; padding-left: 18px; color: var(--text-secondary); font-size: .84rem; line-height: 1.55; }
.docs-code { display: block; margin-top: 8px; background: color-mix(in srgb, var(--bg-solid) 88%, transparent); border: 1px solid color-mix(in srgb, var(--border) 70%, transparent); border-radius: 10px; padding: 9px 10px; font-family: var(--mono); font-size: .76rem; white-space: pre-wrap; color: var(--text); }
.docs-hero { border: 1px solid rgba(59,130,246,.26); border-radius: 14px; padding: 16px; background: radial-gradient(120% 120% at 0% 0%, rgba(37,99,235,.18), rgba(15,23,42,.06)); margin-bottom: 12px; }
.docs-hero h4 { margin: 0 0 6px; font-size: 1.06rem; color: #dbeafe; }
[data-theme="light"] .docs-hero h4 { color: #1e3a8a; }
.docs-hero p { margin: 0; color: #b9c8de; font-size: .84rem; }
[data-theme="light"] .docs-hero p { color: #3f5268; }
.docs-grid { display: grid; gap: 10px; grid-template-columns: repeat(2, minmax(0,1fr)); }
.docs-scenario { border: 1px solid color-mix(in srgb, var(--border) 72%, transparent); border-radius: 12px; padding: 12px; background: rgba(255,255,255,.02); }
[data-theme="light"] .docs-scenario { background: rgba(255,255,255,.68); }
.docs-scenario h5 { margin: 0 0 6px; font-size: .88rem; color: var(--text); }
.docs-scenario p { margin: 0 0 8px; font-size: .8rem; color: var(--text-muted); line-height: 1.4; }
.docs-row-actions { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
.docs-btn { border: 1px solid color-mix(in srgb, var(--accent) 44%, var(--border) 56%); background: color-mix(in srgb, var(--accent-subtle) 78%, transparent); color: var(--text); border-radius: 8px; padding: 7px 10px; font-size: .75rem; font-weight: 700; cursor: pointer; }
.docs-btn.alt { border-color: color-mix(in srgb, var(--border) 80%, transparent); background: color-mix(in srgb, var(--bg-solid) 82%, transparent); color: var(--text-secondary); }
.docs-btn:hover { border-color: var(--accent); color: var(--accent); }
.docs-level { display: inline-flex; align-items: center; gap: 6px; border: 1px solid color-mix(in srgb, var(--border) 70%, transparent); border-radius: 999px; padding: 3px 8px; font-size: .62rem; text-transform: uppercase; letter-spacing: .08em; color: var(--text-muted); margin-bottom: 8px; }
.docs-level.beginner { border-color: rgba(34,197,94,.45); color: #4ade80; }
.docs-level.intermediate { border-color: rgba(59,130,246,.45); color: #60a5fa; }
.docs-level.advanced { border-color: rgba(245,158,11,.45); color: #fbbf24; }
@media(max-width:980px){ .docs-shell { grid-template-columns: 1fr; } .docs-sidebar { border-right: 0; border-bottom: 1px solid rgba(148,163,184,.18); display: flex; flex-wrap: wrap; gap: 6px; } .docs-side-item { width: auto; margin: 0; } }
@media(max-width:760px){ .docs-grid { grid-template-columns: 1fr; } }
.examples-sub { font-size: .78rem; color: #94a3b8; margin-top: 2px; }
.examples-top-search { padding: 12px 18px; border-top: 1px solid rgba(148,163,184,.14); border-bottom: 1px solid rgba(148,163,184,.14); background: rgba(255,255,255,.02); }
[data-theme="light"] .examples-top-search { background: rgba(255,255,255,.45); }
.examples-top-search .method-search { width: 100%; margin: 0; border-color: rgba(148,163,184,.25); border-radius: 10px; padding: 10px 12px; background: rgba(2,6,23,.4); color: #e2e8f0; }
[data-theme="light"] .examples-top-search .method-search { background: rgba(255,255,255,.88); color: #1f2937; }
.examples-shell { display: flex; min-height: 0; flex: 1; }
.examples-sidebar { width: 180px; border-right: 1px solid rgba(148,163,184,.16); padding: 10px; display: flex; flex-direction: column; gap: 6px; overflow-y: auto; background: rgba(255,255,255,.02); }
[data-theme="light"] .examples-sidebar { background: rgba(255,255,255,.35); }
.examples-panel { flex: 1; min-width: 0; overflow-y: auto; overflow-x: hidden; padding: 14px; }
.examples-grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
@media(max-width:900px){ .examples-sidebar { width: 140px; } }
@media(max-width:640px){ .examples-shell { flex-direction: column; } .examples-sidebar { width: 100%; border-right: 0; border-bottom: 1px solid rgba(148,163,184,.16); flex-direction: row; flex-wrap: wrap; } .examples-sidebar .method-side-title { width: 100%; } .example-side-item { width: auto; } }
.example-side-item { width: 100%; text-align: left; border: 1px solid transparent; border-radius: 8px; background: transparent; color: #a8b3c7; padding: 8px 10px; font-size: .82rem; cursor: pointer; transition: all .15s; }
[data-theme="light"] .example-side-item { color: #4b5563; }
.example-side-item:hover { background: rgba(99,102,241,.12); color: #e2e8f0; }
[data-theme="light"] .example-side-item:hover { color: #1f2937; }
.example-side-item.active { background: rgba(19,91,236,.22); border-color: rgba(59,130,246,.35); color: #eff6ff; }
[data-theme="light"] .example-side-item.active { color: #1e3a8a; }
.example-card {
  border: 1px solid rgba(148,163,184,.2);
  border-radius: 16px;
  padding: 14px;
  background: linear-gradient(180deg, rgba(15,23,42,.6), rgba(15,23,42,.36));
  cursor: pointer;
  transition: border-color .15s, background .15s, transform .15s, box-shadow .15s;
}
[data-theme="light"] .example-card { background: rgba(255,255,255,.72); }
.example-card:hover { border-color: rgba(96,165,250,.55); transform: translateY(-2px); box-shadow: 0 10px 24px rgba(2,6,23,.2); }
.example-card.active { border-color: #2563eb; box-shadow: 0 0 0 1px rgba(37,99,235,.35) inset; background: rgba(37,99,235,.12); }
.example-name { font-weight: 800; font-size: .92rem; margin-bottom: 8px; color: #e2e8f0; }
[data-theme="light"] .example-name { color: #111827; }
.example-flow {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 9px;
  border: 1px solid rgba(148,163,184,.2);
  border-radius: 999px;
  padding: 4px 8px;
  background: rgba(2,6,23,.25);
}
[data-theme="light"] .example-flow { background: rgba(255,255,255,.8); }
.flow-pill {
  font-size: .62rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: .05em;
  color: #93c5fd;
}
[data-theme="light"] .flow-pill { color: #1d4ed8; }
.flow-arrow { font-size: .72rem; color: #64748b; }
.example-card-actions {
  display: flex;
  justify-content: flex-end;
  margin-top: 6px;
}
.example-mini-btn {
  border: 1px solid rgba(59,130,246,.45);
  border-radius: 8px;
  background: rgba(30,64,175,.24);
  color: #dbeafe;
  font-size: .7rem;
  font-weight: 700;
  padding: 5px 10px;
  cursor: pointer;
}
.example-mini-btn:hover { background: rgba(30,64,175,.34); }
[data-theme="light"] .example-mini-btn {
  background: rgba(219,234,254,.95);
  color: #1e3a8a;
}
[data-theme="light"] .example-mini-btn:hover { background: rgba(191,219,254,.95); }
.example-tags { display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 8px; }
.example-tag { font-size: .68rem; border: 1px solid rgba(148,163,184,.28); border-radius: 999px; color: #94a3b8; padding: 2px 8px; }
[data-theme="light"] .example-tag { color: #64748b; }
.example-io { font-family: var(--mono); font-size: .73rem; color: #cbd5e1; line-height: 1.45; white-space: pre-wrap; word-break: break-word; border: 1px solid rgba(148,163,184,.2); border-radius: 8px; padding: 8px; margin-bottom: 8px; background: rgba(2,6,23,.38); }
[data-theme="light"] .example-io { color: #4b5563; background: rgba(15,23,42,.06); }
.example-io strong { color: #94a3b8; font-family: var(--sans); font-size: .68rem; text-transform: uppercase; letter-spacing: .05em; display: block; margin-bottom: 4px; }
.examples-footer { border-top: 1px solid rgba(148,163,184,.16); padding: 10px 14px; display: flex; align-items: center; justify-content: space-between; gap: 10px; background: rgba(255,255,255,.03); }
[data-theme="light"] .examples-footer { background: rgba(255,255,255,.45); }
.examples-actions { display: flex; gap: 8px; }
.examples-actions .btn { padding: 8px 13px; font-size: .82rem; }

/* ── Theme chooser popup ── */
.theme-chooser-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,.7); z-index: 300; align-items: center; justify-content: center; }
.theme-chooser-overlay.open { display: flex; pointer-events: none; }
.theme-chooser { pointer-events: auto; background: var(--bg-card); border: 1px solid var(--border); border-radius: 20px; box-shadow: var(--shadow-lg); padding: 40px 36px 32px; text-align: center; max-width: 420px; width: 90%; }
.theme-chooser h2 { font-size: 1.5rem; font-weight: 800; margin-bottom: 6px; }
.theme-chooser p { font-size: 1rem; color: var(--text-secondary); margin-bottom: 28px; }
.theme-choices { display: flex; gap: 16px; justify-content: center; }
.theme-choice { flex: 1; padding: 20px 12px; border-radius: 14px; border: 2px solid var(--border); cursor: pointer; transition: all .2s; background: transparent; font-family: var(--sans); }
.theme-choice:hover { border-color: var(--accent); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(99,102,241,.2); }
.theme-choice .choice-icon { font-size: 2.2rem; margin-bottom: 8px; display: block; }
.theme-choice .choice-label { font-size: .95rem; font-weight: 700; color: var(--text); display: block; }
.theme-choice .choice-sub { font-size: .78rem; color: var(--text-muted); display: block; margin-top: 2px; }

/* ── First-run onboarding ── */
.onboarding-overlay { display: none; position: fixed; inset: 0; z-index: 360; }
.onboarding-overlay.open { display: block; }
.onboarding-dim { position: absolute; inset: 0; background: rgba(2,6,23,.56); }
[data-theme="light"] .onboarding-dim { background: rgba(15,23,42,.34); }
.onboarding-overlay.has-target .onboarding-dim { background: transparent; }
.onboarding-spotlight {
  position: fixed; border-radius: 14px;
  border: 1px solid color-mix(in srgb, var(--accent) 72%, #fff 28%);
  box-shadow: 0 0 0 9999px rgba(2,6,23,.50), 0 10px 24px rgba(2,6,23,.34), 0 0 0 1px rgba(255,255,255,.24) inset;
  transition: left .25s ease, top .25s ease, width .25s ease, height .25s ease, opacity .2s ease;
  pointer-events: none; opacity: 0;
}
.onboarding-overlay.has-target .onboarding-spotlight { opacity: 1; }
.onboarding-card {
  position: absolute; right: 16px; bottom: 16px; width: min(480px, calc(100vw - 28px));
  background: color-mix(in srgb, var(--bg-card) 95%, #020617 5%);
  border: 1px solid color-mix(in srgb, var(--border) 78%, transparent);
  border-radius: 16px; box-shadow: var(--shadow-lg); padding: 16px 16px 14px;
}
[data-theme="light"] .onboarding-card { background: rgba(247,250,254,.97); }
.onboarding-top { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 10px; }
.onboarding-step { font-size: .72rem; letter-spacing: .08em; text-transform: uppercase; color: var(--text-muted); font-weight: 700; }
.onboarding-close {
  border: 1px solid var(--border); background: transparent; color: var(--text-muted);
  width: 28px; height: 28px; border-radius: 8px; cursor: pointer;
}
.onboarding-close:hover { color: var(--text); border-color: var(--accent); }
.onboarding-title { font-size: 1.08rem; font-weight: 800; color: var(--text); margin-bottom: 6px; }
.onboarding-body { font-size: .88rem; color: var(--text-secondary); line-height: 1.5; margin-bottom: 12px; }
.onboarding-flow {
  border: 1px solid color-mix(in srgb, var(--border) 72%, transparent);
  background: color-mix(in srgb, var(--bg-solid) 82%, transparent);
  border-radius: 12px; padding: 10px; margin-bottom: 12px;
}
.onboarding-flow-track { display: flex; align-items: center; gap: 9px; }
.flow-dot {
  min-width: 96px; text-align: center; padding: 8px 7px; border-radius: 10px; font-size: .72rem; font-weight: 700;
  border: 1px solid color-mix(in srgb, var(--border) 70%, transparent); color: var(--text-secondary);
  background: color-mix(in srgb, var(--bg-card) 78%, transparent);
}
.flow-dot.active { color: #fff; border-color: color-mix(in srgb, var(--accent) 72%, transparent); background: linear-gradient(180deg, color-mix(in srgb, var(--accent) 85%, #3b82f6 15%), color-mix(in srgb, var(--accent) 95%, #1d4ed8 5%)); }
.flow-arrow { flex: 1; min-width: 24px; height: 2px; background: linear-gradient(90deg, color-mix(in srgb, var(--accent) 45%, transparent), color-mix(in srgb, var(--accent) 85%, transparent), color-mix(in srgb, var(--accent) 45%, transparent)); background-size: 200% 100%; animation: flow-slide 1.35s linear infinite; opacity: .9; }
@keyframes flow-slide { to { background-position: 200% 0; } }
.onboarding-actions { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
.onboarding-actions-left, .onboarding-actions-right { display: flex; gap: 8px; align-items: center; }
.tour-btn {
  border: 1px solid var(--border); color: var(--text-secondary); background: color-mix(in srgb, var(--bg-solid) 84%, transparent);
  border-radius: 9px; padding: 8px 12px; font-size: .82rem; cursor: pointer; font-weight: 700;
}
.tour-btn:hover { border-color: var(--accent); color: var(--accent); }
.tour-btn.primary { background: linear-gradient(180deg, color-mix(in srgb, var(--accent) 80%, #3b82f6 20%), color-mix(in srgb, var(--accent) 94%, #1d4ed8 6%)); border-color: color-mix(in srgb, var(--accent) 55%, transparent); color: #fff; }
.tour-btn.primary:hover { filter: brightness(1.03); color: #fff; }
@media (prefers-reduced-motion: reduce) {
  .onboarding-spotlight { transition: none; }
  .flow-arrow { animation: none; }
}
@media (max-width: 860px) {
  .onboarding-card { left: 10px; right: 10px; bottom: 10px; width: auto; }
  .onboarding-flow-track { gap: 6px; }
  .flow-dot { min-width: 74px; font-size: .66rem; }
}

/* ── Footer ── */
.site-footer { text-align: center; padding: 24px 16px 32px; font-size: .85rem; color: var(--text-muted); line-height: 1.8; position: relative; z-index: 1; }
.site-footer a { color: var(--accent); text-decoration: none; }
.site-footer a:hover { text-decoration: underline; }
.claude-credit { display: inline-block; font-weight: 700; background: linear-gradient(90deg, #6366f1, #ec4899, #f59e0b, #22c55e, #6366f1); background-size: 200% auto; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; animation: rainbow-shift 3s linear infinite; }
@keyframes rainbow-shift { to { background-position: 200% center; } }

/* ── Test results ── */
.test-results { position: fixed; top: 56px; right: 16px; width: 420px; max-height: 80vh; overflow-y: auto; background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius); box-shadow: var(--shadow-lg); z-index: 100; font-size: .8rem; }
.test-results .tr-head { padding: 10px 14px; font-weight: 700; border-bottom: 1px solid var(--border); }
.test-pass { color: var(--green); }
.test-fail { color: var(--red); }
.test-item { padding: 6px 14px; border-bottom: 1px solid var(--border); }
.field-label { font-size: .7rem; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: .05em; margin-bottom: 6px; }

/* ── Preview3 Layout Overwrite ── */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&family=JetBrains+Mono:wght@400;600&display=swap');
:root { --sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; --mono: 'JetBrains Mono', 'SF Mono', Menlo, monospace; }
body { overflow-x: hidden; }
.studio-header {
  height: 64px; padding: 0 20px; position: sticky; top: 0; z-index: 50;
  display: flex; align-items: center; justify-content: space-between;
  background: color-mix(in srgb, var(--bg) 75%, transparent);
  border-bottom: 1px solid color-mix(in srgb, var(--border) 55%, transparent);
  backdrop-filter: blur(16px);
}
.brand { display: flex; align-items: center; gap: 12px; }
.brand-logo {
  font-weight: 800; letter-spacing: -.045em; font-size: 1.32rem; color: var(--text);
}
.brand-sub { font-size: .67rem; color: var(--text-muted); letter-spacing: .1em; text-transform: uppercase; }
.header-stack { display: flex; align-items: center; gap: 10px; }
.project-chip {
  border: 1px solid color-mix(in srgb, var(--border) 70%, transparent);
  background: color-mix(in srgb, var(--bg-card) 70%, transparent);
  color: var(--text-secondary);
  padding: 6px 11px;
  border-radius: 999px;
  font-size: .73rem;
}
.run-btn {
  border: 1px solid color-mix(in srgb, var(--accent) 45%, transparent);
  background: linear-gradient(180deg, color-mix(in srgb, var(--accent) 78%, #2563eb 22%), color-mix(in srgb, var(--accent) 92%, #1d4ed8 8%));
  color: #fff;
  border-radius: 999px;
  padding: 8px 14px;
  font-size: .74rem;
  font-weight: 700;
  cursor: pointer;
}
.studio-actions { display: flex; align-items: center; gap: 8px; }
.mode-btn {
  border: 1px solid color-mix(in srgb, var(--border) 72%, transparent);
  background: color-mix(in srgb, var(--bg-card) 78%, transparent);
  color: var(--text-secondary);
  border-radius: 999px;
  padding: 8px 12px;
  font-size: .73rem;
  font-weight: 700;
  cursor: pointer;
}
.mode-btn:hover { border-color: var(--accent); color: var(--accent); background: var(--accent-subtle); }
#simple-reset-btn { display: none; }
.studio-shell {
  max-width: none; margin: 0; padding: 12px 14px;
  display: grid; gap: 10px; grid-template-columns: 250px minmax(0, 1fr) 330px;
  position: relative; z-index: 1;
}
.studio-left, .studio-main, .studio-right { min-height: 0; }
.studio-left, .studio-right { display: flex; flex-direction: column; gap: 12px; }
.studio-main { display: flex; flex-direction: column; gap: 12px; }
.glass {
  background: color-mix(in srgb, var(--bg-card) 72%, transparent);
  border: 1px solid color-mix(in srgb, var(--border) 68%, transparent);
  backdrop-filter: blur(10px);
  border-radius: 12px;
  box-shadow: 0 10px 24px rgba(2,6,23,.22);
}
.toolbox-head { padding: 12px 14px; border-bottom: 1px solid var(--border); font-size: .69rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: .11em; font-weight: 700; }
.toolbox-search-wrap { padding: 10px; border-bottom: 1px solid color-mix(in srgb, var(--border) 60%, transparent); }
.toolbox-search {
  width: 100%;
  border: 1px solid color-mix(in srgb, var(--border) 70%, transparent);
  background: color-mix(in srgb, var(--bg-solid) 84%, transparent);
  color: var(--text);
  border-radius: 9px;
  padding: 9px 10px;
  font-size: .78rem;
  outline: none;
}
.toolbox-suggest {
  margin-top: 8px;
  border: 1px solid color-mix(in srgb, var(--border) 72%, transparent);
  border-radius: 10px;
  background: color-mix(in srgb, var(--bg-solid) 90%, transparent);
  box-shadow: 0 10px 22px rgba(2,6,23,.22);
  overflow: hidden;
}
[data-theme="light"] .toolbox-suggest { background: rgba(255,255,255,.96); }
.tool-suggest-item {
  width: 100%;
  text-align: left;
  border: 0;
  border-bottom: 1px solid color-mix(in srgb, var(--border) 70%, transparent);
  background: transparent;
  color: var(--text);
  padding: 8px 10px;
  cursor: pointer;
}
.tool-suggest-item:last-child { border-bottom: 0; }
.tool-suggest-item:hover { background: color-mix(in srgb, var(--accent-subtle) 75%, transparent); }
.tool-suggest-head { display: flex; align-items: center; gap: 8px; font-size: .74rem; font-weight: 700; }
.tool-suggest-type {
  font-size: .58rem;
  letter-spacing: .08em;
  text-transform: uppercase;
  border: 1px solid color-mix(in srgb, var(--border) 70%, transparent);
  border-radius: 999px;
  padding: 1px 6px;
  color: var(--text-muted);
}
.tool-suggest-sub { margin-top: 2px; font-size: .68rem; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.toolbox-list { padding: 10px; display: flex; flex-direction: column; gap: 8px; overflow: visible; }
.tool-cat { font-size: .62rem; color: var(--text-muted); letter-spacing: .11em; text-transform: uppercase; padding: 2px 4px; }
.method-palette { display: none; }
.method-pill {
  border: 1px solid color-mix(in srgb, var(--border) 75%, transparent);
  border-radius: 10px;
  padding: 9px 10px;
  color: var(--text-secondary);
  background: linear-gradient(180deg, color-mix(in srgb, #0f172a 82%, transparent), color-mix(in srgb, #111827 90%, transparent));
  cursor: grab;
  user-select: none;
}
.method-pill:active { cursor: grabbing; }
.method-pill:hover { border-color: color-mix(in srgb, var(--accent) 55%, var(--border) 45%); color: var(--text); }
.method-pill .m-name { font-family: var(--mono); font-size: .78rem; font-weight: 700; color: #c7d2fe; display: block; }
.method-pill .m-desc { font-size: .66rem; color: #94a3b8; margin-top: 2px; display: block; }
.tool-action-btn {
  width: 100%;
  border: 1px solid color-mix(in srgb, var(--accent) 35%, var(--border) 65%);
  border-radius: 11px;
  background: color-mix(in srgb, var(--bg-solid) 80%, transparent);
  color: var(--text);
  padding: 9px 11px;
  text-align: left;
  font-size: .78rem;
  font-weight: 700;
  cursor: pointer;
}
.tool-action-btn small {
  display: block;
  margin-top: 3px;
  color: var(--text-muted);
  font-size: .68rem;
  font-weight: 500;
}
.tool-action-btn:hover {
  border-color: color-mix(in srgb, var(--accent) 60%, var(--border) 40%);
  background: color-mix(in srgb, var(--accent-subtle) 76%, transparent);
}
.tool-note {
  margin-top: 4px;
  color: var(--text-muted);
  font-size: .68rem;
  line-height: 1.4;
  padding: 0 3px;
}
.tool-inline-kbd {
  font-family: var(--mono);
  font-size: .66rem;
  border: 1px solid color-mix(in srgb, var(--border) 70%, transparent);
  border-radius: 6px;
  padding: 2px 6px;
  color: var(--text-secondary);
  background: color-mix(in srgb, var(--bg-solid) 80%, transparent);
}
.example-tutorial-card {
  border: 1px solid rgba(148,163,184,.2);
  border-radius: 18px;
  padding: 14px;
  background: linear-gradient(180deg, rgba(15,23,42,.58), rgba(15,23,42,.34));
}
[data-theme="light"] .example-tutorial-card { background: rgba(255,255,255,.74); }
.example-tutorial-inner { display: grid; grid-template-columns: minmax(0,1.14fr) minmax(0,.86fr); gap: 14px; align-items: stretch; }
.example-meta-line { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
.example-badge {
  font-size: .58rem;
  text-transform: uppercase;
  letter-spacing: .09em;
  font-weight: 800;
  border-radius: 999px;
  padding: 2px 8px;
  border: 1px solid rgba(59,130,246,.35);
  color: #67e8f9;
  background: rgba(34,211,238,.12);
}
[data-theme="light"] .example-badge {
  border-color: rgba(71,85,105,.42);
  color: #1f3a57;
  background: rgba(100,116,139,.16);
}
.example-blocks { font-size: .62rem; letter-spacing: .08em; text-transform: uppercase; color: #64748b; font-weight: 700; }
.example-main-title { font-size: 1.04rem; font-weight: 800; color: #e2e8f0; margin-bottom: 6px; }
[data-theme="light"] .example-main-title { color: #111827; }
.example-main-desc { font-size: .82rem; color: #94a3b8; line-height: 1.5; margin-bottom: 10px; }
.example-cta-row { display: flex; gap: 8px; margin-top: 6px; }
.example-cta {
  border: 1px solid rgba(59,130,246,.45);
  border-radius: 10px;
  background: rgba(30,64,175,.25);
  color: #dbeafe;
  font-size: .74rem;
  font-weight: 700;
  padding: 8px 11px;
  cursor: pointer;
}
.example-cta:hover { background: rgba(30,64,175,.34); }
.example-cta.alt {
  border-color: rgba(148,163,184,.32);
  background: rgba(15,23,42,.36);
  color: #cbd5e1;
}
[data-theme="light"] .example-cta { background: rgba(219,234,254,.95); color: #1e3a8a; }
[data-theme="light"] .example-cta.alt { background: rgba(255,255,255,.92); color: #334155; }
.example-flow-board {
  border: 1px solid rgba(148,163,184,.2);
  border-radius: 14px;
  padding: 12px;
  background: radial-gradient(circle at 0 0, rgba(37,99,235,.1), transparent 55%), rgba(2,6,23,.35);
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 8px;
  overflow: hidden;
}
[data-theme="light"] .example-flow-board { background: rgba(241,245,249,.9); }
.example-flow-node {
  min-width: 90px;
  border: 1px solid rgba(99,102,241,.28);
  border-radius: 10px;
  padding: 7px 8px;
  background: rgba(15,23,42,.45);
}
[data-theme="light"] .example-flow-node { background: rgba(255,255,255,.96); }
.example-flow-node b { display: block; font-size: .58rem; text-transform: uppercase; letter-spacing: .08em; color: #93c5fd; margin-bottom: 4px; }
.example-flow-node span { font-family: var(--mono); font-size: .68rem; color: #e2e8f0; word-break: break-all; }
[data-theme="light"] .example-flow-node span { color: #334155; }
[data-theme="light"] .studio-left .card,
[data-theme="light"] .studio-right .card,
[data-theme="light"] .studio-main .card {
  background: color-mix(in srgb, var(--bg-card) 97%, transparent);
  border-color: color-mix(in srgb, #7f93a8 58%, var(--border) 42%);
}
[data-theme="light"] .node-head {
  background: color-mix(in srgb, #c2cfdb 92%, transparent);
  color: #23364a;
  border-bottom-color: color-mix(in srgb, #8195aa 46%, transparent);
}
[data-theme="light"] .node-head .node-id {
  color: #1f3550;
  font-weight: 700;
  background: color-mix(in srgb, #dde6ef 98%, transparent);
  border-color: color-mix(in srgb, #6f869d 64%, transparent);
}
[data-theme="light"] .method-node .node-head {
  background: linear-gradient(180deg, rgba(102,76,180,.30), rgba(102,76,180,.20));
  color: #23364a;
}
[data-theme="light"] .method-node .method-pill-preview { color: #17385e; }
[data-theme="light"] .method-node .method-mini { color: #3b5169; }
[data-theme="light"] .method-remove {
  color: #20374f;
  border-color: color-mix(in srgb, #6f869d 56%, var(--border) 44%);
  background: color-mix(in srgb, #e2eaf2 92%, transparent);
}
[data-theme="light"] .workflow-canvas {
  background: radial-gradient(1200px 520px at 20% 0%, rgba(19,91,236,.10), transparent 60%),
              radial-gradient(900px 440px at 100% 80%, rgba(34,197,94,.08), transparent 60%),
              linear-gradient(to bottom right, rgba(210,220,230,.90), rgba(203,214,225,.92));
}
[data-theme="light"] .flow-grid { opacity: .42; }
[data-theme="light"] .workflow-ctrl-btn {
  border-color: color-mix(in srgb, #70859a 58%, var(--border) 42%);
  background: color-mix(in srgb, #dde6ef 94%, transparent);
  color: #33495f;
}
[data-theme="light"] .workflow-ctrl-btn:hover { color: #17385e; border-color: #2b4d76; }
[data-theme="light"] .pattern-help { color: #445a71; }
[data-theme="light"] .toolbox-head,
[data-theme="light"] .tool-cat { color: #32475e; }
[data-theme="light"] .tool-action-btn { color: #24374c; }
[data-theme="light"] .tool-action-btn small { color: #4a5f75; }
[data-theme="light"] .toolbox-search {
  background: color-mix(in srgb, #e7edf4 96%, transparent);
  color: #1c3146;
  border-color: color-mix(in srgb, #7d92a8 62%, var(--border) 38%);
}
.example-flow-conn { min-width: 20px; height: 2px; background: linear-gradient(90deg, rgba(59,130,246,.8), rgba(168,85,247,.8)); border-radius: 999px; }
@media(max-width:900px){ .example-tutorial-inner { grid-template-columns: 1fr; } }
.studio-left .card, .studio-right .card, .studio-main .card {
  background: color-mix(in srgb, var(--bg-card) 82%, transparent);
  border-color: color-mix(in srgb, var(--border) 70%, transparent);
  border-radius: 14px;
}
.studio-left .card-body, .studio-right .card-body, .studio-main .card-body { padding: 14px; }
.studio-left .field-label, .studio-main .field-label, .studio-right .field-label { font-size: .65rem; letter-spacing: .09em; }
.studio-main { position: relative; }
.workflow-canvas {
  position: relative; min-height: calc(100vh - 118px); padding: 20px; overflow: hidden;
  background: radial-gradient(1200px 520px at 20% 0%, color-mix(in srgb, var(--accent) 12%, transparent), transparent 60%),
              radial-gradient(900px 440px at 100% 80%, color-mix(in srgb, #22c55e 10%, transparent), transparent 60%),
              linear-gradient(to bottom right, color-mix(in srgb, var(--bg-card) 86%, transparent), color-mix(in srgb, var(--bg-solid) 84%, transparent));
  display: grid; grid-template-columns: repeat(2, minmax(320px, 1fr)); gap: 16px; align-content: start;
}
.flow-grid {
  position: absolute; inset: 0;
  background-image:
    linear-gradient(color-mix(in srgb, var(--accent) 8%, transparent) 1px, transparent 1px),
    linear-gradient(90deg, color-mix(in srgb, var(--accent) 8%, transparent) 1px, transparent 1px);
  background-size: 32px 32px;
  opacity: .32;
  pointer-events: none;
}
.flow-link {
  position: absolute; height: 2px; border-radius: 999px; z-index: 1; left: 0; top: 0; width: 0;
  background: linear-gradient(90deg, rgba(19,91,236,.78), rgba(52,211,153,.72), rgba(19,91,236,.78));
  background-size: 220% 100%;
  box-shadow: 0 0 18px rgba(19,91,236,.28);
  pointer-events: none;
  animation: flow-drift 4.8s linear infinite, flow-pulse 2.6s ease-in-out infinite;
}
.flow-link::after {
  content: none;
}
.flow-node {
  position: relative; z-index: 2;
  border: 1px solid color-mix(in srgb, var(--border) 66%, transparent);
  background: color-mix(in srgb, var(--bg-card) 92%, transparent);
  box-shadow: 0 12px 26px rgba(2,6,23,.22);
}
.node-pattern { border-color: color-mix(in srgb, #3b82f6 45%, var(--border) 55%); }
.node-options { border-color: color-mix(in srgb, #a855f7 40%, var(--border) 60%); }
.node-examples { border-color: color-mix(in srgb, #22c55e 36%, var(--border) 64%); }
.flow-node::before, .flow-node::after {
  content: ''; position: absolute; top: 50%; width: 10px; height: 10px; border-radius: 999px;
  background: color-mix(in srgb, var(--accent) 86%, #fff 14%);
  transform: translateY(-50%);
  box-shadow: 0 0 14px rgba(19,91,236,.35);
}
.flow-node::before { left: -5px; }
.flow-node::after { right: -5px; }
.node-port {
  position: absolute;
  top: 50%;
  width: 9px;
  height: 9px;
  border-radius: 999px;
  transform: translateY(-50%);
  border: 1px solid rgba(148,163,184,.4);
  background: color-mix(in srgb, var(--accent) 84%, #fff 16%);
  box-shadow: 0 0 10px rgba(19,91,236,.24);
  pointer-events: none;
}
.node-port.in { left: -5px; }
.node-port.out { right: -5px; }
.node-head {
  display: flex; align-items: center; justify-content: space-between;
  border-bottom: 1px solid color-mix(in srgb, var(--border) 55%, transparent);
  padding: 9px 12px; font-size: .64rem; letter-spacing: .11em; text-transform: uppercase; color: var(--text-muted);
  background: color-mix(in srgb, var(--bg-solid) 78%, transparent);
}
.node-head .node-title { display: inline-flex; align-items: center; gap: 8px; font-weight: 700; }
.node-handle { opacity: .55; font-size: .78rem; letter-spacing: .1em; cursor: grab; user-select: none; }
.node-head .node-id {
  font-family: var(--mono);
  font-size: .62rem;
  color: #93a4bf;
  border: 1px solid color-mix(in srgb, var(--border) 72%, transparent);
  border-radius: 999px;
  padding: 2px 7px;
  letter-spacing: .04em;
}
.node-step-preview {
  display: none;
  border-top: 1px solid color-mix(in srgb, var(--border) 55%, transparent);
  background: color-mix(in srgb, var(--bg-solid) 86%, transparent);
  padding: 7px 10px 8px;
  cursor: pointer;
}
.node-step-head { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 4px; }
.node-step-title { font-size: .61rem; text-transform: uppercase; letter-spacing: .08em; font-weight: 700; color: var(--text-muted); }
.node-step-meta { font-size: .62rem; color: var(--text-muted); }
.node-step-lines {
  margin: 0;
  font-family: var(--mono);
  font-size: .71rem;
  line-height: 1.35;
  color: var(--text-secondary);
  white-space: pre-wrap;
  word-break: break-word;
  max-height: none;
  overflow: hidden;
}
.node-step-preview:hover {
  background: color-mix(in srgb, var(--bg-solid) 80%, transparent);
}
[data-theme="light"] .node-step-preview {
  background: color-mix(in srgb, #e4ebf3 94%, transparent);
  border-top-color: color-mix(in srgb, #7f93a8 42%, transparent);
}
[data-theme="light"] .node-step-title { color: #334b63; }
[data-theme="light"] .node-step-meta { color: #476079; }
[data-theme="light"] .node-step-lines { color: #243a50; }
.node-pattern { grid-column: 1; grid-row: 1; }
.node-options { grid-column: 2; grid-row: 1; }
.node-options .options-grid { grid-template-columns: 1fr; }
.node-examples { grid-column: 1; grid-row: 2; }
.node-examples .card-body { padding-top: 10px; }
.flow-builder {
  border: 1px dashed color-mix(in srgb, var(--border) 74%, transparent);
  border-radius: 9px;
  padding: 10px;
  background: color-mix(in srgb, var(--bg-solid) 84%, transparent);
  margin-bottom: 10px;
}
.flow-builder-head {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
  margin-bottom: 8px;
}
.flow-builder-head .field-label { margin-bottom: 0; }
.flow-builder-clear {
  border: 1px solid var(--border);
  background: transparent;
  color: var(--text-muted);
  border-radius: 7px;
  padding: 5px 8px;
  font-size: .7rem;
  cursor: pointer;
}
.flow-builder-clear:hover { color: var(--text); border-color: var(--accent); }
.flow-dropzone {
  min-height: 48px;
  border: 1px dashed color-mix(in srgb, var(--accent) 30%, var(--border) 70%);
  border-radius: 8px;
  padding: 7px;
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  align-items: center;
}
.flow-dropzone.drag-over {
  background: color-mix(in srgb, var(--accent-subtle) 75%, transparent);
  border-color: color-mix(in srgb, var(--accent) 65%, var(--border) 35%);
}
.flow-empty {
  color: var(--text-muted);
  font-size: .74rem;
}
.flow-item {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  border: 1px solid color-mix(in srgb, var(--accent) 42%, var(--border) 58%);
  border-radius: 999px;
  padding: 4px 6px 4px 10px;
  background: color-mix(in srgb, var(--accent-subtle) 70%, transparent);
  font-family: var(--mono);
  font-size: .72rem;
  color: var(--text);
  cursor: grab;
}
.flow-item:active { cursor: grabbing; }
.flow-item .flow-x {
  width: 19px;
  height: 19px;
  border-radius: 999px;
  border: 1px solid color-mix(in srgb, var(--border) 70%, transparent);
  background: transparent;
  color: var(--text-muted);
  font-size: .72rem;
  line-height: 1;
  cursor: pointer;
}
.flow-item .flow-x:hover { color: var(--red); border-color: color-mix(in srgb, var(--red) 55%, var(--border) 45%); }
.method-node .card-body { padding: 10px 12px; }
.method-node .method-pill-preview { font-family: var(--mono); font-size: .84rem; color: #c7d2fe; font-weight: 700; }
.method-node .method-mini { font-size: .66rem; color: #94a3b8; margin-top: 3px; }
.method-edit-inline {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-top: 6px;
}
.method-edit-input {
  flex: 1;
  min-width: 0;
  font-family: var(--mono);
  font-size: .78rem;
  border: 1px solid color-mix(in srgb, var(--border) 72%, transparent);
  border-radius: 8px;
  padding: 5px 8px;
  background: color-mix(in srgb, var(--bg-solid) 84%, transparent);
  color: var(--text);
}
.method-edit-save, .method-edit-cancel {
  border: 1px solid color-mix(in srgb, var(--border) 72%, transparent);
  border-radius: 8px;
  padding: 5px 8px;
  font-size: .72rem;
  cursor: pointer;
  background: color-mix(in srgb, var(--bg-solid) 84%, transparent);
  color: var(--text-secondary);
}
.method-edit-save:hover { color: var(--accent); border-color: color-mix(in srgb, var(--accent) 58%, var(--border) 42%); }
.method-edit-cancel:hover { color: var(--red); border-color: color-mix(in srgb, var(--red) 58%, var(--border) 42%); }
.method-node.compact .node-head { padding: 7px 9px; font-size: .58rem; }
.method-node.compact .method-pill-preview { font-size: .76rem; }
.method-node.compact .method-mini { font-size: .6rem; }
.method-node.selected {
  border-color: color-mix(in srgb, var(--accent) 74%, var(--border) 26%);
  box-shadow: 0 0 0 1px color-mix(in srgb, var(--accent) 45%, transparent), 0 14px 30px rgba(2,6,23,.25);
}
.method-node .method-mini .source-dot {
  width: 6px;
  height: 6px;
  border-radius: 999px;
  display: inline-block;
  margin-right: 5px;
  transform: translateY(-1px);
}
.method-node .method-mini .source-dot.global { background: #60a5fa; }
.method-node .method-mini .source-dot.pattern { background: #22c55e; }
.method-legend {
  margin-top: 10px;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  font-size: .68rem;
  color: var(--text-muted);
}
.method-legend-item {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  border: 1px solid color-mix(in srgb, var(--border) 72%, transparent);
  border-radius: 999px;
  padding: 4px 8px;
  background: color-mix(in srgb, var(--bg-solid) 85%, transparent);
}
.method-legend-item .source-dot {
  width: 7px;
  height: 7px;
  border-radius: 999px;
}
.method-legend-item .source-dot.global { background: #60a5fa; }
.method-legend-item .source-dot.pattern { background: #22c55e; }
.method-node .node-head { background: color-mix(in srgb, #6d28d9 16%, var(--bg-solid) 84%); }
.mutation-node .node-head { background: color-mix(in srgb, #0f766e 22%, var(--bg-solid) 78%); }
.method-remove {
  border: 1px solid color-mix(in srgb, var(--border) 70%, transparent);
  background: transparent;
  color: var(--text-muted);
  width: 20px;
  height: 20px;
  border-radius: 999px;
  cursor: pointer;
  line-height: 1;
}
.method-remove:hover { color: var(--red); border-color: color-mix(in srgb, var(--red) 50%, var(--border) 50%); }
.method-edit {
  border: 1px solid color-mix(in srgb, var(--border) 70%, transparent);
  background: transparent;
  color: var(--text-muted);
  width: 20px;
  height: 20px;
  border-radius: 999px;
  cursor: pointer;
  line-height: 1;
  margin-right: 6px;
  font-size: .72rem;
}
.method-edit:hover { color: var(--accent); border-color: color-mix(in srgb, var(--accent) 56%, var(--border) 44%); }
.studio-main .pattern-help { font-size: .74rem; }
.studio-main #pattern { min-height: calc(128px * var(--node-scale, 1)); font-size: calc(.92rem * var(--node-scale, 1)); border-radius: 10px; }
.studio-main .gen-bar .btn { padding: 11px 16px; font-size: .92rem; }
.node-output { display: flex; flex-direction: column; }
.node-output #output-wrapper { flex: 1; min-height: 0; }
.node-output #output-area { max-height: none; height: 100%; min-height: 260px; background: color-mix(in srgb, #020617 88%, transparent); color: #dbeafe; border-top: 1px solid color-mix(in srgb, var(--border) 55%, transparent); }
.node-output .empty-state { min-height: 260px; }
.node-output .output-head { background: color-mix(in srgb, var(--bg-solid) 72%, transparent); }
.node-output .output-title { color: #cbd5e1; }
.live-dot {
  display: inline-block; width: 8px; height: 8px; border-radius: 999px;
  background: #22c55e; margin-right: 7px; box-shadow: 0 0 8px rgba(34,197,94,.7);
  animation: live-pulse 1.6s ease-in-out infinite;
}
@keyframes live-pulse {
  0%, 100% { opacity: .7; transform: scale(.92); }
  50% { opacity: 1; transform: scale(1.06); }
}
.preset-row { grid-template-columns: 1fr; }
.preset-actions { display: grid; grid-template-columns: 1fr 1fr 1fr; }
.preset-actions .btn { padding: 8px 10px; font-size: .76rem; }
.examples-row { gap: 8px; }
.example-chip { padding: 7px 10px; border-radius: 9px; }
.ex-pattern { font-size: .76rem; }
.ex-desc { font-size: .7rem; }
.terminal-stats {
  border-top: 1px solid var(--border);
  background: color-mix(in srgb, var(--bg-solid) 86%, transparent);
  padding: 9px 12px;
  display: grid;
  grid-template-columns: repeat(3, minmax(0,1fr));
  gap: 8px;
}
.terminal-stat { font-size: .67rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: .08em; }
.terminal-stat b { display: block; margin-top: 2px; color: var(--text); font-size: .78rem; letter-spacing: 0; text-transform: none; }
.flow-particle {
  position: absolute;
  width: 7px;
  height: 7px;
  border-radius: 50%;
  background: radial-gradient(circle at 30% 30%, #fff 0%, #93c5fd 42%, #38bdf8 100%);
  box-shadow: 0 0 10px rgba(56,189,248,.42);
  z-index: 2;
  pointer-events: none;
  opacity: .86;
}
.flow-particle.p1 { animation: flow-ball-a 3.2s linear infinite; }
.flow-particle.p2 { animation: flow-ball-b 3.2s linear infinite 1.35s; opacity: .72; }
@keyframes flow-drift {
  from { background-position: 0% 0; }
  to { background-position: 220% 0; }
}
@keyframes flow-pulse {
  0%, 100% { opacity: .7; box-shadow: 0 0 12px rgba(19,91,236,.24); }
  50% { opacity: .98; box-shadow: 0 0 20px rgba(19,91,236,.38); }
}
@keyframes flow-ball-a {
  0% { transform: translateX(0) scale(.9); }
  100% { transform: translateX(var(--flow-len, 0px)) scale(1.05); }
}
@keyframes flow-ball-b {
  0% { transform: translateX(0) scale(.88); }
  100% { transform: translateX(var(--flow-len, 0px)) scale(1.02); }
}
.site-footer { padding-top: 10px; }

/* Draggable canvas mode */
.studio-shell {
  grid-template-columns: clamp(208px, 20vw, 280px) minmax(0, 1fr) clamp(272px, 24vw, 356px);
  gap: clamp(8px, 1.1vw, 14px);
  padding: clamp(8px, 1.1vw, 14px);
  height: calc(100dvh - 64px);
  min-height: calc(100vh - 64px);
}
@media(max-width:1520px) and (min-width:1201px) {
  .studio-shell {
    grid-template-columns: clamp(188px, 17vw, 236px) minmax(0, 1fr) clamp(238px, 21vw, 308px);
    gap: clamp(7px, .9vw, 11px);
    padding: clamp(7px, .9vw, 11px);
  }
  .studio-right #output-area { max-height: min(34vh, 260px); }
}
@supports not (height: 100dvh) {
  .studio-shell { height: calc(100vh - 64px); }
}
.studio-left, .studio-main, .studio-right { min-height: 0; }
.studio-left, .studio-right {
  max-height: 100%;
  overflow-y: auto;
  overflow-x: hidden;
}
.workflow-canvas {
  display: block;
  min-height: 100%;
  height: 100%;
  overflow: hidden;
  position: relative;
  padding: clamp(10px, 1.2vw, 18px);
}
.workflow-stage {
  position: relative;
  width: 100%;
  min-width: 0;
  min-height: 100%;
  transform-origin: 0 0;
  --node-scale: 1;
  --node-vscale: 1;
}
.flow-links { position: absolute; inset: 0; pointer-events: none; z-index: 1; display: none !important; }
.workflow-stage.compact-links .flow-links { display: none; }
.workflow-stage.compact-links .flow-particle { display: none !important; }
.workflow-stage.compact-links .flow-node::before,
.workflow-stage.compact-links .flow-node::after { opacity: 0; }
.flow-node {
  position: absolute;
  min-width: clamp(186px, 16vw, 240px);
  max-width: min(42vw, 380px);
  will-change: left, top;
}
.node-pattern { left: clamp(20px, 4vw, 80px); top: clamp(88px, 18vh, 150px); width: calc(clamp(300px, 30vw, 420px) * var(--node-scale)); }
.node-options { left: clamp(470px, 44vw, 700px); top: clamp(120px, 20vh, 190px); width: calc(clamp(260px, 24vw, 348px) * var(--node-scale)); }
.node-output {
  right: clamp(8px, 1vw, 18px);
  left: auto;
  top: clamp(18px, 4vh, 56px);
  width: clamp(280px, 23vw, 360px);
  height: clamp(330px, 62vh, 560px);
  display: flex; flex-direction: column;
}
.node-output #output-wrapper { flex: 1; min-height: 0; }
.node-output #output-area { max-height: none; height: 100%; min-height: 180px; font-size: .82rem; }
.node-output .empty-state { min-height: 180px; }
.node-head { cursor: grab; }
.node-head:active { cursor: grabbing; }
.flow-node.dragging { box-shadow: 0 16px 34px rgba(2,6,23,.34); }
.workflow-controls {
  position: absolute;
  left: 16px;
  bottom: 16px;
  z-index: 4;
  display: flex;
  gap: 6px;
}
.workflow-ctrl-btn {
  width: 36px; height: 36px;
  border-radius: 8px;
  border: 1px solid color-mix(in srgb, var(--border) 70%, transparent);
  background: color-mix(in srgb, var(--bg-card) 78%, transparent);
  color: var(--text-muted);
  font-size: 1rem;
  cursor: pointer;
}
.workflow-ctrl-btn:hover { color: var(--text); border-color: var(--accent); }
.workflow-ctrl-btn.wide { width: auto; min-width: 96px; padding: 0 10px; font-size: .72rem; font-weight: 700; }
.studio-right #output-card { position: sticky; top: 10px; max-height: calc(100dvh - 86px); display: flex; flex-direction: column; }
.studio-right #output-wrapper { flex: 1; min-height: 0; }
.studio-right #output-area { height: auto; min-height: 170px; max-height: min(36vh, 300px); overflow-y: auto; background: color-mix(in srgb, #020617 88%, transparent); color: #dbeafe; border-top: 1px solid color-mix(in srgb, var(--border) 55%, transparent); font-size: .82rem; }
.studio-right .empty-state { min-height: 220px; }
.studio-right .output-head { background: color-mix(in srgb, var(--bg-solid) 72%, transparent); }
.studio-right .output-title { color: #cbd5e1; }
[data-theme="light"] .studio-right #output-area {
  background: color-mix(in srgb, #edf3f9 98%, transparent);
  border-top: 1px solid color-mix(in srgb, #98abc0 72%, transparent);
  color: #4f647a;
}
[data-theme="light"] .studio-right .output-title { color: #3a4f66; }
[data-theme="light"] .studio-right .output-stats { color: #445a71; }
.starter-templates {
  margin-top: 12px;
  display: grid;
  gap: 8px;
  width: 100%;
  max-width: 360px;
}
.starter-btn {
  border: 1px solid color-mix(in srgb, var(--accent) 35%, var(--border) 65%);
  border-radius: 9px;
  padding: 7px 10px;
  background: color-mix(in srgb, var(--bg-solid) 84%, transparent);
  color: var(--text-secondary);
  font-size: .72rem;
  text-align: left;
  cursor: pointer;
}
.starter-btn b {
  display: block;
  font-family: var(--mono);
  color: var(--text);
  font-size: .7rem;
}
.starter-btn:hover {
  border-color: color-mix(in srgb, var(--accent) 58%, var(--border) 42%);
  background: color-mix(in srgb, var(--accent-subtle) 76%, transparent);
}

@media(max-width:1360px) and (min-width:1021px) {
  .node-pattern { left: clamp(16px, 2.5vw, 48px); width: clamp(270px, 30vw, 360px); }
  .node-options { left: clamp(410px, 42vw, 620px); width: clamp(240px, 22vw, 320px); }
  .node-output { width: clamp(252px, 22vw, 320px); height: clamp(300px, 58vh, 500px); }
}
@media(max-width:1020px) {
  .studio-shell { grid-template-columns: 1fr; height: auto; min-height: 0; }
  .studio-left, .studio-right { max-height: none; overflow: visible; }
  .workflow-canvas { min-height: 0; height: auto; }
  .flow-link { display: none; }
  .flow-particle { display: none; }
  .workflow-stage { min-width: auto; min-height: auto; transform: none !important; width: auto !important; height: auto !important; }
  .flow-node { position: relative; left: auto !important; top: auto !important; width: 100% !important; max-width: none; margin-bottom: 12px; }
  .studio-right #output-card { position: relative; max-height: none; }
  .node-options .options-grid { grid-template-columns: 1fr 1fr; }
}
@media(max-width:820px) {
  .studio-shell { grid-template-columns: 1fr; padding: 10px; }
  .studio-header { height: 56px; padding: 0 12px; }
  .brand-sub, .project-chip, .run-btn { display: none; }
  .workflow-canvas { padding: 10px; }
  .node-options .options-grid { grid-template-columns: 1fr; }
  .terminal-stats { grid-template-columns: 1fr; }
}
body.viewport-forced-simple #mode-toggle-btn { display: none; }
.workflow-stage.workflow-tight .node-options .card-body { padding: 10px 11px; }
.workflow-stage.workflow-tight .node-options .options-grid { gap: 7px; }
.workflow-stage.workflow-tight .node-options .opt-field label { font-size: .64rem; }
.workflow-stage.workflow-tight .node-options .opt-field input,
.workflow-stage.workflow-tight .node-options .opt-field select {
  padding: 6px 8px;
  font-size: .74rem;
}
.workflow-stage.workflow-tight .pattern-help { font-size: .67rem; line-height: 1.35; }
.workflow-stage.workflow-tight #pattern { min-height: calc(94px * var(--node-vscale, 1)); }

/* Simplified mode: same engine/state, reduced UI complexity */
body.simplified-mode .studio-shell {
  grid-template-columns: minmax(0, 940px);
  justify-content: center;
  height: auto;
  min-height: 0;
}
body.simplified-mode .studio-main { order: 2; }
body.simplified-mode .studio-right { order: 1; margin-bottom: 10px; }
body.simplified-mode .studio-left { display: none; }
body.simplified-mode .studio-right { display: block; overflow: visible; max-height: none; }
body.simplified-mode .workflow-canvas {
  min-height: 0;
  height: auto;
  background: none;
  padding: 0;
  overflow: visible;
}
body.simplified-mode .flow-grid,
body.simplified-mode .flow-links,
body.simplified-mode #method-node-layer,
body.simplified-mode .method-legend,
body.simplified-mode .workflow-controls,
body.simplified-mode .node-port,
body.simplified-mode .node-head .node-id { display: none !important; }
body.simplified-mode .workflow-stage {
  transform: none !important;
  width: auto !important;
  height: auto !important;
  min-height: 0 !important;
}
body.simplified-mode .flow-node {
  position: relative !important;
  left: auto !important;
  top: auto !important;
  width: 100% !important;
  max-width: none !important;
  margin-bottom: 12px;
}
body.simplified-mode .node-head {
  cursor: default;
}
body.simplified-mode .node-head .node-handle { display: none; }
body.simplified-mode #simple-reset-btn { display: inline-flex; }
body.simplified-mode .studio-right #output-card {
  position: relative;
  top: 0;
  max-height: min(56vh, 460px);
}
body.simplified-mode .studio-right #output-wrapper {
  flex: 1;
  min-height: 0;
}
body.simplified-mode .studio-right #output-area {
  height: auto !important;
  min-height: 160px;
  max-height: min(44vh, 340px);
  overflow-y: auto;
}
body.simplified-mode .studio-right .empty-state {
  min-height: 160px;
}
body.simplified-mode .studio-right .starter-templates {
  display: none;
}
</style>
</head>
<body>
<div id="ambient-bg" aria-hidden="true"><div id="ambient-grain"></div></div>

<div class="studio-header">
  <div class="header-stack">
    <div class="brand">
      <span class="brand-logo">COOKED</span>
      <span class="brand-sub">Wordlist Generator</span>
    </div>
  </div>
  <div class="studio-actions">
    <button class="mode-btn" id="mode-toggle-btn" onclick="toggleSimplifiedMode()">Simplified Mode</button>
    <button class="mode-btn" id="simple-reset-btn" onclick="resetSimplifiedMode()">Reset</button>
    <button class="hdr-text-btn" onclick="startOnboarding(true)" title="Replay quick tutorial">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:14px;height:14px"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
      Take Tour
    </button>
    <button class="hdr-text-btn" onclick="openDocsModal('recipes')" title="Receipes, workflows, and syntax">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:14px;height:14px"><path d="M8 6h13"/><path d="M8 12h13"/><path d="M8 18h13"/><path d="M3 6h.01"/><path d="M3 12h.01"/><path d="M3 18h.01"/></svg>
      Receipes
    </button>
    <button class="hdr-text-btn" onclick="openMethodModal()" title="Method reference">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:14px;height:14px"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>
      Methods
    </button>
    
    <button class="hdr-btn" onclick="toggleTheme()" id="theme-btn" title="Toggle theme">
      <svg id="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
      <svg id="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
    </button>
  </div>
</div>

<div class="studio-shell">
  <aside class="studio-left">
    <section class="glass">
      <div class="toolbox-head">Workflow Library</div>
      <div class="toolbox-search-wrap">
        <input class="toolbox-search" type="text" placeholder="Search blocks & actions..." />
      </div>
      <div class="toolbox-list">
        <div class="tool-cat">Transformations</div>
        <button class="tool-action-btn" type="button" id="tool-open-methods">
          Ingredients
          <small>Browse all methods with examples, params, and one-click insert.</small>
        </button>
        <button class="tool-action-btn" type="button" id="tool-open-learn">
          Open Receipes
          <small>Recipes and practical syntax examples in one place.</small>
        </button>
        <button class="tool-action-btn" type="button" id="tool-add-mutation-node">
          Add Mutation Node
          <small>Insert a mutation step with profile + custom words as node controls.</small>
        </button>
        <button class="tool-action-btn" type="button" id="tool-clear-all">
          Clear All
          <small>Reset input, options, variables/files, workflow nodes, and output.</small>
        </button>
        <div class="tool-note">Tip: type a method like <span class="tool-inline-kbd">md5</span> or <span class="tool-inline-kbd">regex</span> then press <span class="tool-inline-kbd">Enter</span>.</div>
      </div>
      <div class="method-palette" id="method-palette"></div>
    </section>

    <div class="card">
      <div class="card-body">
        <div class="section-head">
          <div class="field-label">Presets</div>
          <span class="help" data-tip="Save and reuse full setup (pattern, variables, options) in this browser only.">?</span>
        </div>
        <div class="preset-row">
          <select id="preset-select" class="preset-select" onchange="loadSelectedPreset()">
            <option value="">Select preset...</option>
          </select>
          <input id="preset-name" class="preset-name" type="text" placeholder="Preset name" />
          <div class="preset-actions">
            <button class="btn btn-ghost preset-btn" onclick="savePreset()">Save</button>
            <button class="btn btn-ghost preset-btn" onclick="runSelectedPreset()">Run</button>
            <button class="btn btn-ghost preset-btn" onclick="deletePreset()">Delete</button>
          </div>
        </div>
        <div class="preset-meta">
          <label><input type="checkbox" id="preset-autorestore" onchange="togglePresetAutoRestore(this.checked)" /> Auto-restore last used preset</label>
        </div>
      </div>
    </div>

    <div id="params-section" class="card"><div class="card-body">
      <div class="section-head">
        <div class="field-label">Variables</div>
        <span class="help" data-tip="Use a variable name in pattern (example: p), then map it to values here.">?</span>
      </div>
      <div id="param-rows"></div>
      <button class="add-btn" onclick="addParamRow()">+ Add variable</button>
    </div></div>

    <div id="files-section" class="card"><div class="card-body">
      <div class="section-head">
        <div class="field-label">Files</div>
        <span class="help" data-tip="Map variable names to local files. Each file line is used as a value.">?</span>
      </div>
      <div id="file-rows"></div>
      <button class="add-btn" onclick="addFileRow()">+ Add file</button>
    </div></div>
  </aside>

  <main class="studio-main">
    <div class="workflow-canvas glass">
      <div class="workflow-stage" id="workflow-stage">
        <div class="flow-grid"></div>
        <div class="flow-links" id="flow-links"></div>

        <section class="card flow-node node-pattern">
          <span class="node-port in" aria-hidden="true"></span>
          <span class="node-port out" aria-hidden="true"></span>
          <div class="node-head"><span class="node-title"><span class="node-handle">⋮⋮</span>Input Area</span><span class="node-id">NODE 01</span></div>
          <div class="card-body">
            <div class="section-head">
              <div class="field-label">Input</div>
              <span class="help" data-tip="Main input area. Paste values, ranges, and literals. Space splits columns, comma splits values, dot applies methods.">?</span>
            </div>
            <textarea id="pattern" placeholder="Type or paste input...  e.g.  admin,root _,- pass,secret" spellcheck="false" rows="4" oninput="onPatternChange()" onkeydown="onPatternKey(event)"></textarea>
            <div class="pattern-help"><kbd>space</kbd> separates columns &nbsp;&middot;&nbsp; <kbd>,</kbd> separates values &nbsp;&middot;&nbsp; <kbd>1-100</kbd> ranges &nbsp;&middot;&nbsp; <kbd>.method</kbd> transforms &nbsp;&middot;&nbsp; use <kbd>`text with space`</kbd> to keep spaces in one value</div>
            <div id="warn-pattern" class="warn"></div>
            <div id="col-preview" class="col-preview"></div>
            <div class="gen-bar">
              <button id="btn-generate" class="btn btn-primary" onclick="startGenerate()">Generate<span class="shortcut-hint">&thinsp;Ctrl+Enter</span></button>
              <button id="btn-cancel" class="btn btn-danger" onclick="cancelGenerate()">Cancel</button>
            </div>
          </div>
          <div id="step-preview-input" class="node-step-preview"></div>
        </section>

        <section id="options-section" class="card flow-node node-options">
          <span class="node-port in" aria-hidden="true"></span>
          <span class="node-port out" aria-hidden="true"></span>
          <div class="node-head"><span class="node-title"><span class="node-handle">⋮⋮</span>Transform Rules</span><span class="node-id">NODE 02</span></div>
          <div class="card-body">
            <div class="section-head">
              <div class="field-label">Options</div>
              <span class="help" data-tip="Advanced behavior controls. Leave blank to keep defaults.">?</span>
            </div>
            <div class="options-grid">
              <div class="opt-field"><label>Combine mode <span class="help" data-tip="Cross-product multiplies values by column. Line-by-line pairs values by row index.">?</span></label><select id="opt-mode"><option value="permutation">Cross-product</option><option value="append">Line-by-line</option></select><div class="flow-hint" id="mode-help-text"></div></div>
              <div class="opt-field"><label>Min columns <span class="help" data-tip="Start emitting output only after this many columns are combined.">?</span></label><input type="text" id="opt-min" placeholder="all (default)" /></div>
              <div class="opt-field"><label>Apply to all <span class="help" data-tip="Methods applied to final output lines in order. Example: upper,unique,sortu">?</span></label><input type="text" id="opt-methods" placeholder="e.g. upper,unique,sortu" /><div class="flow-hint">Methods here run as a chain from left to right.</div></div>
              <div class="opt-field"><label>Per-column methods <span class="help" data-tip="Methods per column index. Example: 0:upper;1:lower">?</span></label><input type="text" id="opt-colmethods" placeholder="e.g. 0:upper;1:lower" /></div>
              <div class="opt-field"><label>Append columns <span class="help" data-tip="Columns to append line-by-line. Example: 1,2">?</span></label><input type="text" id="opt-append" placeholder="e.g. 1,2" /></div>
            </div>
            <div id="warn-options" class="warn"></div>
          </div>
          <div id="step-preview-options" class="node-step-preview"></div>
        </section>

        <div id="method-node-layer"></div>
      </div>

      <div class="workflow-controls">
        <button class="workflow-ctrl-btn" title="Zoom in" onclick="zoomWorkflow(0.1)">+</button>
        <button class="workflow-ctrl-btn" title="Zoom out" onclick="zoomWorkflow(-0.1)">-</button>
        <button class="workflow-ctrl-btn wide" title="Undo last workflow change" onclick="undoWorkflowAction()">Undo</button>
        <button class="workflow-ctrl-btn wide" title="Redo workflow change" onclick="redoWorkflowAction()">Redo</button>
        <button class="workflow-ctrl-btn wide" title="Auto arrange nodes" onclick="autoArrangeWorkflow()">Auto Arrange</button>
        <button class="workflow-ctrl-btn wide" title="Delete selected method nodes" onclick="deleteSelectedMethodNodes()">Delete Selected</button>
        <button class="workflow-ctrl-btn" title="Reset layout" onclick="resetWorkflowLayout()">⌂</button>
      </div>
    </div>
  </main>

  <aside class="studio-right">
    <div class="card" id="output-card">
      <div class="output-head">
        <span class="output-title"><span class="live-dot"></span>Results Pane <span class="help" data-tip="Generated results. Copy for quick use, Download for full output.">?</span></span>
        <div class="output-meta">
          <span id="stats" class="output-stats"></span>
          <div class="output-actions">
            <button class="btn btn-ghost" onclick="copyOutput()" id="btn-copy">Copy All</button>
            <button class="btn btn-ghost" onclick="openFullResultsWindow()">Open Full</button>
            <button class="btn btn-ghost" onclick="downloadOutput()">Download</button>
          </div>
        </div>
      </div>
      <div id="progress" class="progress-bar"><div class="spinner"></div><span>Generating...</span></div>
      <div id="output-wrapper">
        <div id="empty-state" class="empty-state">
          <div class="empty-icon">&#128187;</div>
          <h3>No output yet</h3>
          <p>Enter a pattern and hit Generate, or try an example.</p>
        </div>
        <div id="output-area" style="display:none;"></div>
      </div>
      <div class="terminal-stats">
        <div class="terminal-stat">Lines<b id="metric-lines">0</b></div>
        <div class="terminal-stat">Runtime<b id="metric-runtime">0.00s</b></div>
        <div class="terminal-stat">Mode<b id="metric-mode">Cross-product</b></div>
      </div>
    </div>
  </aside>
</div>

<div id="method-modal" class="modal-overlay method-modal-overlay" onclick="if(event.target===this)closeMethodModal()">
  <div class="modal method-modal">
    <div class="modal-head method-modal-head">
      <div class="method-head-row">
        <div>
          <h3>Method Reference</h3>
          <p class="method-sub">Discover and chain transformation methods</p>
        </div>
        <div class="method-nav" aria-hidden="true">
          <button class="method-nav-btn" type="button">Canvas</button>
          <button class="method-nav-btn active" type="button">Methods</button>
          <button class="method-nav-btn" type="button">Collections</button>
        </div>
      </div>
      <button class="modal-close" onclick="closeMethodModal()">&times;</button>
    </div>
    <div class="method-top-search">
      <input type="text" id="method-search-input" class="method-search" placeholder="Search methods (e.g. .md5, .regex, .split)..." oninput="filterMethods(this.value)" />
    </div>
    <div class="method-shell">
      <aside class="method-sidebar">
        <button class="method-side-item active" data-cat="all" onclick="setMethodCategory('all')">All Methods</button>
        <div class="method-side-title">Categories</div>
        <button class="method-side-item" data-cat="string" onclick="setMethodCategory('string')">String</button>
        <button class="method-side-item" data-cat="hashing" onclick="setMethodCategory('hashing')">Hashing</button>
        <button class="method-side-item" data-cat="encoding" onclick="setMethodCategory('encoding')">Encoding</button>
        <button class="method-side-item" data-cat="web" onclick="setMethodCategory('web')">Web</button>
        <button class="method-side-item" data-cat="regex" onclick="setMethodCategory('regex')">Regex</button>
      </aside>
      <main class="method-panel">
        <div id="method-grid" class="method-grid"></div>
      </main>
    </div>
    <div class="method-footer">
      <div class="method-hints"><kbd>ESC</kbd> close <span>|</span> <kbd>ENTER</kbd> insert</div>
      <div class="method-actions">
        <button class="btn btn-ghost" onclick="closeMethodModal()">Cancel</button>
        <button class="btn btn-primary" id="method-insert-btn" onclick="insertSelectedMethod()">Add Method Node</button>
      </div>
    </div>
  </div>
</div>

<div id="examples-modal" class="modal-overlay examples-modal-overlay" onclick="if(event.target===this)closeExamplesModal()">
  <div class="modal examples-modal">
    <div class="modal-head examples-modal-head">
      <div>
        <h3>Examples & Tutorials</h3>
        <p class="examples-sub">Real use cases with ready-to-insert patterns</p>
      </div>
      <button class="modal-close" onclick="closeExamplesModal()">&times;</button>
    </div>
    <div class="examples-top-search">
      <input type="text" id="examples-search-input" class="method-search" placeholder="Search examples (e.g. regex, md5, url, append)..." oninput="filterExamples(this.value)" />
    </div>
    <div class="examples-shell">
      <aside class="examples-sidebar">
        <button class="example-side-item active" data-cat="all" onclick="setExampleCategory('all')">All Examples</button>
        <div class="method-side-title">Categories</div>
        <button class="example-side-item" data-cat="ranges" onclick="setExampleCategory('ranges')">Ranges</button>
        <button class="example-side-item" data-cat="wordlists" onclick="setExampleCategory('wordlists')">Wordlists</button>
        <button class="example-side-item" data-cat="hashing" onclick="setExampleCategory('hashing')">Hashing</button>
        <button class="example-side-item" data-cat="encoding" onclick="setExampleCategory('encoding')">Encoding</button>
        <button class="example-side-item" data-cat="url" onclick="setExampleCategory('url')">URL Parsing</button>
        <button class="example-side-item" data-cat="regex" onclick="setExampleCategory('regex')">Regex</button>
        <button class="example-side-item" data-cat="json" onclick="setExampleCategory('json')">JSON</button>
        <button class="example-side-item" data-cat="credentials" onclick="setExampleCategory('credentials')">Credentials</button>
        <button class="example-side-item" data-cat="filters" onclick="setExampleCategory('filters')">Filters</button>
        <button class="example-side-item" data-cat="smart" onclick="setExampleCategory('smart')">Smart Transform</button>
        <button class="example-side-item" data-cat="pipelines" onclick="setExampleCategory('pipelines')">Pipelines</button>
      </aside>
      <main class="examples-panel">
        <div id="examples-grid" class="examples-grid"></div>
      </main>
    </div>
    <div class="examples-footer">
      <div class="method-hints"><kbd>ESC</kbd> close <span>|</span> <kbd>ENTER</kbd> insert</div>
      <div class="examples-actions">
        <button class="btn btn-ghost" onclick="closeExamplesModal()">Cancel</button>
        <button class="btn btn-ghost" id="example-insert-run-btn" onclick="insertSelectedExample(true)">Add + Run</button>
        <button class="btn btn-primary" id="example-insert-btn" onclick="insertSelectedExample(false)">Add Workflow</button>
      </div>
    </div>
  </div>
</div>

<div id="docs-modal" class="modal-overlay docs-modal-overlay" onclick="if(event.target===this)closeDocsModal()">
  <div class="modal docs-modal">
    <div class="modal-head">
      <div>
        <h3>Receipes</h3>
        <p class="examples-sub">Practical workflows and syntax examples.</p>
      </div>
      <button class="modal-close" onclick="closeDocsModal()">&times;</button>
    </div>
    <div class="docs-shell">
      <aside class="docs-sidebar">
        <button class="docs-side-item active" data-docs-tab="recipes" onclick="setDocsTab('recipes')">Recipes</button>
        <button class="docs-side-item" data-docs-tab="syntax" onclick="setDocsTab('syntax')">Syntax</button>
      </aside>
      <main class="docs-main" id="docs-main"></main>
    </div>
    <div class="examples-footer">
      <div class="method-hints"><kbd>ESC</kbd> close</div>
      <div class="examples-actions">
        <button class="btn btn-ghost" onclick="closeDocsModal()">Close</button>
      </div>
    </div>
  </div>
</div>

<footer class="site-footer">
  <div>Inspired by <a href="https://github.com/glitchedgitz/cook" target="_blank" rel="noopener">github.com/glitchedgitz/cook</a></div>
  <div>Built using <span class="claude-credit">Claude Code</span> by <a href="https://github.com/prnig" target="_blank" rel="noopener">@prnig</a></div>
</footer>

<div id="theme-chooser" class="theme-chooser-overlay">
  <div class="theme-chooser">
    <h2>What type of hacker are you?</h2>
    <p>Pick your visual mode: dark stealth or light clarity.</p>
    <div class="theme-choices">
      <button class="theme-choice" onclick="chooseTheme('dark')">
        <span class="choice-icon">&#127761;</span>
        <span class="choice-label">Black Hat</span>
        <span class="choice-sub">Dark theme for stealth ops</span>
      </button>
      <button class="theme-choice" onclick="chooseTheme('light')">
        <span class="choice-icon">&#9728;&#65039;</span>
        <span class="choice-label">White Hat</span>
        <span class="choice-sub">Light theme for clean recon</span>
      </button>
    </div>
  </div>
</div>

<div id="onboarding-overlay" class="onboarding-overlay" aria-hidden="true">
  <div class="onboarding-dim"></div>
  <div id="onboarding-spotlight" class="onboarding-spotlight"></div>
  <div class="onboarding-card" role="dialog" aria-modal="true" aria-labelledby="onboarding-title">
    <div class="onboarding-top">
      <div id="onboarding-step" class="onboarding-step">Quick Tour</div>
      <button class="onboarding-close" onclick="skipOnboarding()" aria-label="Skip tutorial">&times;</button>
    </div>
    <div id="onboarding-title" class="onboarding-title">Welcome to COOKED</div>
    <div id="onboarding-body" class="onboarding-body"></div>
    <div id="onboarding-flow" class="onboarding-flow" style="display:none;">
      <div class="onboarding-flow-track">
        <div class="flow-dot active">Input</div>
        <div class="flow-arrow"></div>
        <div class="flow-dot active">Methods</div>
        <div class="flow-arrow"></div>
        <div class="flow-dot active">Preview</div>
      </div>
    </div>
    <div class="onboarding-actions">
      <div class="onboarding-actions-left">
        <button id="onboarding-try" class="tour-btn" type="button" style="display:none;" onclick="runOnboardingAction()">Try this step</button>
      </div>
      <div class="onboarding-actions-right">
        <button class="tour-btn" type="button" onclick="skipOnboarding()">Skip</button>
        <button id="onboarding-back" class="tour-btn" type="button" onclick="prevOnboardingStep()">Back</button>
        <button id="onboarding-next" class="tour-btn primary" type="button" onclick="nextOnboardingStep()">Next</button>
      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>
<div id="test-results"></div>

<script>
const BUILD_ID = 'preview7-fix-2026-02-19-3';
console.info('[COOKED]', BUILD_ID);

// ============================================================
// Cook Parser — ported from pkg/parse/syntax.go + pkg/config/parse.go
// ============================================================
const CookParser = {
  splitValues(p) {
    const s = [];
    let tmp = '';
    let insideRaw = false;
    let insideBrackets = false;
    const normalized = String(p || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    for (const c of normalized) {
      if ((c === ',' || c === '\n') && !insideRaw && !insideBrackets) { s.push(tmp); tmp = ''; continue; }
      if (c === '`') { insideRaw = !insideRaw; }
      if (!insideRaw && c === '[') insideBrackets = true;
      if (!insideRaw && c === ']') insideBrackets = false;
      tmp += c;
    }
    s.push(tmp);
    return s;
  },

  splitMethods(p) {
    const s = [];
    let tmp = '';
    let insideRaw = false;
    let insideBrackets = false;
    for (const c of p) {
      if (c === '.' && !insideBrackets && !insideRaw) { s.push(tmp); tmp = ''; continue; }
      if (c === '`') insideRaw = !insideRaw;
      if (!insideRaw && c === '[') insideBrackets = true;
      if (!insideRaw && c === ']') insideBrackets = false;
      tmp += c;
    }
    s.push(tmp);
    return s;
  },

  readSqBr(cmd) {
    const i = cmd.indexOf('[');
    return [cmd.slice(0, i), cmd.slice(i + 1, cmd.length - 1)];
  },

  rawInput(value, array) {
    if (value === '`') return true;
    if (value.startsWith('`') && value.endsWith('`')) {
      array.push(value.slice(1, -1));
      return true;
    }
    return false;
  },

  parseRanges(p, array) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    const dashCount = (p.match(/-/g) || []).length;
    if (dashCount !== 1) return false;

    const parts = p.split('-');
    const from = parts[0], to = parts[1];
    if (from === '' || to === '') return false;

    const startN = parseInt(from, 10), stopN = parseInt(to, 10);
    if (!isNaN(startN) && !isNaN(stopN) && /^\d+$/.test(from) && /^\d+$/.test(to)) {
      const minPad = Math.min(from.length, to.length);
      if (startN <= stopN) {
        for (let n = startN; n <= stopN; n++) {
          const s = String(n);
          const pad = minPad - s.length;
          array.push(pad > 0 ? '0'.repeat(pad) + s : s);
        }
      } else {
        for (let n = startN; n >= stopN; n--) {
          const s = String(n);
          const pad = minPad - s.length;
          array.push(pad > 0 ? '0'.repeat(pad) + s : s);
        }
      }
      return true;
    }

    if (from.length === 1 && to.length === 1 && chars.includes(from) && chars.includes(to)) {
      const si = chars.indexOf(from), ei = chars.indexOf(to);
      if (si <= ei) {
        for (let i = si; i <= ei; i++) array.push(chars[i]);
        return true;
      }
    }
    return false;
  },

  repeatOp(value, array) {
    if (value.includes('**')) {
      const parts = value.split('**');
      const input = parts.slice(0, -1).join('**');
      const last = parts[parts.length - 1];
      const n = parseInt(last, 10);
      if (!isNaN(n) && /^\d+$/.test(last)) {
        for (let i = 0; i < n; i++) array.push(input);
        return true;
      }
    }

    if (value.includes('*')) {
      const parts = value.split('*');
      const input = parts.slice(0, -1).join('*');
      const last = parts[parts.length - 1];

      if ((last.match(/-/g) || []).length === 1) {
        const rp = last.split('-');
        const start = parseInt(rp[0], 10), stop = parseInt(rp[1], 10);
        if (!isNaN(start) && !isNaN(stop) && start !== stop) {
          if (start < stop) {
            for (let i = start; i <= stop; i++) array.push(input.repeat(i));
          } else {
            for (let i = start; i >= stop; i--) array.push(input.repeat(i));
          }
          return true;
        }
        return false;
      }

      const n = parseInt(last, 10);
      if (isNaN(n) || !/^\d+$/.test(last)) return false;
      array.push(input.repeat(n));
      return true;
    }
    return false;
  }
};

// ============================================================
// Cook Methods — ported from pkg/methods/
// ============================================================
const CookMethods = {
  leetValues: {
    '4': ['a','A'], '8': ['b','B'], '(': ['c','C'], '|)': ['d','D'],
    '3': ['e','E'], '|=': ['f','F'], '6': ['g','G'], '#': ['h','H'],
    '1': ['i','I'], '_|': ['j','J'], '|<': ['k','K'], '|_': ['l','L'],
    '|\\/|': ['m','M'], '|\\|': ['n','N'], '0': ['o','O'], '|*': ['p','P'],
    '0,': ['q','Q'], '|2': ['r','R'], '5': ['s','S'], '7': ['t','T'],
    '|_|': ['u','U'], '\\/': ['v','V'], '\\/\\/': ['w','W'], '><': ['x','X'],
    '`/': ['y','Y'], '2': ['z','Z']
  },

  upper(values) { return values.map(v => v.toUpperCase()); },
  lower(values) { return values.map(v => v.toLowerCase()); },
  title(values) { return values.map(v => v.replace(/\b\w/g, c => c.toUpperCase())); },

  sort(values) { return [...values].sort(); },
  sortu(values) {
    const seen = new Set();
    return [...values].sort().filter(v => { if (seen.has(v)) return false; seen.add(v); return true; });
  },
  unique(values) {
    const seen = new Set();
    const out = [];
    for (const v of values) {
      if (seen.has(v)) continue;
      seen.add(v);
      out.push(v);
    }
    return out;
  },
  reverse(values) { return values.map(v => [...v].reverse().join('')); },
  trim(values) { return values.map(v => String(v).trim()); },
  ltrim(values) { return values.map(v => String(v).replace(/^\s+/, '')); },
  rtrim(values) { return values.map(v => String(v).replace(/\s+$/, '')); },
  replace(values, val) {
    const [old, nw] = val.split(':');
    return values.map(v => v.split(old).join(nw));
  },
  contains(values, val) { return values.filter(v => String(v).includes(val)); },
  grep(values, val) {
    const raw = String(val == null ? '' : val);
    if (!raw) return values;
    let re = null;
    let isRegex = false;
    if (raw.startsWith('/') && raw.length > 1) {
      const last = raw.lastIndexOf('/');
      if (last > 0) {
        const body = raw.slice(1, last);
        const flagsRaw = raw.slice(last + 1);
        const flags = flagsRaw.includes('i') ? flagsRaw : (flagsRaw + 'i');
        try { re = new RegExp(body, flags); isRegex = true; } catch { re = null; }
      }
    }
    if (!re && raw.startsWith('re:')) {
      try { re = new RegExp(raw.slice(3), 'i'); isRegex = true; } catch { re = null; }
    }
    const needle = raw.toLowerCase();
    const out = [];
    for (const v of values) {
      const txt = String(v == null ? '' : v);
      const lines = txt.split(/\r?\n/);
      for (const line of lines) {
        if (isRegex) {
          re.lastIndex = 0;
          if (re.test(line)) out.push(line);
        } else if (line.toLowerCase().includes(needle)) {
          out.push(line);
        }
      }
    }
    return out;
  },
  grepv(values, val) {
    const raw = String(val == null ? '' : val);
    if (!raw) return values;
    let re = null;
    let isRegex = false;
    if (raw.startsWith('/') && raw.length > 1) {
      const last = raw.lastIndexOf('/');
      if (last > 0) {
        const body = raw.slice(1, last);
        const flagsRaw = raw.slice(last + 1);
        const flags = flagsRaw.includes('i') ? flagsRaw : (flagsRaw + 'i');
        try { re = new RegExp(body, flags); isRegex = true; } catch { re = null; }
      }
    }
    if (!re && raw.startsWith('re:')) {
      try { re = new RegExp(raw.slice(3), 'i'); isRegex = true; } catch { re = null; }
    }
    const needle = raw.toLowerCase();
    const out = [];
    for (const v of values) {
      const txt = String(v == null ? '' : v);
      const lines = txt.split(/\r?\n/);
      for (const line of lines) {
        if (isRegex) {
          re.lastIndex = 0;
          if (!re.test(line)) out.push(line);
        } else if (!line.toLowerCase().includes(needle)) {
          out.push(line);
        }
      }
    }
    return out;
  },
  starts(values, val) { return values.filter(v => String(v).startsWith(val)); },
  ends(values, val) { return values.filter(v => String(v).endsWith(val)); },
  minlength(values, val) {
    const n = parseInt(val, 10);
    if (!Number.isFinite(n)) return values;
    return values.filter(v => String(v).length >= n);
  },
  maxlength(values, val) {
    const n = parseInt(val, 10);
    if (!Number.isFinite(n)) return values;
    return values.filter(v => String(v).length <= n);
  },
  split(values, delim) {
    const r = [];
    for (const v of values) r.push(...v.split(delim));
    return r;
  },
  awkn(values, val) {
    const raw = String(val == null ? '' : val);
    let idx = 0;
    let delim = ' ';
    if (raw) {
      const sep = raw.indexOf(':');
      if (sep >= 0) {
        idx = parseInt(raw.slice(0, sep), 10);
        delim = raw.slice(sep + 1);
      } else {
        idx = parseInt(raw, 10);
      }
      if (!Number.isFinite(idx)) idx = 0;
    }
    if (delim === '\\t') delim = '\t';
    const r = [];
    for (const v of values) {
      const line = String(v == null ? '' : v);
      let fields;
      if (delim === ' ') {
        fields = line.trim().split(/\s+/).filter(Boolean);
      } else if (delim === '') {
        fields = line.split('');
      } else {
        fields = line.split(delim);
      }
      if (!fields.length) continue;
      const at = idx < 0 ? fields.length + idx : idx;
      if (at >= 0 && at < fields.length) r.push(fields[at]);
    }
    return r;
  },
  splitindex(values, val) {
    const parts = val.split(':');
    const idx = parseInt(parts[parts.length - 1], 10);
    const delim = parts.slice(0, -1).join(':');
    const r = [];
    for (const v of values) {
      const sp = v.split(delim);
      if (sp.length > idx) r.push(sp[idx]);
    }
    return r;
  },
  filebase(values) { return values.map(v => { const p = v.split('/'); return p[p.length - 1] || v; }); },

  charcode(values, semi) {
    const addSemi = semi === '1';
    return values.map(v => [...v].map(c => '&#' + c.charCodeAt(0) + (addSemi ? ';' : '')).join(''));
  },
  b64e(values) { return values.map(v => btoa(unescape(encodeURIComponent(v)))); },
  b64d(values) { return values.map(v => { try { return decodeURIComponent(escape(atob(v))); } catch { return v; } }); },
  hexe(values) { return values.map(v => [...v].map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join('')); },
  hexd(values) { return values.map(v => { let r = ''; for (let i = 0; i < v.length; i += 2) r += String.fromCharCode(parseInt(v.substr(i, 2), 16)); return r; }); },
  urle(values) { return values.map(v => encodeURIComponent(v)); },
  urld(values) { return values.map(v => { try { return decodeURIComponent(v); } catch { return v; } }); },
  urlea(values) { return values.map(v => [...v].map(c => '%' + c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase()).join('')); },
  jsone(values) { return values.map(v => JSON.stringify(v).slice(1, -1)); },
  jsonu(values) { return values.map(v => { try { return JSON.parse('"' + v + '"'); } catch { return v; } }); },
  xmle(values) { return values.map(v => v.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&apos;')); },
  xmlu(values) { return values.map(v => v.replace(/&amp;/g,'&').replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&quot;/g,'"').replace(/&apos;/g,"'")); },
  unicodee(values) { return values.map(v => [...v].map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join('')); },
  unicoded(values) { return values.map(v => v.replace(/\\u([0-9a-fA-F]{4})/g, (_, h) => String.fromCharCode(parseInt(h, 16)))); },
  utf16(values) {
    return values.map(v => {
      let r = '';
      for (const c of v) { const code = c.charCodeAt(0); r += String.fromCharCode(code & 0xFF) + String.fromCharCode((code >> 8) & 0xFF); }
      return [...r].map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join('');
    });
  },
  utf16be(values) {
    return values.map(v => {
      let r = '';
      for (const c of v) { const code = c.charCodeAt(0); r += String.fromCharCode((code >> 8) & 0xFF) + String.fromCharCode(code & 0xFF); }
      return [...r].map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join('');
    });
  },

  md5(values) { return values.map(v => _md5(v)); },
  sha224(values) { return values.map(v => _sha224(v)); },

  async sha1(values) { return Promise.all(values.map(v => _cryptoHash('SHA-1', v))); },
  async sha256(values) { return Promise.all(values.map(v => _cryptoHash('SHA-256', v))); },
  async sha384(values) { return Promise.all(values.map(v => _cryptoHash('SHA-384', v))); },
  async sha512(values) { return Promise.all(values.map(v => _cryptoHash('SHA-512', v))); },

  scheme(values) { return values.map(v => _parseUrl(v).protocol.replace(/:$/, '')); },
  host(values) { return values.map(v => _parseUrl(v).hostname); },
  port(values) { return values.map(v => _parseUrl(v).port); },
  path(values) { return values.map(v => _parseUrl(v).pathname); },
  query(values) { return values.map(v => { const s = _parseUrl(v).search; return s.startsWith('?') ? s.slice(1) : s; }); },
  keys(values) { const r = []; for (const v of values) for (const k of _parseUrl(v).searchParams.keys()) r.push(k); return r; },
  value(values) { const r = []; for (const v of values) for (const val of _parseUrl(v).searchParams.values()) r.push(val); return r; },
  domain(values) { return values.map(v => { const u = _parseUrl(v); return u.protocol + '//' + u.host; }); },
  tld(values) { return values.map(v => _getTld(_parseUrl(v).hostname)); },
  subdomain(values) {
    return values.map(v => {
      const h = _parseUrl(v).hostname;
      const main = _getEffectiveDomain(h);
      const till = h.length - main.length - 1;
      return till > 0 ? h.slice(0, till) : '';
    });
  },
  allsub(values) {
    const r = [];
    for (const v of values) {
      const h = _parseUrl(v).hostname;
      const main = _getEffectiveDomain(h);
      const till = h.length - main.length - 1;
      const sub = till > 0 ? h.slice(0, till) : '';
      if (sub) r.push(...sub.split('.'));
    }
    return r;
  },
  alldir(values) {
    const r = [];
    for (const v of values) r.push(..._parseUrl(v).pathname.split('/'));
    return r;
  },
  fragment(values) { return values.map(v => _parseUrl(v).hash.replace(/^#/, '')); },
  user(values) {
    const out = [];
    for (const v of values) {
      const lines = String(v == null ? '' : v).split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      if (lines.length <= 1) out.push(_extractCredentials(v).user);
      else for (const line of lines) out.push(_extractCredentials(line).user);
    }
    return out;
  },
  pass(values) {
    const out = [];
    for (const v of values) {
      const lines = String(v == null ? '' : v).split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      if (lines.length <= 1) out.push(_extractCredentials(v).pass);
      else for (const line of lines) out.push(_extractCredentials(line).pass);
    }
    return out;
  },

  smart(values) {
    const r = [];
    for (const w of values) {
      if (w.includes('_')) { r.push(...w.split('_')); }
      else if (w.includes('-')) { r.push(...w.split('-')); }
      else {
        let j = 0;
        for (let i = 0; i < w.length; i++) {
          const code = w.charCodeAt(i);
          if (i > 0 && code >= 65 && code <= 90) { r.push(w.slice(j, i)); j = i; }
        }
        r.push(w.slice(j));
      }
    }
    return r;
  },
  smartjoin(values, val) {
    const parts = val.split(':');
    const applyCase = parts[0].toLowerCase();
    const joinWith = parts.slice(1).join(':');
    const caseFns = { l: s => s.toLowerCase(), u: s => s.toUpperCase(), t: s => s.charAt(0).toUpperCase() + s.slice(1), c: s => s.charAt(0).toUpperCase() + s.slice(1) };
    let fn1 = s => s, fn2 = s => s;
    if (caseFns[applyCase]) { fn2 = caseFns[applyCase]; fn1 = caseFns[applyCase]; }
    if (applyCase === 'c') fn1 = s => s.toLowerCase();
    return values.map(w => {
      let str;
      if (w.includes('_')) str = w.split('_');
      else if (w.includes('-')) str = w.split('-');
      else {
        str = []; let j = 0;
        for (let i = 0; i < w.length; i++) { const code = w.charCodeAt(i); if (i > 0 && code >= 65 && code <= 90) { str.push(w.slice(j, i)); j = i; } }
        str.push(w.slice(j));
      }
      str[0] = fn1(str[0]);
      for (let i = 1; i < str.length; i++) str[i] = fn2(str[i]);
      return str.join(joinWith);
    });
  },

  leet(values, val) {
    const mode = parseInt(val, 10) || 0;
    const r = [];
    for (const v of values) {
      const tmp = new Set();
      let v2 = v;
      for (const [l, chars] of Object.entries(CookMethods.leetValues)) {
        for (const c of chars) {
          if (v.includes(c)) {
            tmp.add(v.split(c).join(l));
            v2 = v2.split(c).join(l);
            tmp.add(v2);
          }
        }
      }
      if (mode === 0) { r.push(v2); }
      else { for (const k of tmp) r.push(k); }
    }
    return r;
  },

  json(values, get) {
    const keys = get.split(':');
    return values.map(v => {
      try {
        let obj = JSON.parse(v);
        for (const k of keys) { obj = obj[k]; if (obj === undefined) return ''; }
        return typeof obj === 'object' ? JSON.stringify(obj) : String(obj);
      } catch { return ''; }
    });
  },

  regex(values, pattern) {
    const r = [];
    const seen = new Set();
    try {
      const re = new RegExp(pattern, 'g');
      for (const v of values) {
        let m;
        while ((m = re.exec(v)) !== null) {
          if (!seen.has(m[0])) { seen.add(m[0]); r.push(m[0]); }
        }
      }
    } catch { /* invalid regex */ }
    return r;
  }
};

const METHOD_ALIASES = {
  u: 'upper', upper: 'upper', l: 'lower', lower: 'lower', t: 'title', title: 'title',
  trim: 'trim', ltrim: 'ltrim', rtrim: 'rtrim', unique: 'unique',
  contains: 'contains', grep: 'grep', grepv: 'grepv', awkn: 'awkn', awk: 'awkn', starts: 'starts', ends: 'ends',
  minlength: 'minlength', minlen: 'minlength', maxlength: 'maxlength', maxlen: 'maxlength',
  fb: 'filebase', filebase: 'filebase',
  sort: 'sort', sortu: 'sortu', reverse: 'reverse', replace: 'replace',
  split: 'split', splitindex: 'splitindex',
  c: 'charcode', charcode: 'charcode',
  leet: 'leet', json: 'json', smart: 'smart', smartjoin: 'smartjoin', regex: 'regex',
  k: 'keys', keys: 'keys', sub: 'subdomain', subdomain: 'subdomain', allsub: 'allsub',
  tld: 'tld', user: 'user', username: 'user', pass: 'pass', password: 'pass',
  h: 'host', host: 'host', p: 'port', port: 'port', ph: 'path', path: 'path',
  f: 'fragment', fragment: 'fragment', q: 'query', query: 'query',
  v: 'value', value: 'value', s: 'scheme', scheme: 'scheme',
  d: 'domain', domain: 'domain', alldir: 'alldir',
  b64e: 'b64e', b64encode: 'b64e', b64d: 'b64d', b64decode: 'b64d',
  hexe: 'hexe', hexencode: 'hexe', hexd: 'hexd', hexdecode: 'hexd',
  jsone: 'jsone', jsonescape: 'jsone', jsonu: 'jsonu', jsonunescape: 'jsonu',
  md5: 'md5', sha1: 'sha1', sha224: 'sha224', sha256: 'sha256', sha384: 'sha384', sha512: 'sha512',
  unicoded: 'unicoded', unicodedecode: 'unicoded', unicodee: 'unicodee', unicodeencodeall: 'unicodee',
  urle: 'urle', urlencode: 'urle', urld: 'urld', urldecode: 'urld', urlea: 'urlea', urlencodeall: 'urlea',
  utf16: 'utf16', utf16be: 'utf16be',
  xmle: 'xmle', xmlescape: 'xmle', xmlu: 'xmlu', xmlunescape: 'xmlu',
};

function _parseUrl(s) {
  if (!s.startsWith('http://') && !s.startsWith('https://')) s = 'http://' + s;
  try { return new URL(s); } catch { return new URL('http://invalid'); }
}

function _extractCredentials(input) {
  const raw = String(input == null ? '' : input).trim();
  if (!raw) return { user: '', pass: '' };

  // URL credentials: https://user:pass@host or user:pass@host
  const parsed = _parseUrl(raw);
  if (parsed.username || parsed.password) {
    return { user: parsed.username || '', pass: parsed.password || '' };
  }

  // Raw credentials fallback: user:pass
  // Avoid common URL-like host:port / path forms.
  if (!raw.includes('/') && !raw.includes('?') && !raw.includes('#')) {
    const idx = raw.indexOf(':');
    if (idx > 0 && idx < raw.length - 1) {
      const maybeUser = raw.slice(0, idx);
      const maybePass = raw.slice(idx + 1);
      if (!maybeUser.includes('@') && !maybePass.includes('@')) {
        // Avoid treating host:port as credentials (example: google.com:443).
        if (maybeUser.includes('.') && /^\d+$/.test(maybePass)) return { user: '', pass: '' };
        return { user: maybeUser, pass: maybePass };
      }
    }
  }

  return { user: '', pass: '' };
}

const COMPOUND_TLDS = ['co.uk','co.jp','co.kr','co.in','co.za','co.nz','co.il','co.id','co.th','com.au','com.br','com.cn','com.mx','com.tw','com.hk','com.sg','com.ar','com.tr','com.ua','com.pk','com.eg','com.ng','com.my','com.ph','com.vn','com.co','com.pe','com.sa','org.uk','org.au','net.au','ac.uk','gov.uk','gov.au','edu.au','ac.jp','ne.jp','or.jp','go.jp','ac.in','gov.in','edu.in','ac.za','gov.za','edu.za','ac.kr','go.kr','or.kr'];

function _getTld(hostname) {
  const parts = hostname.split('.');
  if (parts.length >= 3) {
    const last2 = parts.slice(-2).join('.');
    if (COMPOUND_TLDS.includes(last2)) return last2;
  }
  return parts[parts.length - 1] || '';
}

function _getEffectiveDomain(hostname) {
  const parts = hostname.split('.');
  if (parts.length >= 3) {
    const last2 = parts.slice(-2).join('.');
    if (COMPOUND_TLDS.includes(last2)) {
      return parts.length >= 3 ? parts.slice(-3).join('.') : hostname;
    }
  }
  return parts.length >= 2 ? parts.slice(-2).join('.') : hostname;
}

async function _cryptoHash(algo, str) {
  // Try Web Crypto first (works on https / localhost), fallback to pure JS
  if (typeof crypto !== 'undefined' && crypto.subtle) {
    try {
      const data = new TextEncoder().encode(str);
      const buf = await crypto.subtle.digest(algo, data);
      return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
    } catch {}
  }
  return _shaJS(algo, str);
}

// Pure JS SHA family — works on file:// and non-secure contexts
function _shaJS(algo, str) {
  const data = new TextEncoder().encode(str);
  const is384 = algo === 'SHA-384', is512 = algo === 'SHA-512' || is384;
  const is1 = algo === 'SHA-1';
  if (is1) return _sha1Pure(data);
  if (is512 || is384) return _sha512Pure(data, is384);
  // SHA-256 (also handles SHA-224 but that uses _sha224 directly)
  return _sha256Pure(data);
}

function _sha1Pure(data) {
  function rotl(n, s) { return ((n << s) | (n >>> (32 - s))) >>> 0; }
  let H0 = 0x67452301, H1 = 0xEFCDAB89, H2 = 0x98BADCFE, H3 = 0x10325476, H4 = 0xC3D2E1F0;
  const l = data.length, bl = l * 8;
  const padded = new Uint8Array(Math.ceil((l + 9) / 64) * 64);
  padded.set(data); padded[l] = 0x80;
  const dv = new DataView(padded.buffer);
  dv.setUint32(padded.length - 4, bl, false);
  for (let off = 0; off < padded.length; off += 64) {
    const W = new Uint32Array(80);
    for (let i = 0; i < 16; i++) W[i] = dv.getUint32(off + i * 4, false);
    for (let i = 16; i < 80; i++) W[i] = rotl(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16], 1);
    let a = H0, b = H1, c = H2, d = H3, e = H4;
    for (let i = 0; i < 80; i++) {
      let f, k;
      if (i < 20) { f = (b & c) | (~b & d); k = 0x5A827999; }
      else if (i < 40) { f = b ^ c ^ d; k = 0x6ED9EBA1; }
      else if (i < 60) { f = (b & c) | (b & d) | (c & d); k = 0x8F1BBCDC; }
      else { f = b ^ c ^ d; k = 0xCA62C1D6; }
      const temp = (rotl(a, 5) + f + e + k + W[i]) >>> 0;
      e = d; d = c; c = rotl(b, 30); b = a; a = temp;
    }
    H0 = (H0 + a) >>> 0; H1 = (H1 + b) >>> 0; H2 = (H2 + c) >>> 0; H3 = (H3 + d) >>> 0; H4 = (H4 + e) >>> 0;
  }
  return [H0,H1,H2,H3,H4].map(v => v.toString(16).padStart(8, '0')).join('');
}

function _sha256Pure(data) {
  const K = [
    0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
    0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
    0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
    0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
    0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
    0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
    0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
    0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
  ];
  let H = [0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19];
  const l = data.length, bl = l * 8;
  const padded = new Uint8Array(Math.ceil((l + 9) / 64) * 64);
  padded.set(data); padded[l] = 0x80;
  const view = new DataView(padded.buffer);
  view.setUint32(padded.length - 4, bl, false);
  function rotr(n, b) { return ((n >>> b) | (n << (32 - b))) >>> 0; }
  for (let off = 0; off < padded.length; off += 64) {
    const W = new Int32Array(64);
    for (let i = 0; i < 16; i++) W[i] = view.getInt32(off + i * 4, false);
    for (let i = 16; i < 64; i++) {
      const s0 = rotr(W[i-15], 7) ^ rotr(W[i-15], 18) ^ (W[i-15] >>> 3);
      const s1 = rotr(W[i-2], 17) ^ rotr(W[i-2], 19) ^ (W[i-2] >>> 10);
      W[i] = (W[i-16] + s0 + W[i-7] + s1) | 0;
    }
    let [a,b,c,d,e,f,g,h] = H;
    for (let i = 0; i < 64; i++) {
      const S1 = rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25);
      const ch = (e & f) ^ (~e & g);
      const t1 = (h + S1 + ch + K[i] + W[i]) | 0;
      const S0 = rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22);
      const maj = (a & b) ^ (a & c) ^ (b & c);
      const t2 = (S0 + maj) | 0;
      h = g; g = f; f = e; e = (d + t1) | 0; d = c; c = b; b = a; a = (t1 + t2) | 0;
    }
    H[0] = (H[0] + a) | 0; H[1] = (H[1] + b) | 0; H[2] = (H[2] + c) | 0; H[3] = (H[3] + d) | 0;
    H[4] = (H[4] + e) | 0; H[5] = (H[5] + f) | 0; H[6] = (H[6] + g) | 0; H[7] = (H[7] + h) | 0;
  }
  return H.map(v => (v >>> 0).toString(16).padStart(8, '0')).join('');
}

function _sha512Pure(data, is384) {
  const M = 0xFFFFFFFFFFFFFFFFn;
  function rotr(x, n) { return ((x >> BigInt(n)) | (x << BigInt(64 - n))) & M; }
  function shr(x, n) { return x >> BigInt(n); }
  function Ch(x, y, z) { return (x & y) ^ (~x & M & z); }
  function Maj(x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }
  function Sig0(x) { return rotr(x,28) ^ rotr(x,34) ^ rotr(x,39); }
  function Sig1(x) { return rotr(x,14) ^ rotr(x,18) ^ rotr(x,41); }
  function sig0(x) { return rotr(x,1) ^ rotr(x,8) ^ shr(x,7); }
  function sig1(x) { return rotr(x,19) ^ rotr(x,61) ^ shr(x,6); }
  const K = [
    0x428a2f98d728ae22n,0x7137449123ef65cdn,0xb5c0fbcfec4d3b2fn,0xe9b5dba58189dbbcn,
    0x3956c25bf348b538n,0x59f111f1b605d019n,0x923f82a4af194f9bn,0xab1c5ed5da6d8118n,
    0xd807aa98a3030242n,0x12835b0145706fben,0x243185be4ee4b28cn,0x550c7dc3d5ffb4e2n,
    0x72be5d74f27b896fn,0x80deb1fe3b1696b1n,0x9bdc06a725c71235n,0xc19bf174cf692694n,
    0xe49b69c19ef14ad2n,0xefbe4786384f25e3n,0x0fc19dc68b8cd5b5n,0x240ca1cc77ac9c65n,
    0x2de92c6f592b0275n,0x4a7484aa6ea6e483n,0x5cb0a9dcbd41fbd4n,0x76f988da831153b5n,
    0x983e5152ee66dfabn,0xa831c66d2db43210n,0xb00327c898fb213fn,0xbf597fc7beef0ee4n,
    0xc6e00bf33da88fc2n,0xd5a79147930aa725n,0x06ca6351e003826fn,0x142929670a0e6e70n,
    0x27b70a8546d22ffcn,0x2e1b21385c26c926n,0x4d2c6dfc5ac42aedn,0x53380d139d95b3dfn,
    0x650a73548baf63den,0x766a0abb3c77b2a8n,0x81c2c92e47edaee6n,0x92722c851482353bn,
    0xa2bfe8a14cf10364n,0xa81a664bbc423001n,0xc24b8b70d0f89791n,0xc76c51a30654be30n,
    0xd192e819d6ef5218n,0xd69906245565a910n,0xf40e35855771202an,0x106aa07032bbd1b8n,
    0x19a4c116b8d2d0c8n,0x1e376c085141ab53n,0x2748774cdf8eeb99n,0x34b0bcb5e19b48a8n,
    0x391c0cb3c5c95a63n,0x4ed8aa4ae3418acbn,0x5b9cca4f7763e373n,0x682e6ff3d6b2b8a3n,
    0x748f82ee5defb2fcn,0x78a5636f43172f60n,0x84c87814a1f0ab72n,0x8cc702081a6439ecn,
    0x90befffa23631e28n,0xa4506cebde82bde9n,0xbef9a3f7b2c67915n,0xc67178f2e372532bn,
    0xca273eceea26619cn,0xd186b8c721c0c207n,0xeada7dd6cde0eb1en,0xf57d4f7fee6ed178n,
    0x06f067aa72176fban,0x0a637dc5a2c898a6n,0x113f9804bef90daen,0x1b710b35131c471bn,
    0x28db77f523047d84n,0x32caab7b40c72493n,0x3c9ebe0a15c9bebcn,0x431d67c49c100d4cn,
    0x4cc5d4becb3e42b6n,0x597f299cfc657e2an,0x5fcb6fab3ad6faecn,0x6c44198c4a475817n
  ];
  let H;
  if (is384) {
    H = [0xcbbb9d5dc1059ed8n,0x629a292a367cd507n,0x9159015a3070dd17n,0x152fecd8f70e5939n,
         0x67332667ffc00b31n,0x8eb44a8768581511n,0xdb0c2e0d64f98fa7n,0x47b5481dbefa4fa4n];
  } else {
    H = [0x6a09e667f3bcc908n,0xbb67ae8584caa73bn,0x3c6ef372fe94f82bn,0xa54ff53a5f1d36f1n,
         0x510e527fade682d1n,0x9b05688c2b3e6c1fn,0x1f83d9abfb41bd6bn,0x5be0cd19137e2179n];
  }
  const l = data.length;
  const padded = new Uint8Array(Math.ceil((l + 17) / 128) * 128);
  padded.set(data); padded[l] = 0x80;
  const dv = new DataView(padded.buffer);
  dv.setUint32(padded.length - 4, (l * 8) >>> 0, false);
  for (let off = 0; off < padded.length; off += 128) {
    const W = new Array(80);
    for (let i = 0; i < 16; i++) {
      W[i] = (BigInt(dv.getUint32(off + i * 8, false)) << 32n) | BigInt(dv.getUint32(off + i * 8 + 4, false));
    }
    for (let i = 16; i < 80; i++) {
      W[i] = (sig1(W[i-2]) + W[i-7] + sig0(W[i-15]) + W[i-16]) & M;
    }
    let [a,b,c,d,e,f,g,h] = H;
    for (let i = 0; i < 80; i++) {
      const t1 = (h + Sig1(e) + Ch(e,f,g) + K[i] + W[i]) & M;
      const t2 = (Sig0(a) + Maj(a,b,c)) & M;
      h=g; g=f; f=e; e=(d+t1)&M; d=c; c=b; b=a; a=(t1+t2)&M;
    }
    H[0]=(H[0]+a)&M; H[1]=(H[1]+b)&M; H[2]=(H[2]+c)&M; H[3]=(H[3]+d)&M;
    H[4]=(H[4]+e)&M; H[5]=(H[5]+f)&M; H[6]=(H[6]+g)&M; H[7]=(H[7]+h)&M;
  }
  const count = is384 ? 6 : 8;
  return H.slice(0, count).map(v => v.toString(16).padStart(16, '0')).join('');
}

// --- Pure JS MD5 ---
function _md5(string) {
  function md5cycle(x, k) {
    let a = x[0], b = x[1], c = x[2], d = x[3];
    a = ff(a, b, c, d, k[0], 7, -680876936); d = ff(d, a, b, c, k[1], 12, -389564586);
    c = ff(c, d, a, b, k[2], 17, 606105819); b = ff(b, c, d, a, k[3], 22, -1044525330);
    a = ff(a, b, c, d, k[4], 7, -176418897); d = ff(d, a, b, c, k[5], 12, 1200080426);
    c = ff(c, d, a, b, k[6], 17, -1473231341); b = ff(b, c, d, a, k[7], 22, -45705983);
    a = ff(a, b, c, d, k[8], 7, 1770035416); d = ff(d, a, b, c, k[9], 12, -1958414417);
    c = ff(c, d, a, b, k[10], 17, -42063); b = ff(b, c, d, a, k[11], 22, -1990404162);
    a = ff(a, b, c, d, k[12], 7, 1804603682); d = ff(d, a, b, c, k[13], 12, -40341101);
    c = ff(c, d, a, b, k[14], 17, -1502002290); b = ff(b, c, d, a, k[15], 22, 1236535329);
    a = gg(a, b, c, d, k[1], 5, -165796510); d = gg(d, a, b, c, k[6], 9, -1069501632);
    c = gg(c, d, a, b, k[11], 14, 643717713); b = gg(b, c, d, a, k[0], 20, -373897302);
    a = gg(a, b, c, d, k[5], 5, -701558691); d = gg(d, a, b, c, k[10], 9, 38016083);
    c = gg(c, d, a, b, k[15], 14, -660478335); b = gg(b, c, d, a, k[4], 20, -405537848);
    a = gg(a, b, c, d, k[9], 5, 568446438); d = gg(d, a, b, c, k[14], 9, -1019803690);
    c = gg(c, d, a, b, k[3], 14, -187363961); b = gg(b, c, d, a, k[8], 20, 1163531501);
    a = gg(a, b, c, d, k[13], 5, -1444681467); d = gg(d, a, b, c, k[2], 9, -51403784);
    c = gg(c, d, a, b, k[7], 14, 1735328473); b = gg(b, c, d, a, k[12], 20, -1926607734);
    a = hh(a, b, c, d, k[5], 4, -378558); d = hh(d, a, b, c, k[8], 11, -2022574463);
    c = hh(c, d, a, b, k[11], 16, 1839030562); b = hh(b, c, d, a, k[14], 23, -35309556);
    a = hh(a, b, c, d, k[1], 4, -1530992060); d = hh(d, a, b, c, k[4], 11, 1272893353);
    c = hh(c, d, a, b, k[7], 16, -155497632); b = hh(b, c, d, a, k[10], 23, -1094730640);
    a = hh(a, b, c, d, k[13], 4, 681279174); d = hh(d, a, b, c, k[0], 11, -358537222);
    c = hh(c, d, a, b, k[3], 16, -722521979); b = hh(b, c, d, a, k[6], 23, 76029189);
    a = hh(a, b, c, d, k[9], 4, -640364487); d = hh(d, a, b, c, k[12], 11, -421815835);
    c = hh(c, d, a, b, k[15], 16, 530742520); b = hh(b, c, d, a, k[2], 23, -995338651);
    a = ii(a, b, c, d, k[0], 6, -198630844); d = ii(d, a, b, c, k[7], 10, 1126891415);
    c = ii(c, d, a, b, k[14], 15, -1416354905); b = ii(b, c, d, a, k[5], 21, -57434055);
    a = ii(a, b, c, d, k[12], 6, 1700485571); d = ii(d, a, b, c, k[3], 10, -1894986606);
    c = ii(c, d, a, b, k[10], 15, -1051523); b = ii(b, c, d, a, k[1], 21, -2054922799);
    a = ii(a, b, c, d, k[8], 6, 1873313359); d = ii(d, a, b, c, k[15], 10, -30611744);
    c = ii(c, d, a, b, k[6], 15, -1560198380); b = ii(b, c, d, a, k[13], 21, 1309151649);
    a = ii(a, b, c, d, k[4], 6, -145523070); d = ii(d, a, b, c, k[11], 10, -1120210379);
    c = ii(c, d, a, b, k[2], 15, 718787259); b = ii(b, c, d, a, k[9], 21, -343485551);
    x[0] = add32(a, x[0]); x[1] = add32(b, x[1]); x[2] = add32(c, x[2]); x[3] = add32(d, x[3]);
  }
  function cmn(q, a, b, x, s, t) { a = add32(add32(a, q), add32(x, t)); return add32((a << s) | (a >>> (32 - s)), b); }
  function ff(a, b, c, d, x, s, t) { return cmn((b & c) | ((~b) & d), a, b, x, s, t); }
  function gg(a, b, c, d, x, s, t) { return cmn((b & d) | (c & (~d)), a, b, x, s, t); }
  function hh(a, b, c, d, x, s, t) { return cmn(b ^ c ^ d, a, b, x, s, t); }
  function ii(a, b, c, d, x, s, t) { return cmn(c ^ (b | (~d)), a, b, x, s, t); }
  function md51(s) {
    const n = s.length;
    let state = [1732584193, -271733879, -1732584194, 271733878], i;
    for (i = 64; i <= n; i += 64) md5cycle(state, md5blk(s.substring(i - 64, i)));
    s = s.substring(i - 64);
    const tail = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    for (i = 0; i < s.length; i++) tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
    tail[i >> 2] |= 0x80 << ((i % 4) << 3);
    if (i > 55) { md5cycle(state, tail); for (i = 0; i < 16; i++) tail[i] = 0; }
    tail[14] = n * 8;
    md5cycle(state, tail);
    return state;
  }
  function md5blk(s) {
    const md5blks = [];
    for (let i = 0; i < 64; i += 4) md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
    return md5blks;
  }
  const hex_chr = '0123456789abcdef'.split('');
  function rhex(n) {
    let s = '';
    for (let j = 0; j < 4; j++) s += hex_chr[(n >> (j * 8 + 4)) & 0x0f] + hex_chr[(n >> (j * 8)) & 0x0f];
    return s;
  }
  function add32(a, b) { return (a + b) & 0xFFFFFFFF; }
  const x = md51(unescape(encodeURIComponent(string)));
  return rhex(x[0]) + rhex(x[1]) + rhex(x[2]) + rhex(x[3]);
}

function _sha224(str) {
  const data = new TextEncoder().encode(str);
  const K = [
    0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
    0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
    0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
    0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
    0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
    0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
    0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
    0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
  ];
  let H = [0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];
  const l = data.length;
  const bl = l * 8;
  const padded = new Uint8Array(Math.ceil((l + 9) / 64) * 64);
  padded.set(data);
  padded[l] = 0x80;
  const view = new DataView(padded.buffer);
  view.setUint32(padded.length - 4, bl, false);
  for (let off = 0; off < padded.length; off += 64) {
    const W = new Int32Array(64);
    for (let i = 0; i < 16; i++) W[i] = view.getInt32(off + i * 4, false);
    for (let i = 16; i < 64; i++) {
      const s0 = (rotr(W[i-15], 7) ^ rotr(W[i-15], 18) ^ (W[i-15] >>> 3));
      const s1 = (rotr(W[i-2], 17) ^ rotr(W[i-2], 19) ^ (W[i-2] >>> 10));
      W[i] = (W[i-16] + s0 + W[i-7] + s1) | 0;
    }
    let [a,b,c,d,e,f,g,h] = H;
    for (let i = 0; i < 64; i++) {
      const S1 = rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25);
      const ch = (e & f) ^ (~e & g);
      const temp1 = (h + S1 + ch + K[i] + W[i]) | 0;
      const S0 = rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22);
      const maj = (a & b) ^ (a & c) ^ (b & c);
      const temp2 = (S0 + maj) | 0;
      h = g; g = f; f = e; e = (d + temp1) | 0; d = c; c = b; b = a; a = (temp1 + temp2) | 0;
    }
    H[0] = (H[0] + a) | 0; H[1] = (H[1] + b) | 0; H[2] = (H[2] + c) | 0; H[3] = (H[3] + d) | 0;
    H[4] = (H[4] + e) | 0; H[5] = (H[5] + f) | 0; H[6] = (H[6] + g) | 0; H[7] = (H[7] + h) | 0;
  }
  function rotr(n, b) { return ((n >>> b) | (n << (32 - b))) >>> 0; }
  return H.slice(0, 7).map(v => (v >>> 0).toString(16).padStart(8, '0')).join('');
}


// ============================================================
// Cook Engine — ported from pkg/cook/
// ============================================================
class CookEngine {
  constructor(pattern, params, options) {
    this.pattern = pattern;
    this.params = params || {};
    this.fileParams = {};
    this.methodsForAll = options.methodsForAll || '';
    this.methodParam = options.methodParam || '';
    this.appendParam = options.appendParam || '';
    this.min = options.min || -1;
    this.final = [''];
    this.totalCols = pattern.length;
    this.methodMap = {};
    this.appendMap = {};
    this.allResults = [];
    this.cancelled = false;

    if (this.min < 0) {
      this.min = this.totalCols - 1;
    } else {
      this.min -= 1;
    }

    if (this.appendParam) {
      for (const col of this.appendParam.split(',')) {
        const n = parseInt(col, 10);
        if (!isNaN(n)) this.appendMap[n] = true;
      }
    }

    if (this.methodParam) {
      const meths = this.methodParam.split(';');
      const forAllCols = [];
      const modifiedCol = {};
      for (const m of meths) {
        if (m.includes(':')) {
          const s = m.split(':');
          const i = parseInt(s[0], 10);
          if (!isNaN(i) && i < this.totalCols) {
            this.methodMap[i] = parseMethodCsv(s.slice(1).join(':'));
            modifiedCol[i] = true;
          }
        } else {
          forAllCols.push(...parseMethodCsv(m));
        }
      }
      if (forAllCols.length > 0) {
        for (let i = 0; i < this.totalCols; i++) {
          if (!modifiedCol[i]) this.methodMap[i] = forAllCols;
        }
      }
    }
  }

  permutationMode(values) {
    const tmp = [];
    for (const t of this.final) {
      for (const v of values) { tmp.push(t + v); }
    }
    this.final = tmp;
  }

  appendMode(values) {
    const tmp = [];
    const till = Math.min(this.final.length, values.length);
    for (let i = 0; i < till; i++) { tmp.push(this.final[i] + values[i]); }
    this.final = tmp;
  }

  checkParam(p, array) {
    if (this.params[p] !== undefined) {
      const val = this.params[p];
      if (CookParser.rawInput(val, array)) return true;
      if (CookParser.repeatOp(val, array)) return true;
      array.push(...CookParser.splitValues(val));
      return true;
    }
    if (this.fileParams[p] !== undefined) {
      array.push(...this.fileParams[p]);
      return true;
    }
    return false;
  }

  hasExpandableSyntax(token) {
    if (!token) return false;
    if (this.params[token] !== undefined || this.fileParams[token] !== undefined) return true;
    if (token.includes(',')) return true;
    if (token.includes('*')) return true;
    const tmp = [];
    if (CookParser.parseRanges(token, tmp)) return true;
    if (token.includes('.')) {
      const parts = CookParser.splitMethods(token);
      if (parts.length > 1) {
        for (const m of parts.slice(1)) {
          const base = m.includes('[') ? m.slice(0, m.indexOf('[')).toLowerCase() : m.toLowerCase();
          const resolved = METHOD_ALIASES[base];
          if (resolved && CookMethods[resolved]) return true;
        }
      }
    }
    return false;
  }

  async expandRawBase(rawText) {
    const cols = splitPatternColumns(rawText);
    if (cols.length === 0) return [''];

    // Keep literal backtick behavior unless at least one token is truly pattern-like.
    const shouldExpand = cols.some((col) => {
      const vals = CookParser.splitValues(col);
      return vals.some((v) => this.hasExpandableSyntax(v));
    });
    if (!shouldExpand) return [rawText];

    let expanded = [''];
    for (const col of cols) {
      let colVals = [];
      for (const part of CookParser.splitValues(col)) {
        if (CookParser.rawInput(part, colVals)) continue;
        if (CookParser.parseRanges(part, colVals)) continue;
        if (CookParser.repeatOp(part, colVals)) continue;
        if (await this.checkMethods(part, colVals)) continue;
        if (this.checkParam(part, colVals)) continue;
        colVals.push(part);
      }

      const next = [];
      for (const prefix of expanded) {
        for (const val of colVals) next.push(prefix + val);
      }
      expanded = next;
    }
    return expanded;
  }

  async checkMethods(p, array) {
    if (p.includes('.')) {
      const splitS = CookParser.splitMethods(p);
      if (splitS.length < 2) return false;
      const firstMethod = splitS[1] || '';
      const firstBase = firstMethod.includes('[') ? firstMethod.slice(0, firstMethod.indexOf('[')).toLowerCase() : firstMethod.toLowerCase();
      const firstResolved = METHOD_ALIASES[firstBase];
      if (!firstResolved || !CookMethods[firstResolved]) return false;
      const u = splitS[0];
      const vals = [];
      if (this.params[u] !== undefined || this.fileParams[u] !== undefined) {
        this.checkParam(u, vals);
      } else if (u) {
        if (u.startsWith('`') && u.endsWith('`') && u.length >= 2) {
          vals.push(...await this.expandRawBase(u.slice(1, -1)));
        } else if (!CookParser.rawInput(u, vals)) {
          vals.push(u);
        }
      } else {
        return false;
      }
      let chain = splitS.slice(1);
      // Friendly shorthand: multiline raw literal + method chain acts line-by-line
      // unless user already provided an explicit split[\n] as first-class step.
      if (u.startsWith('`') && u.endsWith('`') && u.includes('\n')) {
        const hasLineSplit = chain.some((m) => {
          const lower = String(m || '').toLowerCase();
          if (!lower.startsWith('split[') || !lower.endsWith(']')) return false;
          const inside = lower.slice(6, -1);
          return inside === '\\n' || inside === '\n';
        });
        if (!hasLineSplit) chain = ['split[\n]', ...chain];
      }
      const result = await this.applyMethods(vals, chain);
      array.push(...result);
      return true;
    }
    return false;
  }

  async applyMethods(values, meths) {
    let current = values;
    for (const g of meths) {
      let name, value;
      if (g.includes('[')) {
        [name, value] = CookParser.readSqBr(g);
      } else {
        name = g; value = '';
      }
      name = name.toLowerCase();
      const resolved = METHOD_ALIASES[name];
      if (resolved && CookMethods[resolved]) {
        const result = CookMethods[resolved](current, value);
        current = (result instanceof Promise) ? await result : result;
      }
    }
    return current;
  }

  collectResults() {
    if (this.methodsForAll) {
      return (async () => {
        const chain = parseMethodCsv(this.methodsForAll);
        const result = await this.applyMethods(this.final, chain);
        this.allResults.push(...result);
      })();
    } else {
      this.allResults.push(...this.final);
    }
  }

  async generateAsync() {
    for (let colNum = 0; colNum < this.pattern.length; colNum++) {
      if (this.cancelled) break;
      const param = this.pattern[colNum];
      let columnValues = [];

      for (const p of CookParser.splitValues(param)) {
        if (CookParser.rawInput(p, columnValues)) continue;
        if (CookParser.parseRanges(p, columnValues)) continue;
        if (CookParser.repeatOp(p, columnValues)) continue;
        if (await this.checkMethods(p, columnValues)) continue;
        if (this.checkParam(p, columnValues)) continue;
        columnValues.push(p);
      }

      if (this.methodMap[colNum]) {
        columnValues = await this.applyMethods(columnValues, this.methodMap[colNum]);
      }

      if (!this.appendMap[colNum] || colNum === 0) {
        this.permutationMode(columnValues);
      } else {
        this.appendMode(columnValues);
      }

      if (colNum >= this.min) {
        await this.collectResults();
      }
    }
    return this.allResults;
  }
}

// ============================================================
// UI Controller
// ============================================================
let fullResults = [];
const MAX_DISPLAY = 500;
const STEP_PREVIEW_LIMIT = 50;
const STEP_PREVIEW_SHOW_LINES = 5;
let STEP_PREVIEW_TIMER = 0;
let STEP_PREVIEW_SEQ = 0;
const PRESET_KEY = 'cooked-presets-v1';
const PRESET_LAST_KEY = 'cooked-last-preset-v1';
const PRESET_AUTORESTORE_KEY = 'cooked-preset-autorestore-v1';
const FAVORITE_METHODS_KEY = 'cooked-favorite-methods-v1';
const ONBOARDING_KEY = 'cook-onboarding-v1';
const ONBOARDING_STATE = { open: false, step: 0, startedManually: false, pendingAfterTheme: false, followRaf: 0, enteredStep: -1, dotRestore: null };
const DOCS_STATE = {
  tab: 'recipes',
  recipeQuery: '',
  recipeCategory: 'all',
  recipeSelected: -1,
  recipeLastClickIndex: -1,
  recipeLastClickTs: 0,
  syntaxQuery: '',
  syntaxCategory: 'all',
  syntaxSelected: '',
  syntaxLastClickName: '',
  syntaxLastClickTs: 0
};
const METHOD_EDIT_STATE = { id: null, draft: '' };
let TOOLBOX_SEARCH_OPEN_TIMER = 0;
const METHOD_SNIPPETS = [
  ['upper', 'UPPERCASE'], ['lower', 'lowercase'], ['title', 'Title Case'],
  ['reverse', 'reverse'], ['sort', 'sort lines'], ['sortu', 'sort unique'], ['unique', 'keep first unique'],
  ['trim', 'trim spaces'], ['ltrim', 'trim left'], ['rtrim', 'trim right'],
  ['contains[text]', 'keep values containing text'], ['grep[text]', 'grep-style include filter'], ['grepv[text]', 'grep-style exclude filter'], ['awkn[0::]', 'awk-style field picker'],
  ['starts[text]', 'keep values with prefix'], ['ends[text]', 'keep values with suffix'],
  ['minlength[8]', 'minimum length filter'], ['maxlength[16]', 'maximum length filter'],
  ['replace[old:new]', 'replace text'], ['split[delim]', 'split by delimiter'],
  ['splitindex[delim:0]', 'split + index'], ['filebase', 'base filename'],
  ['b64e', 'base64 encode'], ['b64d', 'base64 decode'], ['hexe', 'hex encode'], ['hexd', 'hex decode'],
  ['urle', 'URL encode'], ['urld', 'URL decode'], ['urlea', 'URL encode all'],
  ['jsone', 'JSON escape'], ['jsonu', 'JSON unescape'], ['xmle', 'XML escape'], ['xmlu', 'XML unescape'],
  ['unicodee', 'unicode encode'], ['unicoded', 'unicode decode'], ['utf16', 'utf16'], ['utf16be', 'utf16be'],
  ['charcode', 'HTML charcode'], ['md5', 'md5 hash'], ['sha1', 'sha1 hash'], ['sha224', 'sha224 hash'], ['sha256', 'sha256 hash'], ['sha384', 'sha384 hash'], ['sha512', 'sha512 hash'],
  ['scheme', 'URL scheme'], ['host', 'hostname'], ['port', 'port'], ['path', 'path'], ['query', 'query'],
  ['keys', 'query keys'], ['value', 'query values'], ['domain', 'scheme+host'], ['tld', 'top-level domain'],
  ['subdomain', 'subdomain'], ['allsub', 'all sub parts'], ['alldir', 'all path dirs'], ['fragment', 'fragment'],
  ['user', 'username (URL or user:pass)'], ['pass', 'password (URL or user:pass)'], ['smart', 'split words'], ['smartjoin[l:_]', 'join words'],
  ['leet[0]', 'leet variant'], ['leet[1]', 'leet variants'], ['json[key]', 'extract JSON field'], ['regex[pattern]', 'regex match']
];
const METHOD_CATALOG = METHOD_SNIPPETS.map(([insert, desc]) => {
  const name = insert.split('[')[0];
  return { insert, name, desc, aliases: Object.keys(METHOD_ALIASES).filter(k => METHOD_ALIASES[k] === name) };
});
const METHOD_FLOW_PALETTE = [
  'upper', 'lower', 'title', 'reverse', 'sort', 'sortu', 'unique',
  'trim', 'contains[admin]', 'grep[api]', 'awkn[0::]', 'minlength[8]',
  'md5', 'sha1', 'sha256', 'b64e', 'hexe', 'urle',
  'replace[old:new]', 'split[,]', 'splitindex[-:1]', 'leet[1]',
  'regex[[0-9]+]', 'json[name]', 'user', 'pass'
];
const METHOD_DETAILS = {
  upper: { long: 'Convert each value to uppercase letters.', ex: '`hello world`.upper' },
  lower: { long: 'Convert each value to lowercase letters.', ex: '`HELLO WORLD`.lower' },
  title: { long: 'Casecret123lize word initials while keeping separators.', ex: '`hello world`.title' },
  reverse: { long: 'Reverse characters in each value.', ex: '`abc123`.reverse' },
  sort: { long: 'Sort generated lines in ascending order.', ex: 'p.sort' },
  sortu: { long: 'Sort output and remove duplicates.', ex: 'p.sortu' },
  unique: { long: 'Keep only first occurrence of each value while preserving order.', ex: 'p.unique' },
  trim: { long: 'Trim leading and trailing whitespace from every value.', ex: '`  hello  `.trim' },
  ltrim: { long: 'Trim leading whitespace only.', ex: '`  hello  `.ltrim' },
  rtrim: { long: 'Trim trailing whitespace only.', ex: '`  hello  `.rtrim' },
  replace: { long: 'Replace text using `replace[old:new]` format.', ex: '`hello world`.replace[o:0]' },
  contains: { long: 'Keep values that contain a substring.', ex: 'p.contains[admin]' },
  grep: { long: 'Keep values matching text or regex (`/pattern/flags` or `re:pattern`).', ex: '`api.example.com\ncdn.example.com`.grep[api]' },
  grepv: { long: 'Drop values matching text or regex (inverse grep).', ex: '`admin\nguest\nroot`.grepv[guest]' },
  awkn: { long: 'Extract one field by index using `awkn[index:delimiter]` (0-based, negative indexes allowed).', ex: '`alice:pass1\nbob:pass2`.awkn[0::]' },
  starts: { long: 'Keep values that start with a prefix.', ex: 'p.starts[api-]' },
  ends: { long: 'Keep values that end with a suffix.', ex: 'p.ends[.json]' },
  minlength: { long: 'Keep values with minimum length `n`.', ex: 'p.minlength[8]' },
  maxlength: { long: 'Keep values with maximum length `n`.', ex: 'p.maxlength[16]' },
  split: { long: 'Split by delimiter and emit segments as new lines.', ex: '`a:b:c`.split[:]' },
  splitindex: { long: 'Split by delimiter and pick one index.', ex: '`alpha-beta-gamma`.splitindex[-:1]' },
  filebase: { long: 'Extract filename from full path values.', ex: '`/tmp/demo.txt`.filebase' },
  b64e: { long: 'Base64 encode each value.', ex: '`hello`.b64e' },
  b64d: { long: 'Base64 decode each value.', ex: '`aGVsbG8=`.b64d' },
  hexe: { long: 'Hex-encode each value.', ex: '`hello`.hexe' },
  hexd: { long: 'Hex-decode each value.', ex: '`68656c6c6f`.hexd' },
  urle: { long: 'URL-encode each value.', ex: '`hello world`.urle' },
  urld: { long: 'URL-decode each value.', ex: '`hello%20world`.urld' },
  urlea: { long: 'Encode all characters as `%XX` URL bytes.', ex: '`Ab`.urlea' },
  jsone: { long: 'Escape for JSON-safe string content.', ex: '`line\\nbreak`.jsone' },
  jsonu: { long: 'Unescape JSON string escapes to raw text.', ex: '`line\\\\nbreak`.jsonu' },
  xmle: { long: 'Escape XML entities like `<`, `>`, `&`.', ex: '`<a&b>`.xmle' },
  xmlu: { long: 'Unescape XML entities back to text.', ex: '`&lt;a&gt;`.xmlu' },
  unicodee: { long: 'Encode as `\\uXXXX` code points.', ex: '`Hi!`.unicodee' },
  unicoded: { long: 'Decode `\\uXXXX` sequences to text.', ex: '`\\\\u0048\\\\u0069`.unicoded' },
  utf16: { long: 'Encode UTF-16 little-endian bytes as hex.', ex: '`Hi`.utf16' },
  utf16be: { long: 'Encode UTF-16 big-endian bytes as hex.', ex: '`Hi`.utf16be' },
  charcode: { long: 'Convert characters to HTML numeric entities.', ex: '`hello`.charcode' },
  md5: { long: 'Generate MD5 hash (legacy/compatibility workflows).', ex: '`password123`.md5' },
  sha1: { long: 'Generate SHA-1 hash.', ex: '`password123`.sha1' },
  sha224: { long: 'Generate SHA-224 hash.', ex: '`password123`.sha224' },
  sha256: { long: 'Generate SHA-256 hash.', ex: '`password123`.sha256' },
  sha384: { long: 'Generate SHA-384 hash.', ex: '`password123`.sha384' },
  sha512: { long: 'Generate SHA-512 hash.', ex: '`password123`.sha512' },
  scheme: { long: 'Extract URL scheme/protocol.', ex: '`https://sub.example.com/path`.scheme' },
  host: { long: 'Extract hostname from URL.', ex: '`https://sub.example.com/path`.host' },
  port: { long: 'Extract URL port.', ex: '`https://site.test:8080/x`.port' },
  path: { long: 'Extract URL path.', ex: '`https://site.test/a/b?q=1`.path' },
  query: { long: 'Extract URL query string (without `?`).', ex: '`https://site.test/a?x=1&y=2`.query' },
  keys: { long: 'Extract query parameter names.', ex: '`https://site.test/a?x=1&y=2`.keys' },
  value: { long: 'Extract query parameter values.', ex: '`https://site.test/a?x=1&y=2`.value' },
  domain: { long: 'Extract scheme + host.', ex: '`https://sub.example.com/path`.domain' },
  tld: { long: 'Extract top-level domain.', ex: '`https://sub.example.co.uk/path`.tld' },
  subdomain: { long: 'Extract subdomain portion.', ex: '`https://api.eu.example.com/path`.subdomain' },
  allsub: { long: 'Extract all subdomain parts as separate lines.', ex: '`https://api.eu.example.com/path`.allsub' },
  alldir: { long: 'Split URL path into directory parts.', ex: '`https://site.test/a/b/c`.alldir' },
  fragment: { long: 'Extract URL fragment/hash value.', ex: '`https://site.test/a#section2`.fragment' },
  user: { long: 'Extract username from URL credentials or raw `user:pass` input.', ex: '`admin:Secret123`.user' },
  pass: { long: 'Extract password from URL credentials or raw `user:pass` input.', ex: '`admin:Secret123`.pass' },
  smart: { long: 'Split camelCase, snake_case, and kebab-case into words.', ex: '`helloWorld_test-case`.smart' },
  smartjoin: { long: 'Join smart-split words with chosen case + separator.', ex: '`hello_world`.smartjoin[l:-]' },
  leet: { long: 'Generate leetspeak variants (`leet[0]` combined, `leet[1]` expanded).', ex: '`hello`.leet[1]' },
  json: { long: 'Extract JSON key path value from each line.', ex: '`{\"name\":\"alice\"}`.json[name]' },
  regex: { long: 'Extract regex matches from each line.', ex: '`abc123def456`.regex[[0-9]+]' }
};
const METHOD_PARAM_GUIDE = {
  contains: 'Params: [text] - keep only lines containing text.',
  grep: 'Params: [text] or [/regex/flags] or [re:pattern] - keep matching lines.',
  grepv: 'Params: same as grep - remove matching lines.',
  awkn: 'Params: [index:delimiter] - pick a field (0-based). Example awkn[1::] for password from user:pass.',
  starts: 'Params: [prefix] - keep only lines starting with prefix.',
  ends: 'Params: [suffix] - keep only lines ending with suffix.',
  minlength: 'Params: [n] - keep strings with length >= n.',
  maxlength: 'Params: [n] - keep strings with length <= n.',
  replace: 'Params: [old:new] - replaces every old occurrence with new.',
  split: 'Params: [delimiter] - example split[:] or split[,].',
  splitindex: 'Params: [delimiter:index] - example splitindex[-:1].',
  smartjoin: 'Params: [case:separator] - case l/u/t/c and custom separator.',
  leet: 'Params: [0|1] - 0 combined replacement, 1 emit variants.',
  json: 'Params: [key] or nested [user:name] for object path extraction.',
  regex: 'Params: [pattern] - JS regex pattern, e.g. [[0-9]+].'
};
const METHOD_MODAL_STATE = { query: '', category: 'all', selected: 'md5', lastClickName: '', lastClickTs: 0 };
const EXAMPLES_MODAL_STATE = { query: '', category: 'all', selected: 0, lastClickIndex: -1, lastClickTs: 0 };
const METHOD_FLOW_STATE = { items: [], dragIndex: -1, dragMethod: '', nextId: 1, sourceMethod: '' };
const METHOD_SELECTION = new Set();
const WORKFLOW_HISTORY = { undo: [], redo: [], max: 80, restoring: false };
let METHOD_FLOW_LAST_SYNC = '';
let LAST_PATTERN_TEXT_FOR_UNDO = '';

function isMutationFlowItem(item) {
  return !!item && (item.type === 'mutation' || item.method === '__mutation__');
}

function createMutationFlowItem(profile, words, x, y) {
  return {
    id: METHOD_FLOW_STATE.nextId++,
    type: 'mutation',
    source: 'global',
    method: '__mutation__',
    profile: profile === 'aggressive' ? 'aggressive' : 'balanced',
    words: String(words || ''),
    x: Number.isFinite(x) ? x : 0,
    y: Number.isFinite(y) ? y : 0
  };
}
function extractPatternMethodsFromText(patternText) {
  const methods = [];
  const entries = extractPatternMethodEntriesFromText(patternText);
  for (const e of entries) methods.push(e.method);
  return methods;
}

function getPatternTokensWithRanges(text) {
  const raw = String(text || '');
  const tokens = [];
  let inBacktick = false;
  let start = -1;
  for (let i = 0; i < raw.length; i++) {
    const ch = raw[i];
    if (ch === '`') {
      if (start < 0) start = i;
      inBacktick = !inBacktick;
      continue;
    }
    const isSep = !inBacktick && (ch === ' ' || ch === '\t' || ch === '\n');
    if (isSep) {
      if (start >= 0) {
        tokens.push({ token: raw.slice(start, i), start, end: i });
        start = -1;
      }
      continue;
    }
    if (start < 0) start = i;
  }
  if (start >= 0) tokens.push({ token: raw.slice(start), start, end: raw.length });
  return tokens;
}

function extractPatternMethodEntriesFromText(patternText) {
  const out = [];
  const pattern = String(patternText || '').trim();
  const tokens = pattern ? getPatternTokensWithRanges(patternText) : [];
  for (let tokenIndex = 0; tokenIndex < tokens.length; tokenIndex++) {
    const tokenObj = tokens[tokenIndex];
    const token = tokenObj.token;
    if (!token) continue;
    if (token.startsWith('`')) {
      let close = -1;
      let escaped = false;
      for (let i = 1; i < token.length; i++) {
        const ch = token[i];
        if (ch === '\\' && !escaped) { escaped = true; continue; }
        if (ch === '`' && !escaped) { close = i; break; }
        escaped = false;
      }
      if (close > 0) {
        const suffix = token.slice(close + 1);
        if (suffix.startsWith('.')) {
          const parts = CookParser.splitMethods('x' + suffix);
          if (parts.length > 1) {
            parts.slice(1).forEach((m, methodIndex) => {
              out.push({ method: m, tokenIndex, methodIndex });
            });
          }
        }
      }
      continue;
    }
    if (/^[A-Za-z_][A-Za-z0-9_]*(\.[A-Za-z_][A-Za-z0-9_]*(\[[^\]]*\])?)+$/.test(token)) {
      const parts = CookParser.splitMethods(token);
      if (parts.length > 1) {
        parts.slice(1).forEach((m, methodIndex) => {
          out.push({ method: m, tokenIndex, methodIndex });
        });
      }
    }
  }
  return out;
}
const METHOD_NODE_UI = { width: 220, rowHeight: 108, gap: 26, compact: false };
const EXAMPLE_LIBRARY = [
  { name: 'Combo Permutation', tags: ['cross-product'], pattern: 'admin,root _,- pass,secret', options: { methods: 'upper' }, output: 'ADMIN_PASS\nADMIN_SECRET\nADMIN-PASS\nADMIN-SECRET\nROOT_PASS\nROOT_SECRET\nROOT-PASS\nROOT-SECRET' },
  { name: 'Zero-Padded Range', tags: ['range'], pattern: '01-05', options: { methods: 'md5' }, output: '96a3be3cf272e017046d1b2674a52bd3\n...' },
  { name: 'Repeat Range Operator', tags: ['repeat'], pattern: 'r*2-5', options: { methods: 'reverse' }, output: 'rr\nrrr\nrrrr\nrrrrr' },
  { name: 'Literal + Chain', tags: ['dot-chain'], pattern: '`hello world`.upper.reverse', output: 'DLROW OLLEH' },
  { name: 'Variable + Hash', tags: ['variables', 'hash'], pattern: 'p.upper.md5', params: [{ name: 'p', value: 'hello,world' }], output: 'eb61eead90e3b899c6bcbe27ac581660\n5289492cf082446ca4a6eec9f72f1ec3' },
  { name: 'Replace + Base64', tags: ['encoding'], pattern: '`hello world`.replace[o:0].b64e', output: 'aGVsbDAgdzBybGQ=' },
  { name: 'Regex Extract', tags: ['regex'], pattern: '`abc123def456`.regex[[0-9]+]', output: '123\n456' },
  { name: 'JSON + Upper', tags: ['json'], pattern: '`{"name":"alice","age":30}`.json[name].upper', output: 'ALICE' },
  { name: 'URL Host + TLD', tags: ['url'], pattern: 'p.host.tld', params: [{ name: 'p', value: 'https://sub.example.com/path,https://api.test.io/v1' }], output: 'com\nio' },
  { name: 'Raw Credential Split', tags: ['advanced', 'dot-chain'], pattern: '`admin:Secret123,bob:hunter2`.user', output: 'admin\nbob' },
  { name: 'Smart + Sortu', tags: ['smart'], pattern: 'p.smart.sortu', params: [{ name: 'p', value: 'helloWorld,hello_world,hello-world' }], output: 'World\nhello\nworld' },
  { name: 'Leet Variants', tags: ['leet[1]'], pattern: '`hello my name is alice`.leet[1]', output: 'hell0 my name is alice\nhello my name 1s alice\nhell0 my name 1s alice\nh3llo my nam3 is alice\nh3ll0 my nam3 1s alice\nhello my n4me is 4l1c3' },
  { name: 'Append Mode', tags: ['line-by-line'], pattern: 'alice,bob 1,2', options: { mode: 'append', methods: 'lower' }, output: 'alice1\nbob2' },
  { name: 'Mutation Wordlist', tags: ['mutation', 'wordlists'], pattern: 'admin,root', options: { mode: 'mutation', mutateProfile: 'balanced', mutateWords: 'corp,secure' }, output: 'admin\nadmin1\nadmin-secure\ncorpadmin' },
  { name: 'Per-Column Methods', tags: ['col methods'], pattern: 'john,alice 5,7', options: { colmethods: '0:upper;1:md5' }, output: 'JOHNe4da3b7fbbce2345d7772b0674a318d5\nJOHN8f14e45fceea167a5a36dedd4bea2543\nALICEe4da3b7fbbce2345d7772b0674a318d5\nALICE8f14e45fceea167a5a36dedd4bea2543' },
  { name: 'SplitIndex + Upper', tags: ['dot-chain'], pattern: '`alpha-beta-gamma`.splitindex[-:1].upper', output: 'BETA' },
  { name: 'Unicode Roundtrip', tags: ['encode/decode'], pattern: '`Hi!`.unicodee.unicoded.upper', output: 'HI!' },
  { name: 'Split + Sortu', tags: ['dot-chain'], pattern: '`alpha:beta:gamma`.split[:].sortu', output: 'alpha\nbeta\ngamma' },
  { name: 'Email Usernames', tags: ['regex', 'dot-chain'], pattern: '`alice@test.com,bob@demo.io`.split[,].splitindex[@:0].lower', output: 'alice\nbob' },
  { name: 'Path Wordlist', tags: ['url', 'dot-chain'], pattern: '`/admin/panel/login`.split[/].minlength[1].sortu', output: 'admin\nlogin\npanel' },
  { name: 'Credential Passwords', tags: ['advanced', 'dot-chain'], pattern: '`alice:123\nbob:secret123\nguest:qwerty`.pass.sortu', output: '123\nsecret123\nqwerty' },
  { name: 'Credential Users + Hash', tags: ['advanced', 'hash'], pattern: '`alice:123\nbob:secret123`.user.md5', output: 'f4f8....' },
  { name: 'Domain Recon', tags: ['url', 'dot-chain'], pattern: '`api.eu.example.co.uk`.subdomain', output: 'api.eu' },
  { name: 'TLD Extractor', tags: ['url', 'dot-chain'], pattern: '`example.com,example.org`.split[,].tld.sortu', output: 'com\norg' },
  { name: 'Regex to SHA1', tags: ['regex', 'hash'], pattern: '`ID-42 ticket-900`.regex[[0-9]+].sha1', output: '92cf...\n...' },
  { name: 'Smart Join Slug', tags: ['smart', 'dot-chain'], pattern: '`HelloWorld,TestCase`.split[,].smartjoin[l:-]', output: 'hello-world\ntest-case' },
  { name: 'URL Encode Pipeline', tags: ['encoding', 'dot-chain'], pattern: '`hello world + admin`.urle.upper', output: 'HELLO%20WORLD%20%2B%20ADMIN' },
  { name: 'JSON Nested Key', tags: ['json', 'dot-chain'], pattern: '`{"user":{"name":"alice","id":7}}`.json[user:name].upper', output: 'ALICE' },
  { name: 'Hex Roundtrip', tags: ['encode/decode', 'dot-chain'], pattern: '`Secret42`.hexe.hexd.upper', output: 'SECRET42' },
  { name: 'Leet + Reverse', tags: ['leet[1]', 'dot-chain'], pattern: '`password`.leet[1].reverse', output: 'dr0wss4p\n...' },
  { name: 'Replace Attack Pattern', tags: ['dot-chain'], pattern: '`admin_login`.replace[_:-].upper', output: 'ADMIN-LOGIN' },
  { name: 'Charcode Payload', tags: ['encoding', 'dot-chain'], pattern: '`alert(1)`.charcode', output: '&#97;&#108;...' },
  { name: 'Subdomain Burst', tags: ['url', 'dot-chain'], pattern: '`dev.api.stage.example.com`.allsub.sortu', output: 'api\ndev\nstage' },
  { name: 'Trim + Unique Wordlist', tags: ['dot-chain'], pattern: '`  admin  ,admin, root ,root `.split[,].trim.unique', output: 'admin\nroot' },
  { name: 'Contains Admin Filter', tags: ['dot-chain'], pattern: '`admin-panel,user-home,admin-api`.split[,].contains[admin]', output: 'admin-panel\nadmin-api' },
  { name: 'Grep API Hosts', tags: ['filters', 'dot-chain', 'url'], pattern: '`api.example.com\ncdn.example.com\napi.test.net`.grep[api.]', output: 'api.example.com\napi.test.net' },
  { name: 'Inverse Grep Guests', tags: ['filters', 'dot-chain'], pattern: '`admin\nguest\nops\nguest-demo`.grepv[guest]', output: 'admin\nops' },
  { name: 'AWK User Column', tags: ['filters', 'credentials', 'dot-chain'], pattern: '`alice:pass123\nbob:secret!\nguest:qwerty`.awkn[0::]', output: 'alice\nbob\nguest' },
  { name: 'AWK Password Column', tags: ['filters', 'credentials', 'dot-chain'], pattern: '`alice:pass123\nbob:secret!\nguest:qwerty`.awkn[1::]', output: 'pass123\nsecret!\nqwerty' },
  { name: 'Regex Grep Status', tags: ['filters', 'regex', 'dot-chain'], pattern: '`200 OK\n500 ERROR\n404 MISS\n503 DOWN`.grep[/^5\\d\\d/]', output: '500 ERROR\n503 DOWN' },
  { name: 'Path Field Then Filter', tags: ['filters', 'url', 'dot-chain'], pattern: '`GET /api/v1/users\nPOST /login\nGET /api/v1/admin`.awkn[1: ].starts[/api/]', output: '/api/v1/users\n/api/v1/admin' },
  { name: 'StartsWith API Prefix', tags: ['dot-chain'], pattern: '`api-v1,web-v1,api-v2`.split[,].starts[api-]', output: 'api-v1\napi-v2' },
  { name: 'EndsWith JSON Files', tags: ['dot-chain'], pattern: '`alphaJSON,betaTXT,gammaJSON`.split[,].ends[JSON]', output: 'alphaJSON\ngammaJSON' },
  { name: 'MinLength Passwords', tags: ['dot-chain'], pattern: '`root,admin123,guest01,SuperSecure99`.split[,].minlength[8]', output: 'admin123\nSuperSecure99' },
  { name: 'MaxLength Usernames', tags: ['dot-chain'], pattern: '`administrator,alice,ops,dev-team`.split[,].maxlength[6]', output: 'alice\nops' },
  { name: 'Credential Pipeline', tags: ['advanced', 'dot-chain'], pattern: '`alice:12345678\nbob:secret1234\nguest:123`.pass.minlength[6].sha1', output: '7c222fb2927d828af22f592134e8932480637c0d\n...' },
  { name: 'Mixed Recon Chain', tags: ['url', 'dot-chain'], pattern: '`api.example.com,cdn.example.com`.split[,].subdomain.unique', output: 'api\ncdn' }
];
const RECIPE_LIBRARY = [
  {
    name: 'Scope Host Extraction From URL Archive',
    category: 'bugbounty',
    summary: 'Turn noisy historical URLs into a deduplicated host target list for recon.',
    pattern: '`https://app.example.com/login?next=/dashboard\nhttps://cdn.example.com/assets/app.js?v=2\nhttps://api.example.com/v1/users?id=42\nhttps://api.example.com/v1/users/42?expand=profile\nhttps://admin.example.com/panel\nhttps://cdn.example.com/assets/vendor.js\nhttps://staging-api.example.com/v1/health\nhttps://m.example.com/reset-password\nhttps://app.example.com/logout\nhttps://beta.example.com/invite`',
    options: { methods: 'split[\n],host,unique,sortu' },
    output: 'admin.example.com\napi.example.com\napp.example.com\nbeta.example.com\ncdn.example.com\nm.example.com\nstaging-api.example.com'
  },
  {
    name: 'Query Parameter Candidate Extraction',
    category: 'bugbounty',
    summary: 'Extract unique query keys from captured endpoints for fuzzing and param mining.',
    pattern: '`https://shop.example.com/search?q=phone&lang=en&sort=price\nhttps://shop.example.com/cart?coupon=SAVE10&currency=USD\nhttps://api.example.com/v1/orders?limit=50&offset=0&status=open\nhttps://api.example.com/v1/users?role=admin&page=2\nhttps://portal.example.com/export?format=csv&token=abc123\nhttps://api.example.com/v2/invoices?from=2026-01-01&to=2026-02-01`',
    options: { methods: 'split[\n],keys,unique,sortu' },
    output: 'coupon\ncurrency\nformat\nfrom\nlang\nlimit\noffset\npage\nq\nrole\nsort\nstatus\nto\ntoken'
  },
  {
    name: 'Likely API Route Isolation',
    category: 'bugbounty',
    summary: 'Filter mixed path lists and keep only probable API routes for endpoint testing.',
    pattern: '`/login\n/assets/logo.svg\n/api/v1/users\n/api/v1/admin\n/docs/index.html\n/api/v2/invoices\n/static/js/main.js\n/health\n/api/internal/metrics\n/images/bg.png\n/api/v1/profile\n/contact`',
    options: { methods: 'split[\n],contains[/api/],unique,sortu' },
    output: '/api/internal/metrics\n/api/v1/admin\n/api/v1/profile\n/api/v1/users\n/api/v2/invoices'
  },
  {
    name: 'Credential Username Extraction (Combo Lists)',
    category: 'identity',
    summary: 'Parse large combo-format leaks and isolate usernames for identity exposure review.',
    pattern: '`alice.admin@corp.local:Welcome2026!\nbob.ops@corp.local:Winter#2025\nguest.portal@corp.local:Summer123!\nalice.admin@corp.local:ResetMe123\ncarol.finance@corp.local:Invoice#778\nservice.backup@corp.local:Backup!2026\ndev.portal@corp.local:Build#992\nsupport.team@corp.local:Ticket@901`',
    options: { methods: 'split[\n],awkn[0::],trim,lower,unique,sortu' },
    output: 'alice.admin@corp.local\nbob.ops@corp.local\ncarol.finance@corp.local\ndev.portal@corp.local\nguest.portal@corp.local\nservice.backup@corp.local\nsupport.team@corp.local'
  },
  {
    name: 'Weak Password Candidate Isolation',
    category: 'identity',
    summary: 'Extract password values and filter out short entries for credential hygiene checks.',
    pattern: '`alice:admin\nbob:Welcome2026!\nguest:Summer!\nops:Winter2025#\nportal:Password1\nbackup:Qwerty!\nroot:toor\nsecops:BlueTeam#2026`',
    options: { methods: 'split[\n],awkn[1::],trim,minlength[8],unique,sortu' },
    output: 'BlueTeam#2026\nPassword1\nWelcome2026!\nWinter2025#'
  },
  {
    name: 'HTTP 5xx Incident Line Extraction',
    category: 'secops',
    summary: 'Filter server logs to retain only outage-related 5xx lines for triage.',
    pattern: '`2026-02-01T10:00:11Z GET /login 200\n2026-02-01T10:01:09Z POST /api/auth 500\n2026-02-01T10:02:13Z GET /admin 403\n2026-02-01T10:02:50Z GET /api/data 503\n2026-02-01T10:03:44Z GET /health 200\n2026-02-01T10:05:02Z POST /api/payment 502\n2026-02-01T10:05:42Z GET /status 200\n2026-02-01T10:06:21Z GET /api/inventory 504`',
    options: { methods: 'grep[/5\\d\\d/],unique' },
    output: '2026-02-01T10:01:09Z POST /api/auth 500\n2026-02-01T10:02:50Z GET /api/data 503\n2026-02-01T10:05:02Z POST /api/payment 502\n2026-02-01T10:06:21Z GET /api/inventory 504'
  },
  {
    name: 'IOC Domain Normalization',
    category: 'secops',
    summary: 'Normalize IOC domains from different analyst sources into one canonical list.',
    pattern: '`  MALWARE-CDN.EXAMPLE.NET \nC2-gateway.example.org\nmalware-cdn.example.net\nredirector.example.org \nBeacon-A.EXAMPLE.IO\nbeacon-a.example.io\n   c2-gateway.example.org`',
    options: { methods: 'split[\n],trim,lower,unique,sortu' },
    output: 'beacon-a.example.io\nc2-gateway.example.org\nmalware-cdn.example.net\nredirector.example.org'
  },
  {
    name: 'JWT-Like Token Harvest From Logs',
    category: 'appsec',
    summary: 'Extract probable JWT tokens from logs/source snippets for token handling review.',
    pattern: '`Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.signature\nconst token = \"eyJhbGciOiJIUzI1NiJ9.payload.sig\";\nX-Session: eyJraWQiOiIxIn0.eyJ1c2VyIjoiYWxpY2UifQ.zzz\nrandom text without token\njwt=eyJhbGciOiJIUzI1NiJ9.e30.abc123`',
    options: { methods: 'regex[[A-Za-z0-9_-]+\\.[A-Za-z0-9_-]+\\.[A-Za-z0-9_-]+],unique' },
    output: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.signature\neyJhbGciOiJIUzI1NiJ9.payload.sig\neyJraWQiOiIxIn0.eyJ1c2VyIjoiYWxpY2UifQ.zzz\neyJhbGciOiJIUzI1NiJ9.e30.abc123'
  },
  {
    name: 'JSON Field Extraction For Asset Inventory',
    category: 'appsec',
    summary: 'Extract service names from JSON lines exported by service discovery tools.',
    pattern: '`{"service":"billing","env":"prod","owner":"secops"}\n{"service":"identity","env":"prod","owner":"iam"}\n{"service":"catalog","env":"staging","owner":"appsec"}\n{"service":"billing","env":"dr","owner":"secops"}`.json[service]',
    options: { methods: 'unique,sortu' },
    output: 'billing\ncatalog\nidentity'
  },
  {
    name: 'Subdomain Pivot Seed Builder',
    category: 'intel',
    summary: 'Convert host inventories into subdomain seeds for pivoting and clustering.',
    pattern: '`api.eu.example.com\ncdn.assets.example.com\nvpn.example.com\napi.us.example.com\nm.eu.example.com\nauth.id.example.com\nassets.example.com`',
    options: { methods: 'split[\n],subdomain,unique,sortu' },
    output: 'api.eu\napi.us\nauth.id\nassets\ncdn.assets\nm.eu\nvpn'
  },
  {
    name: 'TLD Profile Extraction',
    category: 'intel',
    summary: 'Extract TLD distribution from campaign host sets for quick profiling.',
    pattern: '`example.com\nsecure-example.net\npayments.example.org\nmirror.example.com\nassets.sample.io\ngateway.demo.co.uk\ntracker.example.net`',
    options: { methods: 'split[\n],tld,unique,sortu' },
    output: 'com\nio\nnet\norg\nuk'
  },
  {
    name: 'Role/Region Username Builder',
    category: 'wordlists',
    summary: 'Generate structured username candidates from role, region, and environment tokens.',
    pattern: 'admin,ops,dev us,eu,apac _,- corp,prod',
    options: { methods: 'unique,sortu' },
    output: 'admin-apac-corp\nadmin_apac_corp\n...\nops_us_prod'
  },
  {
    name: 'Mutation Wordlist Expansion',
    category: 'wordlists',
    summary: 'Expand base seeds into realistic variants using mutation mode and context words.',
    pattern: 'admin,portal,service,backup',
    options: { mode: 'mutation', mutateProfile: 'balanced', mutateWords: 'corp,secure,prod,cloud,internal' },
    output: 'admin\nadmin1\nadmin2026\nsecureadmin\ncloud-admin\n...'
  },
  {
    name: 'Credential Password Pipeline To SHA1',
    category: 'secops',
    summary: 'Extract password values and hash them for legacy verification workflows.',
    pattern: '`alice:Welcome2026!\nbob:Winter2025#\nguest:admin123\nops:BlueTeam#2026\nsvc:RotateMe!2026`',
    options: { methods: 'split[\n],awkn[1::],trim,minlength[8],sha1,unique' },
    output: '2f44...\n9ac1...'
  },
  {
    name: 'Simple: Grep Staging Domains',
    category: 'bugbounty',
    summary: 'Keep only staging/dev hosts from a mixed domain list.',
    pattern: '`api.example.com\nstaging-api.example.com\ndev-portal.example.com\ncdn.example.com\nauth.example.com\ntest-auth.example.com\nprod-app.example.com`',
    options: { methods: 'split[\n],grep[/staging|dev|test/i],unique,sortu' },
    output: 'dev-portal.example.com\nstaging-api.example.com\ntest-auth.example.com'
  },
  {
    name: 'Simple: Extract Hostnames From URLs',
    category: 'bugbounty',
    summary: 'Extract unique hosts from collected URL lists.',
    pattern: '`https://shop.example.com/cart?coupon=NEW\nhttps://api.example.com/v1/users?id=5\nhttps://cdn.example.com/assets/app.js\nhttps://shop.example.com/checkout\nhttps://img.example.com/logo.png`',
    options: { methods: 'split[\n],host,unique,sortu' },
    output: 'api.example.com\ncdn.example.com\nimg.example.com\nshop.example.com'
  },
  {
    name: 'Simple: Extract URL Paths',
    category: 'bugbounty',
    summary: 'Extract request paths for endpoint mapping.',
    pattern: '`https://api.example.com/v1/users?id=5\nhttps://api.example.com/v2/orders/42\nhttps://shop.example.com/login\nhttps://shop.example.com/cart/checkout`',
    options: { methods: 'split[\n],path,unique,sortu' },
    output: '/cart/checkout\n/login\n/v1/users\n/v2/orders/42'
  },
  {
    name: 'Simple: Keep JavaScript URLs',
    category: 'appsec',
    summary: 'Filter only JavaScript assets from mixed URL inventories.',
    pattern: '`https://cdn.example.com/app.js\nhttps://cdn.example.com/app.css\nhttps://shop.example.com/index.html\nhttps://cdn.example.com/vendor.min.js\nhttps://api.example.com/v1/users`',
    options: { methods: 'split[\n],contains[.js],unique,sortu' },
    output: 'https://cdn.example.com/app.js\nhttps://cdn.example.com/vendor.min.js'
  },
  {
    name: 'Simple: Remove Guest/Service Accounts',
    category: 'identity',
    summary: 'Exclude guest/service accounts from username lists.',
    pattern: '`admin\nops\nguest\nservice-api\nqa-user\nguest-demo\nsecurity`',
    options: { methods: 'split[\n],grepv[/guest|service/i],unique,sortu' },
    output: 'admin\nops\nqa-user\nsecurity'
  },
  {
    name: 'Simple: Extract Emails',
    category: 'secops',
    summary: 'Extract email addresses from logs, alerts, or notes.',
    pattern: '`alert owner=alice@example.com source=siem\ncontact: bob.ops@example.org\nnoise line\naudit by carol.sec@example.net and dave@example.net`',
    options: { methods: 'regex[\\w+([.-]?\\w+)*@\\w+([.-]?\\w+)*\\.\\w+],unique,sortu' },
    output: 'alice@example.com\nbob.ops@example.org\ncarol.sec@example.net\ndave@example.net'
  },
  {
    name: 'Simple: Subdomain List From FQDNs',
    category: 'intel',
    summary: 'Extract subdomain prefixes from FQDN inventories.',
    pattern: '`api.eu.example.com\ncdn.assets.example.com\nvpn.example.com\nauth.id.example.com`',
    options: { methods: 'split[\n],subdomain,unique,sortu' },
    output: 'api.eu\nauth.id\ncdn.assets\nvpn'
  },
  {
    name: 'Simple: TLD Extraction',
    category: 'intel',
    summary: 'Extract top-level domains for quick domain footprint analysis.',
    pattern: '`example.com\nportal.example.org\nstatic.sample.io\ngateway.company.co.uk\ninternal.company.net`',
    options: { methods: 'split[\n],tld,unique,sortu' },
    output: 'co.uk\ncom\nio\nnet\norg'
  },
  {
    name: 'Simple: Clean + Deduplicate Wordlist',
    category: 'wordlists',
    summary: 'Trim whitespace and deduplicate noisy wordlists.',
    pattern: '`  admin\nadmin\n root \nops\nops\nsecurity-team  `',
    options: { methods: 'split[\n],trim,unique,sortu' },
    output: 'admin\nops\nroot\nsecurity-team'
  },
  {
    name: 'Simple: Keep Strong Passwords',
    category: 'identity',
    summary: 'Filter candidate passwords by minimum length.',
    pattern: '`admin\nwelcome\nSummer2026!\nBlueTeam#2026\nqwerty\nS3curePass!`',
    options: { methods: 'split[\n],minlength[10],unique,sortu' },
    output: 'BlueTeam#2026\nS3curePass!\nSummer2026!'
  },
  {
    name: 'Advanced: API Key Pattern Harvest',
    category: 'appsec',
    summary: 'Extract probable API keys/tokens from source blobs.',
    pattern: '`const KEY=\"sk_live_51NabCDEFGhijklmnopqrstuv\";\napi_key=AKIAIOSFODNN7EXAMPLE\nBearer eyJhbGciOiJIUzI1NiJ9.e30.signature\nsecret=not-a-key\nstripe=sk_test_51ZZZZZZZZZZZZZZZZZZZZ`',
    options: { methods: 'regex[(sk_(live|test)_\\w+|AKIA\\w+|\\S+\\.\\S+\\.\\S+)],unique' },
    output: 'sk_live_...\nAKIA...\neyJhbGci...\nsk_test_...'
  },
  {
    name: 'Advanced: Error Endpoint Correlation',
    category: 'secops',
    summary: 'Keep only 5xx lines and extract the affected endpoint path.',
    pattern: '`2026-03-01 GET /login 200\n2026-03-01 POST /api/auth 500\n2026-03-01 GET /api/users 503\n2026-03-01 GET /health 200\n2026-03-01 POST /api/payment 502`',
    options: { methods: 'split[\n],grep[/5\\d\\d/],awkn[2: ],unique,sortu' },
    output: '/api/auth\n/api/payment\n/api/users'
  },
  {
    name: 'Advanced: Credential Password SHA256 Set',
    category: 'secops',
    summary: 'Extract passwords from combos and hash with SHA-256 for legacy matching.',
    pattern: '`alice:Welcome2026!\nbob:Winter2025#\nqa:Qwerty123!\nops:BlueTeam#2026\nsvc:RotateMe!2026`',
    options: { methods: 'split[\n],awkn[1::],trim,minlength[8],sha256,unique' },
    output: '8f9d...\n4b3a...\n...'
  },
  {
    name: 'Advanced: Parameter Value Wordlist',
    category: 'bugbounty',
    summary: 'Extract unique query values from URL lists for payload seeding.',
    pattern: '`https://shop.example.com/search?q=laptop&lang=en\nhttps://shop.example.com/search?q=phone&lang=fr\nhttps://api.example.com/v1/users?role=admin&page=2\nhttps://api.example.com/v1/users?role=ops&page=7`',
    options: { methods: 'split[\n],value,trim,unique,sortu' },
    output: '2\n7\nadmin\nen\nfr\nlaptop\nops\nphone'
  },
  {
    name: 'Advanced: JS Endpoint Discovery Seeds',
    category: 'appsec',
    summary: 'Extract API-like paths from JavaScript snippets/logs for endpoint testing.',
    pattern: '`fetch(\"/api/v1/users\")\naxios.get(\"/api/v2/orders\")\nconst x=\"/static/app.js\"\nPOST /api/admin/invite\nwindow.location=\"/login\"`',
    options: { methods: 'regex[/api/[A-Za-z0-9_\\/-]+],unique,sortu' },
    output: '/api/admin/invite\n/api/v1/users\n/api/v2/orders'
  },
  {
    name: 'Advanced: Environment Host Segmentation',
    category: 'intel',
    summary: 'Split hosts by environment keywords (dev/stage/prod) for targeted testing.',
    pattern: '`dev-api.example.com\nstage-api.example.com\nprod-api.example.com\ndev-auth.example.com\nprod-auth.example.com\ncdn.example.com`',
    options: { methods: 'split[\n],grep[/dev|stage|prod/],unique,sortu' },
    output: 'dev-api.example.com\ndev-auth.example.com\nprod-api.example.com\nprod-auth.example.com\nstage-api.example.com'
  }
];
let acState = { input: null, items: [], activeIndex: 0, replaceRange: null, mode: '', meta: {} };

function getMethodCategory(name) {
  const n = name.toLowerCase();
  const hashing = new Set(['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512']);
  const encoding = new Set(['b64e', 'b64d', 'hexe', 'hexd', 'urle', 'urld', 'urlea', 'jsone', 'jsonu', 'xmle', 'xmlu', 'unicodee', 'unicoded', 'utf16', 'utf16be', 'charcode']);
  const web = new Set(['scheme', 'host', 'port', 'path', 'query', 'keys', 'value', 'domain', 'tld', 'subdomain', 'allsub', 'alldir', 'fragment', 'user', 'pass']);
  const regex = new Set(['regex']);
  if (hashing.has(n)) return 'hashing';
  if (encoding.has(n)) return 'encoding';
  if (web.has(n)) return 'web';
  if (regex.has(n)) return 'regex';
  return 'string';
}

function escapeHtml(value) {
  return String(value)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function renderStepPreview(targetId, title, lines, total, hint) {
  const el = document.getElementById(targetId);
  if (!el) return;
  el.style.display = 'block';
  const arr = Array.isArray(lines) ? lines : [];
  const textLines = [];
  let truncated = false;
  for (let i = 0; i < arr.length; i++) {
    const parts = String(arr[i] ?? '').split(/\r?\n/);
    for (let j = 0; j < parts.length; j++) {
      const piece = parts[j];
      if (textLines.length >= STEP_PREVIEW_SHOW_LINES) {
        truncated = true;
        break;
      }
      textLines.push(piece);
    }
    if (truncated) break;
  }
  if (truncated || arr.length > STEP_PREVIEW_SHOW_LINES) textLines.push('...');
  const text = textLines.length ? textLines.join('\n') : '(no lines)';
  const shownCount = Math.min(STEP_PREVIEW_SHOW_LINES, Math.max(0, Number(total) || 0));
  const meta = total > shownCount ? `${shownCount}/${total.toLocaleString()} lines` : `${total.toLocaleString()} lines`;
  const hintText = hint ? ` · ${hint}` : '';
  el.dataset.previewCopy = text;
  el.title = 'Click to copy this preview';
  el.innerHTML = `<div class="node-step-head"><span class="node-step-title">${escapeHtml(title)}</span><span class="node-step-meta">${escapeHtml(meta + hintText)}</span></div><pre class="node-step-lines">${escapeHtml(text)}</pre>`;
}

function setStepPreviewVisible(targetId, visible) {
  const el = document.getElementById(targetId);
  if (!el) return;
  el.style.display = visible ? 'block' : 'none';
}

function clearStepPreviews() {
  setStepPreviewVisible('step-preview-input', false);
  setStepPreviewVisible('step-preview-options', false);
  document.querySelectorAll('[id^="step-preview-method-"]').forEach((el) => {
    el.style.display = 'none';
    el.innerHTML = '';
  });
}

function buildPatternMethodRankMap(items, patternChain) {
  const map = new Map();
  const chain = Array.isArray(patternChain) ? patternChain : [];
  const patternItems = items
    .filter((it) => it && it.source === 'pattern')
    .slice()
    .sort((a, b) => (a.id - b.id));
  const withMeta = patternItems
    .filter((it) => Number.isFinite(it.patternTokenIndex) && Number.isFinite(it.patternMethodIndex))
    .slice()
    .sort((a, b) => (a.patternTokenIndex - b.patternTokenIndex) || (a.patternMethodIndex - b.patternMethodIndex) || (a.id - b.id));
  let metaRank = 0;
  for (const it of withMeta) {
    map.set(it.id, metaRank++);
  }
  const used = new Set();
  let rank = metaRank;
  for (const method of chain) {
    const idx = patternItems.findIndex((it) => !used.has(it.id) && String(it.method || '') === String(method || ''));
    if (idx >= 0) {
      const it = patternItems[idx];
      used.add(it.id);
      if (!map.has(it.id)) map.set(it.id, rank++);
    }
  }
  for (const it of patternItems) {
    if (!map.has(it.id)) map.set(it.id, rank++);
  }
  return map;
}

function getMethodItemsOrdered() {
  const stage = document.getElementById('workflow-stage');
  const pattern = document.getElementById('pattern')?.value || '';
  const patternChain = extractPatternMethodsFromText(pattern);
  const rankMap = buildPatternMethodRankMap(METHOD_FLOW_STATE.items, patternChain);
  const rows = METHOD_FLOW_STATE.items.map((item) => {
    const el = stage ? stage.querySelector(`.method-node[data-id="${item.id}"]`) : null;
    const y = parseFloat(el?.style.top || item.y || 0);
    const x = parseFloat(el?.style.left || item.x || 0);
    const pRank = item.source === 'pattern'
      ? (rankMap.has(item.id) ? rankMap.get(item.id) : Number.MAX_SAFE_INTEGER - 1)
      : Number.MAX_SAFE_INTEGER;
    return { item, y, x, pRank };
  });
  rows.sort((a, b) => {
    const ap = a.item.source === 'pattern';
    const bp = b.item.source === 'pattern';
    if (ap && bp) return (a.pRank - b.pRank) || (a.item.id - b.item.id);
    if (ap !== bp) return ap ? -1 : 1;
    return (a.y - b.y) || (a.x - b.x) || (a.item.id - b.item.id);
  });
  return rows.map((v) => v.item);
}

async function generatePreviewStage(patternCols, params, fileParams, options, limit) {
  const engine = new CookEngine(patternCols, params, {
    methodsForAll: options.methodsForAll || '',
    methodParam: options.methodParam || '',
    appendParam: options.appendParam || '',
    min: Number.isFinite(options.min) ? options.min : -1,
  });
  if (fileParams) engine.fileParams = fileParams;
  const origCollect = engine.collectResults.bind(engine);
  engine.collectResults = async function collectLimited() {
    await origCollect();
    if (this.allResults.length > limit) {
      this.allResults = this.allResults.slice(0, limit);
      this.cancelled = true;
    }
  };
  return engine.generateAsync();
}

function scheduleStepPreviewUpdate(delay = 180) {
  if (STEP_PREVIEW_TIMER) window.clearTimeout(STEP_PREVIEW_TIMER);
  const seq = ++STEP_PREVIEW_SEQ;
  STEP_PREVIEW_TIMER = window.setTimeout(() => { updateWorkflowStepPreviews(seq); }, delay);
}

async function collectPreviewContext() {
  const patternText = document.getElementById('pattern')?.value?.trim() || '';
  if (!patternText) return null;
  const patternCols = splitPatternColumns(patternText);
  const previewPatternCols = splitPatternColumnsForPreview(patternText);
  const params = {};
  for (const row of document.querySelectorAll('#param-rows .dyn-row')) {
    const name = row.querySelector('.param-name')?.value?.trim();
    const val = row.querySelector('.param-value')?.value?.trim();
    if (name) params[name] = val || '';
  }
  const fileParams = {};
  for (const row of document.querySelectorAll('#file-rows .dyn-row')) {
    const name = row.querySelector('.file-name')?.value?.trim();
    const fileInput = row.querySelector('.file-input');
    if (name && fileInput?.files && fileInput.files[0]) fileParams[name] = await readFileInput(fileInput);
  }
  const mode = document.getElementById('opt-mode').value;
  const minValue = parseInt(document.getElementById('opt-min').value, 10);
  let appendParam = document.getElementById('opt-append').value.trim();
  if (mode === 'append') {
    const cols = [];
    for (let i = 1; i < patternCols.length; i++) cols.push(String(i));
    appendParam = cols.join(',');
  }
  return {
    patternCols,
    previewPatternCols,
    params,
    fileParams,
    mode,
    min: Number.isFinite(minValue) ? minValue : -1,
    appendParam,
    methodParam: document.getElementById('opt-colmethods').value.trim(),
    globalMethods: parseMethodCsv(document.getElementById('opt-methods').value.trim())
  };
}

async function updateWorkflowStepPreviews(seq) {
  if (seq !== STEP_PREVIEW_SEQ) return;
  const ctx = await collectPreviewContext();
  if (seq !== STEP_PREVIEW_SEQ) return;
  if (!ctx) { clearStepPreviews(); return; }
  try {
    const inputStage = await generatePreviewStage(ctx.previewPatternCols, ctx.params, ctx.fileParams, {
      methodsForAll: '',
      methodParam: '',
      appendParam: ctx.mode === 'append' ? ctx.appendParam : '',
      min: ctx.min
    }, STEP_PREVIEW_LIMIT);
    if (seq !== STEP_PREVIEW_SEQ) return;
    setStepPreviewVisible('step-preview-input', true);
    renderStepPreview('step-preview-input', 'Input Expansion', inputStage, inputStage.length, ctx.mode === 'append' ? 'line-by-line base' : '');

    const hasRules =
      ctx.mode !== 'permutation' ||
      !!ctx.methodParam ||
      !!ctx.appendParam ||
      ctx.min !== -1 ||
      ctx.globalMethods.length > 0;

    let rulesStage = await generatePreviewStage(ctx.previewPatternCols, ctx.params, ctx.fileParams, {
      methodsForAll: '',
      methodParam: ctx.methodParam,
      appendParam: ctx.appendParam,
      min: ctx.min
    }, STEP_PREVIEW_LIMIT);
    if (seq !== STEP_PREVIEW_SEQ) return;
    if (hasRules) {
      setStepPreviewVisible('step-preview-options', true);
      renderStepPreview('step-preview-options', 'After Transform Rules', rulesStage, rulesStage.length, '');
    } else {
      setStepPreviewVisible('step-preview-options', false);
    }

    let current = rulesStage;
    const orderedItems = getMethodItemsOrdered();
    document.querySelectorAll('[id^="step-preview-method-"]').forEach((el) => { el.style.display = 'none'; });
    for (const item of orderedItems) {
      const id = item.id;
      if (isMutationFlowItem(item)) {
        current = generateMutationWordlist(current, {
          profile: item.profile || 'balanced',
          extraWords: parseMutationWords(item.words || '')
        }).slice(0, STEP_PREVIEW_LIMIT);
      } else {
        if (!item.method) continue;
        const tmpEngine = new CookEngine(['x'], {}, { methodsForAll: '', methodParam: '', appendParam: '', min: -1 });
        current = await tmpEngine.applyMethods(current, [item.method]);
      }
      if (seq !== STEP_PREVIEW_SEQ) return;
      const shown = current.slice(0, STEP_PREVIEW_LIMIT);
      const title = isMutationFlowItem(item)
        ? `After Mutation (${item.profile || 'balanced'})`
        : `After .${item.method}`;
      renderStepPreview(`step-preview-method-${id}`, title, shown, current.length, '');
    }
  } catch {
    renderStepPreview('step-preview-input', 'Input Expansion', ['Preview unavailable'], 1, '');
    renderStepPreview('step-preview-options', 'After Transform Rules', ['Preview unavailable'], 1, '');
  }
}

function onPatternChange() {
  const patternEl = document.getElementById('pattern');
  if (!patternEl) return;
  const rawValue = String(patternEl.value || '');
  if (!WORKFLOW_HISTORY.restoring && rawValue !== LAST_PATTERN_TEXT_FOR_UNDO) {
    const snap = captureWorkflowSnapshot();
    snap.patternText = LAST_PATTERN_TEXT_FOR_UNDO;
    pushWorkflowUndo(snap);
  }
  const text = patternEl.value.trim();
  const preview = document.getElementById('col-preview');
  if (!text) {
    preview.innerHTML = '';
    validateInputs();
    clearStepPreviews();
    syncMethodFlowFromInput(true);
    LAST_PATTERN_TEXT_FOR_UNDO = rawValue;
    return;
  }
  const cols = splitPatternColumns(text);
  let html = '';
  const MAX_COL_PREVIEW_TAGS = 6;
  const visibleCols = cols.slice(0, MAX_COL_PREVIEW_TAGS);
  visibleCols.forEach((col, i) => {
    if (i > 0) html += '<span class="col-sep">&times;</span>';
    const normalized = String(col || '')
      .replace(/`/g, '')
      .replace(/\s+/g, ' ')
      .trim();
    const display = normalized.length > 24 ? normalized.slice(0, 22) + '..' : normalized;
    const escaped = display.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    html += `<span class="col-tag"><span class="col-num">${i + 1}</span>${escaped}</span>`;
  });
  if (cols.length > MAX_COL_PREVIEW_TAGS) {
    html += '<span class="col-sep">&times;</span>';
    html += `<span class="col-tag col-more">+${(cols.length - MAX_COL_PREVIEW_TAGS).toLocaleString()} more</span>`;
  }
  preview.innerHTML = html;
  syncMethodFlowFromInput(true);
  validateInputs();
  scheduleStepPreviewUpdate(120);
  LAST_PATTERN_TEXT_FOR_UNDO = rawValue;
}

function autoWrapPatternPasteLiteral() {
  const patternEl = document.getElementById('pattern');
  if (!patternEl) return;
  const value = String(patternEl.value || '');
  const trimmed = value.trim();
  if (!trimmed) return;
  if (trimmed.startsWith('`') && trimmed.endsWith('`')) return;
  const hasNewlines = trimmed.includes('\n');
  const isSentenceLike = /\s/.test(trimmed) && !trimmed.includes(',');
  // Keep multiline paste as a real wordlist; only wrap single-line sentence-style input.
  if (hasNewlines || !isSentenceLike) return;
  patternEl.value = '`' + trimmed + '`';
}

function onPatternKey(e) {
  if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); startGenerate(); }
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
    // Let textarea keep native undo, then resync node graph from restored text.
    setTimeout(() => onPatternChange(), 0);
  }
}
function isTypingTarget(el) {
  if (!el) return false;
  const tag = (el.tagName || '').toLowerCase();
  return tag === 'input' || tag === 'textarea' || !!el.closest('[contenteditable="true"]');
}
document.addEventListener('keydown', (e) => {
  if (ONBOARDING_STATE.open && e.key === 'Escape') { e.preventDefault(); skipOnboarding(); return; }
  if (e.key === 'Enter' && (e.ctrlKey || e.metaKey) && !acState.input) { e.preventDefault(); startGenerate(); }
  if (e.key === 'Enter' && !e.ctrlKey && !e.metaKey && document.getElementById('method-modal')?.classList.contains('open')) {
    const tag = (document.activeElement && document.activeElement.tagName || '').toLowerCase();
    if (tag !== 'textarea') { e.preventDefault(); insertSelectedMethod(); }
  }
  if (e.key === 'Enter' && !e.ctrlKey && !e.metaKey && document.getElementById('examples-modal')?.classList.contains('open')) {
    const tag = (document.activeElement && document.activeElement.tagName || '').toLowerCase();
    if (tag !== 'textarea') { e.preventDefault(); insertSelectedExample(false); }
  }
  if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'z') {
    if (isTypingTarget(document.activeElement)) return;
    e.preventDefault();
    if (e.shiftKey) redoWorkflowAction();
    else undoWorkflowAction();
    return;
  }
  if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'd' && !isTypingTarget(document.activeElement)) {
    if (!METHOD_SELECTION.size) return;
    e.preventDefault();
    pushWorkflowUndo(captureWorkflowSnapshot());
    const selected = METHOD_FLOW_STATE.items.filter((i) => METHOD_SELECTION.has(i.id));
    METHOD_SELECTION.clear();
    selected.forEach((s) => {
      METHOD_FLOW_STATE.items.push({
        id: METHOD_FLOW_STATE.nextId++,
        type: s.type || (isMutationFlowItem(s) ? 'mutation' : 'method'),
        method: s.method,
        source: s.source || 'global',
        profile: isMutationFlowItem(s) ? (s.profile || 'balanced') : undefined,
        words: isMutationFlowItem(s) ? String(s.words || '') : undefined,
        x: (s.x || 0) + 24,
        y: getMethodLayoutRegion().startY
      });
      METHOD_SELECTION.add(METHOD_FLOW_STATE.items[METHOD_FLOW_STATE.items.length - 1].id);
    });
    layoutMethodNodes(true);
    renderMethodFlow();
    syncMethodFlowToInput();
    updateWorkflowConnectors();
    showToast(`Duplicated ${selected.length} method node${selected.length > 1 ? 's' : ''}`);
    return;
  }
  if ((e.key === 'Delete' || e.key === 'Backspace') && !isTypingTarget(document.activeElement)) {
    if (!METHOD_SELECTION.size) return;
    e.preventDefault();
    deleteSelectedMethodNodes();
    return;
  }
  if (e.key === 'Escape') { closeMethodModal(); closeExamplesModal(); closeDocsModal(); }
});

function loadExample(chip) {
  document.getElementById('pattern').value = chip.dataset.pattern;
  onPatternChange();
  const paramsContainer = document.getElementById('param-rows');
  paramsContainer.innerHTML = '';
  if (chip.dataset.params) {
    const params = JSON.parse(chip.dataset.params);
    for (const [name, val] of params) addParamRow(name, val);
  }
  startGenerate();
}

function addParamRow(name, val) {
  const container = document.getElementById('param-rows');
  const row = document.createElement('div');
  row.className = 'dyn-row';
  row.innerHTML = `<input type="text" placeholder="name" class="name-input param-name" value="${name || ''}" /><input type="text" placeholder="values (comma = multiple)" class="val-input param-value" value="${val || ''}" /><button class="icon-btn" onclick="this.parentElement.remove()" title="Remove">&times;</button>`;
  container.appendChild(row);
  row.querySelector('.param-name').addEventListener('input', () => { validateInputs(); scheduleStepPreviewUpdate(); });
  row.querySelector('.param-value').addEventListener('input', () => { validateInputs(); scheduleStepPreviewUpdate(); });
  if (!name) row.querySelector('.name-input').focus();
}

function addFileRow() {
  const container = document.getElementById('file-rows');
  const row = document.createElement('div');
  row.className = 'dyn-row';
  row.innerHTML = '<input type="text" placeholder="name" class="name-input file-name" /><input type="file" class="val-input file-input" style="padding:4px 6px;" /><button class="icon-btn" onclick="this.parentElement.remove()" title="Remove">&times;</button>';
  container.appendChild(row);
  row.querySelector('.file-name').addEventListener('input', () => { validateInputs(); scheduleStepPreviewUpdate(); });
  row.querySelector('.file-input').addEventListener('change', () => scheduleStepPreviewUpdate(120));
  row.querySelector('.name-input').focus();
}

function readFileInput(fileInput) {
  return new Promise((resolve) => {
    if (!fileInput.files || !fileInput.files[0]) { resolve([]); return; }
    const reader = new FileReader();
    reader.onload = (e) => resolve(e.target.result.split('\n').filter(l => l.length > 0));
    reader.readAsText(fileInput.files[0]);
  });
}

async function startGenerate() {
  const patternText = document.getElementById('pattern').value.trim();
  if (!patternText) return;
  validateInputs();
  const btnGen = document.getElementById('btn-generate');
  const btnCancel = document.getElementById('btn-cancel');
  const progress = document.getElementById('progress');
  const outputArea = document.getElementById('output-area');
  const emptyState = document.getElementById('empty-state');
  const stats = document.getElementById('stats');
  const metricLines = document.getElementById('metric-lines');
  const metricRuntime = document.getElementById('metric-runtime');
  const metricMode = document.getElementById('metric-mode');
  const outputCard = document.getElementById('output-wrapper').closest('.card');

  btnGen.disabled = true;
  btnCancel.style.display = '';
  progress.classList.add('active');
  outputArea.textContent = '';
  emptyState.style.display = 'none';
  outputArea.style.display = '';
  stats.textContent = '';
  if (metricLines) metricLines.textContent = '0';
  if (metricRuntime) metricRuntime.textContent = '0.00s';
  const mode = document.getElementById('opt-mode').value;
  if (metricMode) metricMode.textContent = getModeLabel(mode);
  fullResults = [];
  if (outputCard) outputCard.scrollIntoView({ behavior: 'smooth', block: 'start' });

  const pattern = splitPatternColumns(patternText);
  const params = {};
  for (const row of document.querySelectorAll('#param-rows .dyn-row')) {
    const name = row.querySelector('.param-name').value.trim();
    const val = row.querySelector('.param-value').value.trim();
    if (name) params[name] = val;
  }
  const fileParams = {};
  for (const row of document.querySelectorAll('#file-rows .dyn-row')) {
    const name = row.querySelector('.file-name').value.trim();
    const fileInput = row.querySelector('.file-input');
    if (name && fileInput.files && fileInput.files[0]) fileParams[name] = await readFileInput(fileInput);
  }
  const options = {
    methodsForAll: '',
    methodParam: document.getElementById('opt-colmethods').value.trim(),
    appendParam: document.getElementById('opt-append').value.trim(),
    min: parseInt(document.getElementById('opt-min').value, 10) || -1,
    mode
  };
  if (mode === 'append') {
    const cols = [];
    for (let i = 1; i < pattern.length; i++) cols.push(String(i));
    options.appendParam = cols.join(',');
  }
  const t0 = performance.now();
  try {
    const engine = new CookEngine(pattern, params, options);
    engine.fileParams = fileParams;
    window._currentEngine = engine;
    fullResults = await engine.generateAsync();
    const orderedNodes = getMethodItemsOrdered().filter((i) => i.source !== 'pattern');
    if (orderedNodes.length) {
      const tmpEngine = new CookEngine(['x'], {}, { methodsForAll: '', methodParam: '', appendParam: '', min: -1 });
      for (const node of orderedNodes) {
        if (isMutationFlowItem(node)) {
          fullResults = generateMutationWordlist(fullResults, {
            profile: node.profile || 'balanced',
            extraWords: parseMutationWords(node.words || '')
          });
        } else if (node.method) {
          fullResults = await tmpEngine.applyMethods(fullResults, [node.method]);
        }
      }
    }
    const elapsed = ((performance.now() - t0) / 1000).toFixed(2);
    stats.innerHTML = `<span class="count">${fullResults.length.toLocaleString()}</span> results &middot; ${elapsed}s`;
    if (metricLines) metricLines.textContent = fullResults.length.toLocaleString();
    if (metricRuntime) metricRuntime.textContent = `${elapsed}s`;
    if (fullResults.length === 0) {
      outputArea.textContent = '(no results)';
    } else if (fullResults.length > MAX_DISPLAY) {
      outputArea.textContent = fullResults.slice(0, MAX_DISPLAY).join('\n') + `\n\n... ${(fullResults.length - MAX_DISPLAY).toLocaleString()} more lines (use Open Full / Copy All / Download for complete output)`;
    } else {
      outputArea.textContent = fullResults.join('\n');
    }
  } catch (err) {
    outputArea.textContent = 'Error: ' + err.message;
    if (metricMode) metricMode.textContent = 'Error';
  }
  btnGen.disabled = false;
  btnCancel.style.display = 'none';
  progress.classList.remove('active');
  window._currentEngine = null;
}

function cancelGenerate() { if (window._currentEngine) window._currentEngine.cancelled = true; }

function splitPatternColumns(text) {
  const raw = String(text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  let sawNewline = false;
  let sawSpaceOrTab = false;
  let inRaw = false;
  for (const ch of raw) {
    if (ch === '`') { inRaw = !inRaw; continue; }
    if (inRaw) continue;
    if (ch === '\n') sawNewline = true;
    else if (ch === ' ' || ch === '\t') sawSpaceOrTab = true;
  }
  // Friendly default for pasted wordlists: newline-only input becomes one column with line values.
  if (sawNewline && !sawSpaceOrTab) {
    return [raw];
  }
  const cols = [];
  let current = '', inBacktick = false;
  for (const ch of raw) {
    if (ch === '`') { inBacktick = !inBacktick; current += ch; continue; }
    if (!inBacktick && (ch === ' ' || ch === '\t' || ch === '\n')) {
      if (current) { cols.push(current); current = ''; }
      continue;
    }
    current += ch;
  }
  if (current) cols.push(current);
  return cols;
}

function stripInlineMethodsFromToken(token) {
  const t = String(token || '');
  if (!t) return t;
  if (t.startsWith('`')) {
    let close = -1;
    let escaped = false;
    for (let i = 1; i < t.length; i++) {
      const ch = t[i];
      if (ch === '\\' && !escaped) { escaped = true; continue; }
      if (ch === '`' && !escaped) { close = i; break; }
      escaped = false;
    }
    if (close > 0) {
      const suffix = t.slice(close + 1).trim();
      if (suffix.startsWith('.')) return t.slice(0, close + 1);
    }
    return t;
  }
  if (/^[A-Za-z_][A-Za-z0-9_]*(\.[A-Za-z_][A-Za-z0-9_]*(\[[^\]]*\])?)+$/.test(t)) {
    const parts = CookParser.splitMethods(t);
    if (parts.length > 1) return parts[0];
  }
  return t;
}

function splitPatternColumnsForPreview(text) {
  return splitPatternColumns(text).map((tok) => stripInlineMethodsFromToken(tok));
}

function parseMethodCsv(csv) {
  return CookParser.splitValues(String(csv || ''))
    .map(s => s.trim())
    .filter(Boolean);
}

function getModeLabel(mode) {
  if (mode === 'append') return 'Line-by-line';
  return 'Cross-product';
}

function parseMutationWords(raw) {
  return String(raw || '')
    .split(/[\s,]+/)
    .map((s) => s.trim())
    .filter(Boolean)
    .slice(0, 64);
}

function ensureLegacyMutationNode(options, silent) {
  const opts = options || {};
  const want =
    opts.mode === 'mutation' ||
    !!opts.mutationNode ||
    (typeof opts.mutateProfile === 'string' || typeof opts.mutateWords === 'string');
  if (!want) return false;
  const profile = opts.mutationNode?.profile || opts.mutateProfile || 'balanced';
  const words = opts.mutationNode?.words || opts.mutateWords || '';
  const exists = METHOD_FLOW_STATE.items.some((i) => isMutationFlowItem(i));
  if (!exists) METHOD_FLOW_STATE.items.push(createMutationFlowItem(profile, words));
  else {
    const it = METHOD_FLOW_STATE.items.find((i) => isMutationFlowItem(i));
    if (it) {
      it.profile = profile === 'aggressive' ? 'aggressive' : 'balanced';
      it.words = String(words || '');
    }
  }
  if (!silent) showToast('Legacy mutation mode migrated to Mutation node');
  return true;
}

function titleCaseWord(value) {
  return String(value || '').replace(/\S+/g, (w) => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase());
}

function generateLeetVariants(base, aggressive) {
  const text = String(base || '');
  const variants = new Set([text]);
  const charSets = aggressive
    ? { a: ['4', '@'], e: ['3'], i: ['1', '!'], o: ['0'], s: ['5', '$'], t: ['7'], l: ['1'] }
    : { a: ['4'], e: ['3'], i: ['1'], o: ['0'], s: ['5'] };
  const lower = text.toLowerCase();
  for (let i = 0; i < lower.length; i++) {
    const ch = lower[i];
    if (!charSets[ch]) continue;
    for (const rep of charSets[ch]) {
      variants.add(text.slice(0, i) + rep + text.slice(i + 1));
    }
  }
  return [...variants];
}

function generateMutationWordlist(baseValues, opts = {}) {
  const profile = opts.profile === 'aggressive' ? 'aggressive' : 'balanced';
  const aggressive = profile === 'aggressive';
  const extras = Array.isArray(opts.extraWords) ? opts.extraWords.filter(Boolean).slice(0, 64) : [];
  const out = new Set();
  const maxBase = aggressive ? 1200 : 900;
  const maxPerBase = aggressive ? 220 : 120;
  const maxTotal = aggressive ? 100000 : 50000;
  const suffixNums = aggressive ? ['1','12','123','1234','007','01','99','2024','2025','2026'] : ['1','12','123','2025','2026'];
  const prefixes = aggressive ? ['dev','prod','qa','stage','test','beta'] : ['dev','test','prod'];
  const separators = ['','-','_','.'];

  const bases = Array.isArray(baseValues) ? baseValues.slice(0, maxBase) : [];
  for (const raw of bases) {
    if (out.size >= maxTotal) break;
    const v = String(raw || '').trim();
    if (!v) continue;
    const local = new Set();
    const cleaned = v.replace(/\s+/g, ' ');
    const compact = cleaned.replace(/[\s._-]+/g, '');
    const parts = cleaned.split(/[\s._-]+/).filter(Boolean);
    const lc = cleaned.toLowerCase();
    const uc = cleaned.toUpperCase();
    const tc = titleCaseWord(cleaned);
    local.add(cleaned);
    local.add(lc);
    local.add(uc);
    local.add(tc);
    if (compact && compact !== cleaned) local.add(compact);

    for (const n of suffixNums) {
      local.add(lc + n);
      local.add(uc + n);
      if (aggressive) local.add(n + lc);
    }

    if (parts.length > 1) {
      for (const sep of separators) local.add(parts.join(sep));
      if (aggressive) {
        const rev = [...parts].reverse();
        for (const sep of separators) local.add(rev.join(sep));
      }
    }

    for (const p of prefixes) {
      local.add(p + compact);
      local.add(p + '-' + compact);
      if (aggressive) local.add(compact + '-' + p);
    }

    const mixWords = [...new Set([...extras, ...prefixes])].slice(0, 24);
    for (const w of mixWords) {
      const word = String(w || '').trim().toLowerCase();
      if (!word) continue;
      for (const sep of separators) {
        local.add(lc + sep + word);
        local.add(word + sep + lc);
      }
    }

    for (const variant of generateLeetVariants(lc, aggressive)) local.add(variant);
    if (aggressive && compact.length >= 4) {
      for (let i = 0; i < Math.min(compact.length - 1, 8); i++) {
        const arr = compact.split('');
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
        local.add(arr.join(''));
      }
      for (let i = 1; i < Math.min(compact.length - 1, 8); i++) {
        local.add(compact.slice(0, i) + compact.slice(i + 1));
      }
    }

    let emitted = 0;
    for (const candidate of local) {
      if (!candidate || out.has(candidate)) continue;
      out.add(candidate);
      emitted++;
      if (emitted >= maxPerBase || out.size >= maxTotal) break;
    }
  }
  return [...out];
}

function getMethodLayoutRegion() {
  const stage = document.getElementById('workflow-stage');
  const patternEl = document.querySelector('.node-pattern');
  const optionsEl = document.querySelector('.node-options');
  if (!stage || !patternEl || !optionsEl) {
    return { startX: 20, startY: 220, availableW: Math.max(180, (stage?.clientWidth || 900) - 40), availableH: Math.max(140, (stage?.clientHeight || 560) - 240) };
  }
  const patternLeft = parseFloat(patternEl.style.left) || DEFAULT_WORKFLOW_LAYOUT.pattern.left;
  const patternTop = parseFloat(patternEl.style.top) || DEFAULT_WORKFLOW_LAYOUT.pattern.top;
  const patternW = patternEl.offsetWidth || 340;
  const patternH = patternEl.offsetHeight || 180;
  const optionsLeft = parseFloat(optionsEl.style.left) || DEFAULT_WORKFLOW_LAYOUT.options.left;
  const optionsTop = parseFloat(optionsEl.style.top) || DEFAULT_WORKFLOW_LAYOUT.options.top;
  const optionsW = optionsEl.offsetWidth || 320;
  const optionsH = optionsEl.offsetHeight || 220;
  const pad = 20;

  const rightStartX = optionsLeft + optionsW + 24;
  const rightAvailableW = stage.clientWidth - rightStartX - pad;
  const rightMinW = 180;
  if (rightAvailableW >= rightMinW) {
    const top = Math.min(patternTop, optionsTop) + 8;
    return {
      startX: rightStartX,
      startY: top,
      availableW: rightAvailableW,
      availableH: Math.max(140, stage.clientHeight - top - pad)
    };
  }

  const belowTop = Math.max(patternTop + patternH, optionsTop + optionsH) + 22;
  return {
    startX: pad,
    startY: belowTop,
    availableW: Math.max(180, stage.clientWidth - pad * 2),
    availableH: Math.max(140, stage.clientHeight - belowTop - pad)
  };
}

function captureWorkflowSnapshot() {
  const pattern = document.querySelector('.node-pattern');
  const options = document.querySelector('.node-options');
  const patternInput = document.getElementById('pattern');
  const methodsInput = document.getElementById('opt-methods');
  const colMethodsInput = document.getElementById('opt-colmethods');
  const modeInput = document.getElementById('opt-mode');
  const appendInput = document.getElementById('opt-append');
  const minInput = document.getElementById('opt-min');
  return {
    items: METHOD_FLOW_STATE.items.map((i) => ({ ...i })),
    nextId: METHOD_FLOW_STATE.nextId,
    selected: [...METHOD_SELECTION],
    patternText: patternInput ? patternInput.value : '',
    globalMethodsText: methodsInput ? methodsInput.value : '',
    colMethodsText: colMethodsInput ? colMethodsInput.value : '',
    modeValue: modeInput ? modeInput.value : 'permutation',
    appendValue: appendInput ? appendInput.value : '',
    minValue: minInput ? minInput.value : '',
    pattern: pattern ? { left: parseFloat(pattern.style.left) || DEFAULT_WORKFLOW_LAYOUT.pattern.left, top: parseFloat(pattern.style.top) || DEFAULT_WORKFLOW_LAYOUT.pattern.top } : DEFAULT_WORKFLOW_LAYOUT.pattern,
    options: options ? { left: parseFloat(options.style.left) || DEFAULT_WORKFLOW_LAYOUT.options.left, top: parseFloat(options.style.top) || DEFAULT_WORKFLOW_LAYOUT.options.top } : DEFAULT_WORKFLOW_LAYOUT.options,
    scale: WORKFLOW_VIEW.scale
  };
}

function pushWorkflowUndo(snapshot) {
  if (WORKFLOW_HISTORY.restoring) return;
  WORKFLOW_HISTORY.undo.push(snapshot || captureWorkflowSnapshot());
  if (WORKFLOW_HISTORY.undo.length > WORKFLOW_HISTORY.max) WORKFLOW_HISTORY.undo.shift();
  WORKFLOW_HISTORY.redo = [];
}

function applyWorkflowSnapshot(snapshot) {
  if (!snapshot) return;
  WORKFLOW_HISTORY.restoring = true;
  const patternInput = document.getElementById('pattern');
  const methodsInput = document.getElementById('opt-methods');
  const colMethodsInput = document.getElementById('opt-colmethods');
  const modeInput = document.getElementById('opt-mode');
  const appendInput = document.getElementById('opt-append');
  const minInput = document.getElementById('opt-min');
  if (patternInput && typeof snapshot.patternText === 'string') patternInput.value = snapshot.patternText;
  if (methodsInput && typeof snapshot.globalMethodsText === 'string') methodsInput.value = snapshot.globalMethodsText;
  if (colMethodsInput && typeof snapshot.colMethodsText === 'string') colMethodsInput.value = snapshot.colMethodsText;
  if (modeInput && typeof snapshot.modeValue === 'string') {
    const mv = snapshot.modeValue === 'append' ? 'append' : 'permutation';
    modeInput.value = mv;
  }
  if (appendInput && typeof snapshot.appendValue === 'string') appendInput.value = snapshot.appendValue;
  if (minInput && typeof snapshot.minValue === 'string') minInput.value = snapshot.minValue;
  updateModeUI();
  onPatternChange();
  METHOD_FLOW_STATE.items = (snapshot.items || []).map((i) => ({ ...i }));
  METHOD_FLOW_STATE.nextId = Number.isFinite(snapshot.nextId) ? snapshot.nextId : (METHOD_FLOW_STATE.items.length + 1);
  METHOD_SELECTION.clear();
  for (const id of (snapshot.selected || [])) METHOD_SELECTION.add(id);
  applyWorkflowLayout({ pattern: snapshot.pattern || DEFAULT_WORKFLOW_LAYOUT.pattern, options: snapshot.options || DEFAULT_WORKFLOW_LAYOUT.options });
  WORKFLOW_VIEW.scale = Number.isFinite(snapshot.scale) ? snapshot.scale : DEFAULT_WORKFLOW_SCALE;
  applyWorkflowScale();
  renderMethodFlow();
  syncMethodFlowToInput();
  updateWorkflowConnectors();
  WORKFLOW_HISTORY.restoring = false;
}

function undoWorkflowAction() {
  if (!WORKFLOW_HISTORY.undo.length) return;
  const prev = WORKFLOW_HISTORY.undo.pop();
  WORKFLOW_HISTORY.redo.push(captureWorkflowSnapshot());
  applyWorkflowSnapshot(prev);
  showToast('Undo');
}

function redoWorkflowAction() {
  if (!WORKFLOW_HISTORY.redo.length) return;
  const next = WORKFLOW_HISTORY.redo.pop();
  WORKFLOW_HISTORY.undo.push(captureWorkflowSnapshot());
  applyWorkflowSnapshot(next);
  showToast('Redo');
}

function deleteSelectedMethodNodes() {
  const ids = [...METHOD_SELECTION];
  if (!ids.length) return;
  pushWorkflowUndo(captureWorkflowSnapshot());
  METHOD_FLOW_STATE.items = METHOD_FLOW_STATE.items.filter((i) => !METHOD_SELECTION.has(i.id));
  METHOD_SELECTION.clear();
  layoutMethodNodes(true);
  renderMethodFlow();
  syncMethodFlowToInput();
  updateWorkflowConnectors();
  showToast(`Deleted ${ids.length} selected node${ids.length > 1 ? 's' : ''}`);
}

function syncMethodFlowToInput() {
  const input = document.getElementById('opt-methods');
  if (!input) return;
  const ordered = getMethodItemsOrdered();
  input.value = ordered.filter(i => i.source !== 'pattern' && !isMutationFlowItem(i)).map(i => i.method).join(',');
  const patternMethods = extractPatternMethodsFromText(document.getElementById('pattern')?.value || '');
  METHOD_FLOW_LAST_SYNC = input.value + '\n||\n' + patternMethods.join(',');
  validateInputs();
}

function syncMethodFlowFromInput(skipUndo) {
  const raw = document.getElementById('opt-methods')?.value || '';
  const patternEntries = extractPatternMethodEntriesFromText(document.getElementById('pattern')?.value || '');
  const patternMethods = patternEntries.map((e) => e.method);
  const syncKey = raw + '\n||\n' + patternMethods.join(',');
  if (syncKey === METHOD_FLOW_LAST_SYNC && !WORKFLOW_HISTORY.restoring) {
    // Keep visual direction canonical (left->right by execution order) even when chain text did not change.
    layoutMethodNodes(false);
    renderMethodFlow();
    updateWorkflowConnectors();
    return;
  }
  if (!skipUndo && !WORKFLOW_HISTORY.restoring) pushWorkflowUndo(captureWorkflowSnapshot());
  const preservedMutation = METHOD_FLOW_STATE.items
    .filter((i) => isMutationFlowItem(i))
    .map((i) => ({ ...i }));
  const methods = parseMethodCsv(raw);
  METHOD_FLOW_STATE.items = preservedMutation;
  methods.forEach((m) => {
    METHOD_FLOW_STATE.items.push({
      id: METHOD_FLOW_STATE.nextId++,
      type: 'method',
      method: m,
      source: 'global',
      x: 0,
      y: 0
    });
  });
  patternEntries.forEach((entry) => {
    METHOD_FLOW_STATE.items.push({
      id: METHOD_FLOW_STATE.nextId++,
      type: 'method',
      method: entry.method,
      source: 'pattern',
      patternTokenIndex: entry.tokenIndex,
      patternMethodIndex: entry.methodIndex,
      x: 0,
      y: 0
    });
  });
  METHOD_SELECTION.clear();
  const maxId = METHOD_FLOW_STATE.items.reduce((m, it) => Math.max(m, Number(it.id) || 0), 0);
  METHOD_FLOW_STATE.nextId = Math.max(METHOD_FLOW_STATE.nextId, maxId + 1);
  layoutMethodNodes(false);
  renderMethodFlow();
  updateWorkflowConnectors();
  METHOD_FLOW_LAST_SYNC = syncKey;
}

function layoutMethodNodes(orderByCurrent) {
  if (!METHOD_FLOW_STATE.items.length) return;
  const stage = document.getElementById('workflow-stage');
  if (!stage) return;
  const count = METHOD_FLOW_STATE.items.length;
  const region = getMethodLayoutRegion();
  const startX = region.startX;
  const startY = region.startY;
  const availableW = Math.max(180, region.availableW);
  const availableH = Math.max(120, region.availableH);
  const minW = 148;
  const maxW = 220;
  const gap = METHOD_NODE_UI.gap;
  let maxCols = Math.max(1, Math.floor((availableW + gap) / (minW + gap)));
  maxCols = Math.min(Math.max(1, count), maxCols);
  let selected = null;
  for (let cols = maxCols; cols >= 1; cols--) {
    const w = Math.min(maxW, Math.floor((availableW - gap * (cols - 1)) / cols));
    if (w < minW) continue;
    const rows = Math.ceil(count / cols);
    const rowH = w < 176 ? 116 : 132;
    const neededH = rows * rowH + Math.max(0, rows - 1) * 22;
    if (neededH <= availableH) {
      selected = { cols, w, rowH };
      break;
    }
  }
  if (!selected) {
    const cols = maxCols;
    const w = Math.max(132, Math.min(maxW, Math.floor((availableW - gap * (cols - 1)) / cols)));
    const rowH = w < 176 ? 112 : 126;
    selected = { cols, w, rowH };
  }
  METHOD_NODE_UI.width = selected.w;
  METHOD_NODE_UI.rowHeight = selected.rowH;
  METHOD_NODE_UI.compact = selected.w < 188;
  const slotW = METHOD_NODE_UI.width + gap;
  const slotH = METHOD_NODE_UI.rowHeight + 18;

  const items = [...METHOD_FLOW_STATE.items];
  if (orderByCurrent) {
    items.sort((a, b) => (a.y - b.y) || (a.x - b.x) || (a.id - b.id));
  } else {
    const pattern = document.getElementById('pattern')?.value || '';
    const patternChain = extractPatternMethodsFromText(pattern);
    const rankMap = buildPatternMethodRankMap(items, patternChain);
    items.sort((a, b) => {
      const ra = a.source === 'pattern' ? (rankMap.get(a.id) ?? (Number.MAX_SAFE_INTEGER - 1)) : Number.MAX_SAFE_INTEGER;
      const rb = b.source === 'pattern' ? (rankMap.get(b.id) ?? (Number.MAX_SAFE_INTEGER - 1)) : Number.MAX_SAFE_INTEGER;
      if (ra !== rb) return ra - rb;
      if (a.source !== b.source) return a.source === 'pattern' ? -1 : 1;
      return a.id - b.id;
    });
  }
  items.forEach((item, i) => {
    const col = i % selected.cols;
    const row = Math.floor(i / selected.cols);
    item.x = startX + col * slotW;
    item.y = startY + row * slotH;
  });
  METHOD_FLOW_STATE.items = items;
}

function _rectsOverlap(a, b, gap) {
  const g = Number.isFinite(gap) ? gap : 8;
  return !(a.right + g <= b.left || a.left >= b.right + g || a.bottom + g <= b.top || a.top >= b.bottom + g);
}

function resolveMethodNodeCollision(id, left, top, width, height) {
  const stage = document.getElementById('workflow-stage');
  if (!stage) return { left, top };
  const pad = 6;
  const maxLeft = Math.max(pad, stage.clientWidth - width - pad);
  const maxTop = Math.max(pad, stage.clientHeight - height - pad);
  let x = Math.max(pad, Math.min(maxLeft, left));
  let y = Math.max(pad, Math.min(maxTop, top));
  const others = METHOD_FLOW_STATE.items
    .filter((n) => n.id !== id)
    .map((n) => ({
      left: n.x,
      top: n.y,
      right: n.x + width,
      bottom: n.y + height
    }));
  const coreNodes = [...stage.querySelectorAll('.node-pattern, .node-options, .node-output')].map((n) => {
    const l = parseFloat(n.style.left) || 0;
    const t = parseFloat(n.style.top) || 0;
    const w = n.offsetWidth || 0;
    const h = n.offsetHeight || 0;
    return { left: l, top: t, right: l + w, bottom: t + h };
  });
  const step = 14;
  for (let i = 0; i < 280; i++) {
    const rect = { left: x, top: y, right: x + width, bottom: y + height };
    const hitMethods = others.some((r) => _rectsOverlap(rect, r, 10));
    const hitCore = coreNodes.some((r) => _rectsOverlap(rect, r, 6));
    const hit = hitMethods || hitCore;
    if (!hit) return { left: x, top: y };
    x += step;
    if (x > maxLeft) {
      x = pad;
      y += step;
      if (y > maxTop) y = pad;
    }
  }
  return { left: x, top: y };
}

function renderMethodPalette() {
  const palette = document.getElementById('method-palette');
  if (!palette) return;
  palette.innerHTML = METHOD_FLOW_PALETTE.map((m) => {
    const base = m.split('[')[0];
    const meta = METHOD_CATALOG.find(x => x.insert === m || x.name === base);
    return `<div class="method-pill" draggable="true" data-method="${escapeHtml(m)}"><span class="m-name">.${escapeHtml(m)}</span><span class="m-desc">${escapeHtml(meta?.desc || 'Transform')}</span></div>`;
  }).join('');

  palette.querySelectorAll('.method-pill').forEach((el) => {
    el.addEventListener('dragstart', (e) => {
      METHOD_FLOW_STATE.sourceMethod = el.dataset.method || '';
      e.dataTransfer.effectAllowed = 'copy';
      e.dataTransfer.setData('text/plain', METHOD_FLOW_STATE.sourceMethod);
    });
    el.addEventListener('click', () => addMethodNode(el.dataset.method || 'upper'));
  });
}

function addMethodNode(method, x, y, source) {
  if (!method) return;
  pushWorkflowUndo(captureWorkflowSnapshot());
  METHOD_FLOW_STATE.items.push({
    id: METHOD_FLOW_STATE.nextId++,
    type: 'method',
    method,
    source: source === 'pattern' ? 'pattern' : 'global',
    x: Number.isFinite(x) ? x : (100000 + METHOD_FLOW_STATE.items.length),
    y: Number.isFinite(y) ? y : 0
  });
  METHOD_SELECTION.clear();
  // Additions should follow canonical chain direction, not stale x/y ordering.
  layoutMethodNodes(false);
  renderMethodFlow();
  syncMethodFlowToInput();
  updateWorkflowConnectors();
}

function addMutationNode(profile, words, x, y) {
  pushWorkflowUndo(captureWorkflowSnapshot());
  METHOD_FLOW_STATE.items.push(createMutationFlowItem(profile, words, x, y));
  METHOD_SELECTION.clear();
  layoutMethodNodes(false);
  renderMethodFlow();
  syncMethodFlowToInput();
  updateWorkflowConnectors();
  showToast('Mutation node added');
}

function removeFlowMethod(id) {
  pushWorkflowUndo(captureWorkflowSnapshot());
  METHOD_FLOW_STATE.items = METHOD_FLOW_STATE.items.filter(i => i.id !== id);
  METHOD_SELECTION.delete(id);
  layoutMethodNodes(true);
  renderMethodFlow();
  syncMethodFlowToInput();
  updateWorkflowConnectors();
}

function clearMethodFlow() {
  if (!METHOD_FLOW_STATE.items.length) return;
  pushWorkflowUndo(captureWorkflowSnapshot());
  METHOD_FLOW_STATE.items = [];
  METHOD_SELECTION.clear();
  renderMethodFlow();
  syncMethodFlowToInput();
  updateWorkflowConnectors();
}

function renderMethodFlow() {
  const layer = document.getElementById('method-node-layer');
  if (!layer) return;
  const orderedItems = getMethodItemsOrdered();
  layer.innerHTML = orderedItems.map((item, idx) => {
    const isMutation = isMutationFlowItem(item);
    const meta = isMutation ? null : METHOD_CATALOG.find(m => item.method.startsWith(m.name));
    const isPattern = item.source === 'pattern';
    const kind = isMutation
      ? 'Workflow mutation step'
      : (isPattern ? 'Inline method in pattern' : 'Global workflow method');
    const dotClass = isPattern ? 'pattern' : 'global';
    const selectedClass = METHOD_SELECTION.has(item.id) ? ' selected' : '';
    const compactClass = METHOD_NODE_UI.compact ? ' compact' : '';
    const mutationProfile = item.profile === 'aggressive' ? 'aggressive' : 'balanced';
    const mutationWords = String(item.words || '');
    return `<section class="card flow-node method-node${isMutation ? ' mutation-node' : ''}${selectedClass}${compactClass}" data-id="${item.id}" style="left:${item.x}px;top:${item.y}px;width:${METHOD_NODE_UI.width}px;" tabindex="0">
      <span class="node-port in" aria-hidden="true"></span>
      <span class="node-port out" aria-hidden="true"></span>
      <div class="node-head"><span class="node-title"><span class="node-handle">⋮⋮</span>${isMutation ? 'Mutation' : 'Method'}</span><span class="node-id">M${idx + 1}</span><span>${isMutation ? '' : `<button class="method-edit" type="button" data-edit-btn="${item.id}" title="Edit method">✎</button>`}<button class="method-remove" type="button" data-rm="${item.id}">&times;</button></span></div>
      <div class="card-body">
        ${isMutation
          ? `<div class="method-pill-preview">Mutation Generator</div>
             <div class="method-edit-inline">
               <select class="method-edit-input" data-mut-prof="${item.id}">
                 <option value="balanced"${mutationProfile === 'balanced' ? ' selected' : ''}>Balanced</option>
                 <option value="aggressive"${mutationProfile === 'aggressive' ? ' selected' : ''}>Aggressive</option>
               </select>
             </div>
             <div class="method-edit-inline">
               <input type="text" class="method-edit-input" data-mut-words="${item.id}" value="${escapeHtml(mutationWords)}" placeholder="Extra words: corp,secure" />
             </div>`
          : `<div class="method-pill-preview" data-edit-method="${item.id}" title="Double-click to edit this method">.${escapeHtml(item.method)}</div>
             ${METHOD_EDIT_STATE.id === item.id
               ? `<div class="method-edit-inline">
                   <input type="text" class="method-edit-input" data-edit-input="${item.id}" value="${escapeHtml(METHOD_EDIT_STATE.draft || item.method)}" />
                   <button type="button" class="method-edit-save" data-edit-save="${item.id}">Save</button>
                   <button type="button" class="method-edit-cancel" data-edit-cancel="${item.id}">Cancel</button>
                 </div>`
               : ''
             }`
        }
        <div class="method-mini">${escapeHtml(isMutation ? 'Generate mutation variants from current lines' : (meta?.desc || 'Transformation step'))} · <span class="source-dot ${dotClass}"></span>${escapeHtml(kind)}</div>
      </div>
      <div id="step-preview-method-${item.id}" class="node-step-preview"></div>
    </section>`;
  }).join('');
  layer.querySelectorAll('.method-remove').forEach((btn) => {
    btn.addEventListener('click', () => removeFlowMethod(parseInt(btn.dataset.rm || '-1', 10)));
  });
  layer.querySelectorAll('[data-edit-btn]').forEach((btn) => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const id = parseInt(btn.getAttribute('data-edit-btn') || '-1', 10);
      if (id >= 0) startInlineEditFlowMethod(id);
    });
  });
  layer.querySelectorAll('[data-edit-method]').forEach((el) => {
    el.addEventListener('dblclick', (e) => {
      e.stopPropagation();
      const id = parseInt(el.getAttribute('data-edit-method') || '-1', 10);
      if (id >= 0) startInlineEditFlowMethod(id);
    });
  });
  layer.querySelectorAll('[data-edit-save]').forEach((btn) => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const id = parseInt(btn.getAttribute('data-edit-save') || '-1', 10);
      if (id >= 0) commitInlineEditFlowMethod(id);
    });
  });
  layer.querySelectorAll('[data-edit-cancel]').forEach((btn) => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      cancelInlineEditFlowMethod();
    });
  });
  layer.querySelectorAll('[data-edit-input]').forEach((inputEl) => {
    inputEl.addEventListener('keydown', (e) => {
      const id = parseInt(inputEl.getAttribute('data-edit-input') || '-1', 10);
      if (e.key === 'Enter') {
        e.preventDefault();
        if (id >= 0) commitInlineEditFlowMethod(id);
      } else if (e.key === 'Escape') {
        e.preventDefault();
        cancelInlineEditFlowMethod();
      }
    });
    inputEl.addEventListener('input', () => {
      METHOD_EDIT_STATE.draft = inputEl.value;
    });
  });
  layer.querySelectorAll('[data-mut-prof]').forEach((selectEl) => {
    selectEl.addEventListener('change', () => {
      const id = parseInt(selectEl.getAttribute('data-mut-prof') || '-1', 10);
      const item = METHOD_FLOW_STATE.items.find((m) => m.id === id);
      if (!item || !isMutationFlowItem(item)) return;
      item.profile = (selectEl.value === 'aggressive') ? 'aggressive' : 'balanced';
      scheduleStepPreviewUpdate(100);
    });
  });
  layer.querySelectorAll('[data-mut-words]').forEach((inputEl) => {
    inputEl.addEventListener('input', () => {
      const id = parseInt(inputEl.getAttribute('data-mut-words') || '-1', 10);
      const item = METHOD_FLOW_STATE.items.find((m) => m.id === id);
      if (!item || !isMutationFlowItem(item)) return;
      item.words = inputEl.value;
      scheduleStepPreviewUpdate(120);
    });
  });
  if (METHOD_EDIT_STATE.id !== null) {
    const editInput = layer.querySelector(`[data-edit-input="${METHOD_EDIT_STATE.id}"]`);
    if (editInput) {
      setTimeout(() => {
        editInput.focus();
        editInput.select();
      }, 0);
    }
  }
  scheduleWorkflowFit(false);
  scheduleStepPreviewUpdate(80);
}

function startInlineEditFlowMethod(id) {
  const item = METHOD_FLOW_STATE.items.find((m) => m.id === id);
  if (!item) return;
  METHOD_EDIT_STATE.id = id;
  METHOD_EDIT_STATE.draft = String(item.method || '');
  renderMethodFlow();
}

function cancelInlineEditFlowMethod() {
  METHOD_EDIT_STATE.id = null;
  METHOD_EDIT_STATE.draft = '';
  renderMethodFlow();
}

function updatePatternMethodAt(patternText, tokenIndex, methodIndex, nextMethod) {
  const tokens = getPatternTokensWithRanges(patternText);
  const tok = tokens[tokenIndex];
  if (!tok) return null;
  const token = tok.token;
  let rebuilt = token;
  if (token.startsWith('`')) {
    let close = -1;
    let escaped = false;
    for (let i = 1; i < token.length; i++) {
      const ch = token[i];
      if (ch === '\\' && !escaped) { escaped = true; continue; }
      if (ch === '`' && !escaped) { close = i; break; }
      escaped = false;
    }
    if (close <= 0) return null;
    const rawPart = token.slice(0, close + 1);
    const suffix = token.slice(close + 1);
    const parts = suffix.startsWith('.') ? CookParser.splitMethods('x' + suffix).slice(1) : [];
    if (!parts.length || methodIndex < 0 || methodIndex >= parts.length) return null;
    parts[methodIndex] = nextMethod;
    rebuilt = rawPart + '.' + parts.join('.');
  } else {
    const parts = CookParser.splitMethods(token);
    if (parts.length <= 1) return null;
    const methods = parts.slice(1);
    if (methodIndex < 0 || methodIndex >= methods.length) return null;
    methods[methodIndex] = nextMethod;
    rebuilt = parts[0] + '.' + methods.join('.');
  }
  return String(patternText).slice(0, tok.start) + rebuilt + String(patternText).slice(tok.end);
}

function commitInlineEditFlowMethod(id) {
  const item = METHOD_FLOW_STATE.items.find((m) => m.id === id);
  if (!item) return;
  const next = String(METHOD_EDIT_STATE.draft || '').trim().replace(/^\.+/, '');
  if (!next) {
    showToast('Method cannot be empty');
    return;
  }
  if (next === String(item.method || '')) {
    cancelInlineEditFlowMethod();
    return;
  }
  pushWorkflowUndo(captureWorkflowSnapshot());
  if (item.source === 'pattern') {
    const patternInput = document.getElementById('pattern');
    const currentPattern = patternInput ? patternInput.value : '';
    const updated = updatePatternMethodAt(currentPattern, item.patternTokenIndex, item.patternMethodIndex, next);
    if (!patternInput || updated === null) {
      showToast('Could not map pattern method for edit');
      return;
    }
    patternInput.value = updated;
    METHOD_EDIT_STATE.id = null;
    METHOD_EDIT_STATE.draft = '';
    onPatternChange();
    showToast(`Updated inline method to .${next}`);
    return;
  }
  item.method = next;
  METHOD_EDIT_STATE.id = null;
  METHOD_EDIT_STATE.draft = '';
  renderMethodFlow();
  syncMethodFlowToInput();
  updateWorkflowConnectors();
  scheduleStepPreviewUpdate(80);
  showToast(`Updated method to .${next}`);
}

function initMethodFlowBuilder() {
  renderMethodPalette();
  syncMethodFlowFromInput();
  const canvas = document.querySelector('.workflow-canvas');
  if (!canvas) return;
  canvas.addEventListener('dragover', (e) => { if (METHOD_FLOW_STATE.sourceMethod) e.preventDefault(); });
  canvas.addEventListener('drop', (e) => {
    if (!METHOD_FLOW_STATE.sourceMethod) return;
    e.preventDefault();
    addMethodNode(METHOD_FLOW_STATE.sourceMethod);
    METHOD_FLOW_STATE.sourceMethod = '';
  });
}

function initToolboxSearch() {
  const input = document.querySelector('.toolbox-search');
  if (!input) return;
  const methodBtn = document.getElementById('tool-open-methods');
  const learnBtn = document.getElementById('tool-open-learn');
  const mutationBtn = document.getElementById('tool-add-mutation-node');
  document.querySelectorAll('.tool-action-btn,.tool-note,.tool-cat').forEach((el) => { el.style.display = ''; });
  if (methodBtn) {
    const methodParts = [];
    for (const m of METHOD_CATALOG) {
      methodParts.push(m.name || '', m.insert || '', m.desc || '');
      for (const a of (m.aliases || [])) methodParts.push(a || '');
    }
    const methodTokens = methodParts.join(' ').toLowerCase();
    methodBtn.dataset.search = `methods transform hash encode regex web string ${methodTokens}`;
  }
  if (learnBtn) {
    const exParts = [];
    for (let i = 0; i < EXAMPLE_LIBRARY.length; i++) {
      const e = EXAMPLE_LIBRARY[i];
      exParts.push(e.name || '', e.pattern || '', e.output || '');
      for (const t of (e.tags || [])) exParts.push(t || '');
    }
    for (let i = 0; i < RECIPE_LIBRARY.length; i++) {
      const r = RECIPE_LIBRARY[i];
      exParts.push(r.name || '', r.summary || '', r.pattern || '', r.output || '', r.category || '', r.options?.methods || '');
    }
    const exTokens = exParts.join(' ').toLowerCase();
    learnBtn.dataset.search = `learn receipes recipes examples tutorials workflow templates docs syntax faq ${exTokens}`;
  }
  if (mutationBtn) {
    mutationBtn.dataset.search = 'mutation mutate wordlist variants balanced aggressive extra words generator node';
  }
  function openMethodsWithQuery(q) {
    const query = String(q || '').trim();
    if (!query) return;
    const modal = document.getElementById('method-modal');
    if (modal && modal.classList.contains('open')) {
      const methodSearch = document.getElementById('method-search-input');
      if (methodSearch) {
        methodSearch.value = query;
        filterMethods(query);
        methodSearch.focus();
        methodSearch.select();
      }
      return;
    }
    openMethodsFromSidebar(query);
    input.blur();
  }
  function openLearnWithQuery(q) { openLearnFromSidebar(q); }

  function scheduleOpen(query) {
    if (ONBOARDING_STATE.open) return;
    if (TOOLBOX_SEARCH_OPEN_TIMER) window.clearTimeout(TOOLBOX_SEARCH_OPEN_TIMER);
    TOOLBOX_SEARCH_OPEN_TIMER = window.setTimeout(() => {
      if (ONBOARDING_STATE.open) return;
      openLearnWithQuery(query);
    }, 180);
  }

  input.addEventListener('input', () => {
    const q = input.value.trim();
    if (!q) {
      if (TOOLBOX_SEARCH_OPEN_TIMER) window.clearTimeout(TOOLBOX_SEARCH_OPEN_TIMER);
      TOOLBOX_SEARCH_OPEN_TIMER = 0;
      return;
    }
    scheduleOpen(q);
  });
  input.addEventListener('focus', () => {
    const q = input.value.trim();
    if (!q) return;
    scheduleOpen(q);
  });
  input.addEventListener('keydown', (e) => {
    if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'a') return;
    if (e.key === 'Escape') { input.value = ''; return; }
    if (e.key !== 'Enter') return;
    const q = input.value.trim();
    if (!q) return;
    const query = q.toLowerCase();
    const methodsHay = (methodBtn?.dataset.search || '');
    const learnHay = (learnBtn?.dataset.search || '');
    const mutationHay = (mutationBtn?.dataset.search || '');
    if (mutationHay.includes(query)) {
      addMutationNode('balanced', '');
      input.value = '';
      return;
    }
    if (learnHay.includes(query)) {
      openLearnWithQuery(q);
      return;
    }
    if (methodsHay.includes(query)) {
      openLearnWithQuery(q);
      return;
    }
    openLearnWithQuery(q);
  });
}

function getFavoriteMethods() {
  try {
    const raw = localStorage.getItem(FAVORITE_METHODS_KEY);
    const arr = JSON.parse(raw || '[]');
    return new Set(Array.isArray(arr) ? arr : []);
  } catch { return new Set(); }
}

function setFavoriteMethods(set) {
  localStorage.setItem(FAVORITE_METHODS_KEY, JSON.stringify([...set]));
}

function getSidebarSearchInput() {
  return document.querySelector('.toolbox-search');
}

function clearSidebarSearch() {
  if (TOOLBOX_SEARCH_OPEN_TIMER) {
    window.clearTimeout(TOOLBOX_SEARCH_OPEN_TIMER);
    TOOLBOX_SEARCH_OPEN_TIMER = 0;
  }
  const input = getSidebarSearchInput();
  if (input) {
    input.value = '';
    input.dispatchEvent(new Event('input', { bubbles: true }));
    input.blur();
  }
}

function safeOpenMethodsSidebar(seedQuery) {
  const q = String(seedQuery || '').trim();
  if (typeof openMethodModal === 'function') {
    openMethodModal({ query: q, focus: true });
    const methodSearch = document.getElementById('method-search-input');
    if (methodSearch) {
      methodSearch.value = q;
      if (typeof filterMethods === 'function') filterMethods(q);
    }
  }
  clearSidebarSearch();
}

function safeOpenLearnSidebar(seedQuery) {
  const q = String(seedQuery || '').trim();
  DOCS_STATE.recipeQuery = q;
  DOCS_STATE.syntaxQuery = q;
  if (typeof openDocsModal === 'function') openDocsModal('recipes');
  const search = document.getElementById('docs-recipe-search');
  if (search) {
    search.value = q;
    filterDocsRecipes(q);
  }
  const syntaxSearch = document.getElementById('docs-syntax-search');
  if (syntaxSearch) {
    syntaxSearch.value = q;
    filterDocsSyntax(q);
  }
  if (!q) clearSidebarSearch();
}

function openMethodsFromSidebar(seedQuery) {
  const q = String(seedQuery || '').trim();
  METHOD_MODAL_STATE.category = 'all';
  openMethodModal({ query: q, focus: true });
  const methodSearch = document.getElementById('method-search-input');
  if (methodSearch) {
    methodSearch.value = q;
    filterMethods(q);
  }
  clearSidebarSearch();
}

function openExamplesFromSidebar(seedQuery) {
  return safeOpenLearnSidebar(seedQuery);
}

function openLearnFromSidebar(seedQuery) {
  return safeOpenLearnSidebar(seedQuery);
}

// Resilient global wrappers for inline handlers and cached/stale DOM callbacks.
window.openMethodsFromSidebar = function openMethodsFromSidebarGlobal(seedQuery) {
  return safeOpenMethodsSidebar(seedQuery);
};
window.openExamplesFromSidebar = function openExamplesFromSidebarGlobal(seedQuery) {
  return safeOpenLearnSidebar(seedQuery);
};
window.openLearnFromSidebar = function openLearnFromSidebarGlobal(seedQuery) {
  return safeOpenLearnSidebar(seedQuery);
};

function bindPrimaryActionButtons() {
  const methodsBtn = document.getElementById('tool-open-methods');
  const learnBtn = document.getElementById('tool-open-learn');
  const mutationBtn = document.getElementById('tool-add-mutation-node');
  const clearBtn = document.getElementById('tool-clear-all');
  const hdrLearn = document.querySelector('.studio-actions .hdr-text-btn[title=\"Receipes, workflows, and syntax\"]');
  const hdrMethods = document.querySelector('.studio-actions .hdr-text-btn[title=\"Method reference\"]');

  if (methodsBtn) {
    methodsBtn.removeAttribute('onclick');
    methodsBtn.onclick = () => safeOpenMethodsSidebar();
  }
  if (learnBtn) {
    learnBtn.removeAttribute('onclick');
    learnBtn.onclick = () => safeOpenLearnSidebar();
  }
  if (mutationBtn) {
    mutationBtn.removeAttribute('onclick');
    mutationBtn.onclick = () => addMutationNode('balanced', '');
  }
  if (clearBtn) {
    clearBtn.removeAttribute('onclick');
    clearBtn.onclick = () => clearAllAndSidebarSearch();
  }
  if (hdrLearn) {
    hdrLearn.removeAttribute('onclick');
    hdrLearn.onclick = () => openDocsModal('recipes');
  }
  if (hdrMethods) {
    hdrMethods.removeAttribute('onclick');
    hdrMethods.onclick = () => openMethodModal();
  }
}

function clearAllAndSidebarSearch() {
  clearAllWorkflowData();
  clearSidebarSearch();
}

function clearAllWorkflowData(keepPattern) {
  const keep = keepPattern !== false;
  document.getElementById('param-rows').innerHTML = '';
  document.getElementById('file-rows').innerHTML = '';
  document.getElementById('opt-mode').value = 'permutation';
  document.getElementById('opt-min').value = '';
  document.getElementById('opt-methods').value = '';
  document.getElementById('opt-colmethods').value = '';
  document.getElementById('opt-append').value = '';
  updateModeUI();
  METHOD_FLOW_STATE.items = [];
  renderMethodFlow();
  syncMethodFlowToInput();
  updateWorkflowConnectors();
  fullResults = [];
  const outputArea = document.getElementById('output-area');
  const emptyState = document.getElementById('empty-state');
  if (outputArea) { outputArea.textContent = ''; outputArea.style.display = 'none'; }
  if (emptyState) emptyState.style.display = '';
  const stats = document.getElementById('stats');
  if (stats) stats.textContent = '';
  const metricLines = document.getElementById('metric-lines');
  const metricRuntime = document.getElementById('metric-runtime');
  const metricMode = document.getElementById('metric-mode');
  if (metricLines) metricLines.textContent = '0';
  if (metricRuntime) metricRuntime.textContent = '0.00s';
  if (metricMode) metricMode.textContent = getModeLabel(document.getElementById('opt-mode').value);
  if (!keep) document.getElementById('pattern').value = '';
  onPatternChange();
  validateInputs();
  showToast(keep ? 'Cleared all settings (pattern kept)' : 'Cleared all settings');
}

function getAutocompleteBox() {
  let box = document.getElementById('ac-box');
  if (!box) {
    box = document.createElement('div');
    box.id = 'ac-box';
    box.className = 'ac-box';
    document.body.appendChild(box);
  }
  return box;
}

function hideAutocomplete() {
  const box = getAutocompleteBox();
  box.style.display = 'none';
  acState = { input: null, items: [], activeIndex: 0, replaceRange: null, mode: '', meta: {} };
}

function positionAutocomplete() {
  if (!acState.input) return;
  const box = getAutocompleteBox();
  if (box.style.display === 'none') return;
  const rect = acState.input.getBoundingClientRect();
  box.style.left = Math.max(8, rect.left) + 'px';
  box.style.top = (rect.bottom + 6) + 'px';
  box.style.width = Math.min(420, Math.max(250, rect.width)) + 'px';
}

function showAutocomplete(input, items, replaceRange, mode, meta) {
  if (!items.length) { hideAutocomplete(); return; }
  const box = getAutocompleteBox();
  acState = { input, items, activeIndex: 0, replaceRange, mode, meta: meta || {} };
  renderAutocomplete();
  box.style.display = 'block';
  positionAutocomplete();
}

function renderAutocomplete() {
  const box = getAutocompleteBox();
  const favs = getFavoriteMethods();
  const prevTop = box.scrollTop;
  box.innerHTML = '';
  acState.items.forEach((m, i) => {
    const row = document.createElement('div');
    row.className = 'ac-item' + (i === acState.activeIndex ? ' active' : '');
    const fav = favs.has(m.name);
    row.innerHTML = `<div class="ac-main"><span class="ac-code">${m.insert}</span><span class="ac-desc">${m.desc}</span></div><button class="ac-fav${fav ? ' on' : ''}" title="Favorite">${fav ? '★' : '☆'}</button>`;
    row.addEventListener('mousedown', (e) => { e.preventDefault(); });
    row.addEventListener('click', () => applyAutocomplete(i));
    row.querySelector('.ac-fav').addEventListener('click', (e) => {
      e.stopPropagation();
      const set = getFavoriteMethods();
      if (set.has(m.name)) set.delete(m.name); else set.add(m.name);
      setFavoriteMethods(set);
      updateAutocomplete(acState.input);
    });
    box.appendChild(row);
  });
  box.scrollTop = prevTop;
  const active = box.querySelector('.ac-item.active');
  if (active) {
    const top = active.offsetTop;
    const bottom = top + active.offsetHeight;
    if (top < box.scrollTop) box.scrollTop = top;
    else if (bottom > box.scrollTop + box.clientHeight) box.scrollTop = bottom - box.clientHeight;
  }
}

function handleAutocompleteKey(e) {
  if (!acState.input) return false;
  if (e.key === 'ArrowDown') { e.preventDefault(); acState.activeIndex = (acState.activeIndex + 1) % acState.items.length; renderAutocomplete(); return true; }
  if (e.key === 'ArrowUp') { e.preventDefault(); acState.activeIndex = (acState.activeIndex - 1 + acState.items.length) % acState.items.length; renderAutocomplete(); return true; }
  if (e.key === 'Enter' || e.key === 'Tab') { e.preventDefault(); applyAutocomplete(acState.activeIndex); return true; }
  if (e.key === 'Escape') { hideAutocomplete(); return true; }
  return false;
}

function applyAutocomplete(index) {
  const item = acState.items[index];
  if (!item || !acState.input || !acState.replaceRange) return;
  const input = acState.input;
  const text = input.value;
  let { start, end } = acState.replaceRange;
  let insertValue = item.insert;
  if (acState.mode === 'pattern_method' && acState.meta && acState.meta.baseMissing) {
    start = acState.meta.tokenStart;
    insertValue = '`text`.' + item.insert;
    showToast('Inserted as `text`.' + item.name + ' to keep valid syntax');
  }
  input.value = text.slice(0, start) + insertValue + text.slice(end);
  const pos = start + insertValue.length;
  input.focus();
  input.setSelectionRange(pos, pos);
  hideAutocomplete();
  if (input.id === 'pattern') onPatternChange();
  validateInputs();
}

function fuzzyScore(method, q) {
  if (!q) return 1;
  q = q.toLowerCase();
  const hay = [method.insert, method.name, ...method.aliases].join(' ').toLowerCase();
  if (hay.includes(q)) return 2;
  let j = 0;
  for (const ch of hay) if (ch === q[j]) j++;
  return j === q.length ? 1 : 0;
}

function getVarNames() {
  const names = [];
  for (const row of document.querySelectorAll('#param-rows .dyn-row, #file-rows .dyn-row')) {
    const n = row.querySelector('.name-input')?.value?.trim();
    if (n && !names.includes(n)) names.push(n);
  }
  return names;
}

function updateAutocomplete(input) {
  if (!input) return hideAutocomplete();
  const pos = input.selectionStart;
  const text = input.value;
  const favs = getFavoriteMethods();
  const sortedMethods = [...METHOD_CATALOG].sort((a, b) => (favs.has(b.name) - favs.has(a.name)));
  if (input.id === 'pattern') {
    const before = text.slice(0, pos);
    const tokenStart = Math.max(before.lastIndexOf(' '), before.lastIndexOf('\n'), before.lastIndexOf('\t')) + 1;
    const token = before.slice(tokenStart);
    const dotIdx = token.lastIndexOf('.');
    if (dotIdx >= 0) {
      const base = token.slice(0, dotIdx).trim();
      const baseMissing = !base;
      const q = token.slice(dotIdx + 1);
      const items = sortedMethods.filter(m => fuzzyScore(m, q) > 0).slice(0, q ? 16 : 80);
      return showAutocomplete(input, items, { start: pos - q.length, end: pos }, 'pattern_method', { baseMissing, tokenStart });
    }
    const q = token;
    if (!q) return hideAutocomplete();
    const vars = getVarNames()
      .filter(v => v.toLowerCase().includes(q.toLowerCase()))
      .map(v => ({ insert: v, name: v, desc: 'variable', aliases: [] }))
      .slice(0, 8);
    return showAutocomplete(input, vars, { start: pos - q.length, end: pos }, 'variable');
  }
  if (input.id === 'opt-methods') {
    const before = text.slice(0, pos);
    const sep = Math.max(before.lastIndexOf(','), before.lastIndexOf(' '));
    const q = before.slice(sep + 1);
    const items = sortedMethods.filter(m => fuzzyScore(m, q) > 0).slice(0, q ? 16 : 80);
    return showAutocomplete(input, items, { start: pos - q.length, end: pos }, 'method');
  }
  if (input.id === 'opt-colmethods') {
    const before = text.slice(0, pos);
    const segStart = before.lastIndexOf(';') + 1;
    const seg = before.slice(segStart);
    const colon = seg.indexOf(':');
    if (colon < 0) {
      const q = seg.trim();
      const items = sortedMethods
        .filter(m => fuzzyScore(m, q) > 0)
        .map(m => ({ ...m, insert: '0:' + m.insert, desc: 'col 0 -> ' + m.desc }))
        .slice(0, q ? 16 : 80);
      return showAutocomplete(input, items, { start: segStart, end: pos }, 'colprefix');
    }
    const methodPart = seg.slice(colon + 1);
    const comma = methodPart.lastIndexOf(',');
    const q = comma >= 0 ? methodPart.slice(comma + 1) : methodPart;
    const items = sortedMethods.filter(m => fuzzyScore(m, q) > 0).slice(0, q ? 16 : 80);
    return showAutocomplete(input, items, { start: pos - q.length, end: pos }, 'method');
  }
  hideAutocomplete();
}

function validateInputs() {
  const pattern = document.getElementById('pattern').value.trim();
  const globalMethods = document.getElementById('opt-methods').value.trim();
  const colMethods = document.getElementById('opt-colmethods').value.trim();
  const known = new Set(METHOD_CATALOG.map(m => m.name).concat(Object.keys(METHOD_ALIASES)));
  const unknown = [];
  const badBracket = [];
  if (pattern) {
    const tokens = splitPatternColumns(pattern);
    tokens.forEach((t) => {
      const token = String(t || '').trim();
      if (!token) return;
      let methods = [];
      if (token.startsWith('`')) {
        let close = -1;
        let escaped = false;
        for (let i = 1; i < token.length; i++) {
          const ch = token[i];
          if (ch === '\\' && !escaped) { escaped = true; continue; }
          if (ch === '`' && !escaped) { close = i; break; }
          escaped = false;
        }
        if (close > 0) {
          const suffix = token.slice(close + 1).trim();
          if (suffix.startsWith('.')) {
            const parts = CookParser.splitMethods('x' + suffix);
            methods = parts.slice(1);
          }
        }
      } else if (/^[A-Za-z_][A-Za-z0-9_]*(\.[A-Za-z_][A-Za-z0-9_]*(\[[^\]]*\])?)+$/.test(token)) {
        methods = CookParser.splitMethods(token).slice(1);
      }

      methods.forEach((m) => {
        const base = m.includes('[') ? m.slice(0, m.indexOf('[')) : m;
        if (!known.has(base)) unknown.push(base);
        if ((m.includes('[') && !m.endsWith(']')) || (!m.includes('[') && m.includes(']'))) badBracket.push(m);
      });
    });
  }
  const gList = globalMethods ? parseMethodCsv(globalMethods) : [];
  gList.forEach((m) => { const base = m.includes('[') ? m.slice(0, m.indexOf('[')) : m; if (!known.has(base)) unknown.push(base); });
  const cList = colMethods ? colMethods.split(';').map(s => s.trim()).filter(Boolean) : [];
  const badCol = [];
  cList.forEach((seg) => {
    const idx = seg.split(':')[0];
    if (!/^\d+$/.test(idx)) badCol.push(seg);
    const part = seg.includes(':') ? seg.split(':').slice(1).join(':') : '';
    parseMethodCsv(part).forEach((m) => {
      const base = m.includes('[') ? m.slice(0, m.indexOf('[')) : m;
      if (!known.has(base)) unknown.push(base);
    });
  });
  const wPattern = [];
  if (badBracket.length) wPattern.push('Unclosed method brackets: ' + [...new Set(badBracket)].join(', '));
  if (unknown.length) wPattern.push('Unknown methods: ' + [...new Set(unknown)].join(', '));
  const wp = document.getElementById('warn-pattern');
  wp.style.display = wPattern.length ? 'block' : 'none';
  wp.textContent = wPattern.join(' | ');
  const wo = document.getElementById('warn-options');
  wo.style.display = badCol.length ? 'block' : 'none';
  wo.textContent = badCol.length ? ('Invalid per-column syntax segments: ' + badCol.join('; ')) : '';
  scheduleStepPreviewUpdate(200);
}

function getPresets() {
  try {
    const raw = localStorage.getItem(PRESET_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : [];
  } catch {
    return [];
  }
}

function setPresets(presets) {
  localStorage.setItem(PRESET_KEY, JSON.stringify(presets));
}

function refreshPresetSelect(selectedName) {
  const select = document.getElementById('preset-select');
  const presets = getPresets();
  select.innerHTML = '<option value="">Select preset...</option>';
  presets.forEach((p) => {
    const opt = document.createElement('option');
    opt.value = p.name;
    opt.textContent = p.name;
    select.appendChild(opt);
  });
  if (selectedName) select.value = selectedName;
}

function collectCurrentConfig() {
  const params = [];
  for (const row of document.querySelectorAll('#param-rows .dyn-row')) {
    const name = row.querySelector('.param-name').value.trim();
    const value = row.querySelector('.param-value').value.trim();
    if (name) params.push({ name, value });
  }
  const mutationNode = METHOD_FLOW_STATE.items.find((i) => isMutationFlowItem(i));
  return {
    pattern: document.getElementById('pattern').value,
    params,
    options: {
      mode: document.getElementById('opt-mode').value,
      min: document.getElementById('opt-min').value,
      methods: document.getElementById('opt-methods').value,
      colmethods: document.getElementById('opt-colmethods').value,
      append: document.getElementById('opt-append').value,
      mutationNode: mutationNode
        ? { profile: mutationNode.profile || 'balanced', words: mutationNode.words || '' }
        : null
    }
  };
}

function applyConfig(config) {
  document.getElementById('pattern').value = config.pattern || '';
  onPatternChange();
  document.getElementById('param-rows').innerHTML = '';
  const params = Array.isArray(config.params) ? config.params : [];
  for (const p of params) addParamRow(p.name || '', p.value || '');
  const options = config.options || {};
  document.getElementById('opt-mode').value = (options.mode === 'append' ? 'append' : 'permutation');
  document.getElementById('opt-min').value = options.min || '';
  document.getElementById('opt-methods').value = options.methods || '';
  document.getElementById('opt-colmethods').value = options.colmethods || '';
  document.getElementById('opt-append').value = options.append || '';
  updateModeUI();
  syncMethodFlowFromInput();
  ensureLegacyMutationNode(options, true);
  layoutMethodNodes(false);
  renderMethodFlow();
  syncMethodFlowToInput();
}

function savePreset() {
  const input = document.getElementById('preset-name');
  const name = input.value.trim();
  if (!name) { showToast('Preset name is required'); return; }
  const presets = getPresets();
  const config = collectCurrentConfig();
  const i = presets.findIndex(p => p.name === name);
  if (i >= 0) presets[i] = { name, config, updatedAt: Date.now() };
  else presets.push({ name, config, updatedAt: Date.now() });
  setPresets(presets);
  refreshPresetSelect(name);
  localStorage.setItem(PRESET_LAST_KEY, name);
  showToast(i >= 0 ? 'Preset updated' : 'Preset saved');
}

function loadSelectedPreset(nameArg, silent) {
  const select = document.getElementById('preset-select');
  const name = nameArg || select.value;
  if (!name) return;
  const preset = getPresets().find(p => p.name === name);
  if (!preset) return;
  applyConfig(preset.config || {});
  refreshPresetSelect(name);
  document.getElementById('preset-name').value = name;
  localStorage.setItem(PRESET_LAST_KEY, name);
  if (!silent) showToast('Preset loaded (files are not persisted)');
}

function runSelectedPreset() {
  const select = document.getElementById('preset-select');
  if (!select.value) { showToast('Select a preset first'); return; }
  loadSelectedPreset(select.value, true);
  startGenerate();
}

function deletePreset() {
  const select = document.getElementById('preset-select');
  const name = select.value || document.getElementById('preset-name').value.trim();
  if (!name) { showToast('Select a preset to delete'); return; }
  const presets = getPresets().filter(p => p.name !== name);
  setPresets(presets);
  document.getElementById('preset-name').value = '';
  refreshPresetSelect('');
  if (localStorage.getItem(PRESET_LAST_KEY) === name) localStorage.removeItem(PRESET_LAST_KEY);
  showToast('Preset deleted');
}

function togglePresetAutoRestore(enabled) {
  localStorage.setItem(PRESET_AUTORESTORE_KEY, enabled ? '1' : '0');
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2000);
}

async function copyNodePreviewFromElement(el) {
  if (!el) return;
  const txt = String(el.dataset.previewCopy || '').trim();
  if (!txt || txt === '(no lines)') return;
  try {
    await navigator.clipboard.writeText(txt);
    showToast('Preview copied');
  } catch {
    showToast('Copy failed');
  }
}

function copyOutput() {
  if (fullResults.length === 0) return;
  navigator.clipboard.writeText(fullResults.join('\n')).then(() => showToast('Copied to clipboard'));
}

function openFullResultsWindow() {
  if (fullResults.length === 0) {
    showToast('No results yet. Click Generate first.');
    return;
  }
  const win = window.open('about:blank', '_blank');
  if (!win) {
    // Fallback keeps the action useful even if popups are restricted.
    downloadOutput();
    showToast('Popup blocked. Downloaded output instead.');
    return;
  }
  try {
    const doc = win.document;
    doc.open();
    doc.write('<!doctype html><html><head><meta charset="utf-8"><title>Cooked Results</title></head><body>');
    doc.close();
    if (!doc.documentElement) {
      const html = doc.createElement('html');
      doc.appendChild(html);
    }
    if (!doc.head) {
      const head = doc.createElement('head');
      doc.documentElement.insertBefore(head, doc.documentElement.firstChild);
    }
    if (!doc.body) {
      const body = doc.createElement('body');
      doc.documentElement.appendChild(body);
    }
    doc.body.innerHTML = '';
    doc.body.style.margin = '0';
    doc.body.style.fontFamily = 'ui-monospace, Menlo, Consolas, monospace';
    doc.body.style.background = '#0b1220';
    doc.body.style.color = '#dbeafe';

    const pre = doc.createElement('pre');
    pre.textContent = fullResults.join('\n');
    pre.style.margin = '0';
    pre.style.padding = '14px';
    pre.style.whiteSpace = 'pre';
    pre.style.lineHeight = '1.45';
    doc.body.appendChild(pre);
  } catch (err) {
    downloadOutput();
    showToast('Could not open new window. Downloaded output instead.');
  }
}

function downloadOutput() {
  if (fullResults.length === 0) return;
  const blob = new Blob([fullResults.join('\n')], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'cook-output.txt';
  a.click();
  URL.revokeObjectURL(a.href);
}

// ── Method modal ──
function openMethodModal(opts) {
  const options = opts || {};
  if (typeof options.query === 'string') {
    METHOD_MODAL_STATE.query = options.query.toLowerCase();
  }
  closeExamplesModal();
  closeDocsModal();
  document.getElementById('method-modal').classList.add('open');
  const search = document.getElementById('method-search-input');
  if (search) search.value = METHOD_MODAL_STATE.query;
  renderMethodModal();
  if (search && options.focus !== false) setTimeout(() => search.focus(), 0);
}
function closeMethodModal() { document.getElementById('method-modal').classList.remove('open'); }

function filterMethods(query) {
  METHOD_MODAL_STATE.query = (query || '').toLowerCase();
  renderMethodModal();
}

function setMethodCategory(cat) {
  METHOD_MODAL_STATE.category = cat;
  renderMethodModal();
}

function selectMethod(method) {
  METHOD_MODAL_STATE.selected = method;
  renderMethodModal();
}

function getMethodInsertToken(methodName) {
  const meta = METHOD_CATALOG.find((m) => m.name === methodName);
  return (meta?.insert || methodName || '').trim();
}

function addMethodToWorkflow(methodName, shouldRun) {
  const token = getMethodInsertToken(methodName);
  if (!token) return;
  addMethodNode(token);
  validateInputs();
  closeMethodModal();
  clearSidebarSearch();
  showToast(`Added .${token} to workflow`);
  if (shouldRun) startGenerate();
}

function insertSelectedMethod() {
  if (!METHOD_MODAL_STATE.selected) return;
  addMethodToWorkflow(METHOD_MODAL_STATE.selected, false);
}

function onMethodCardClick(method) {
  const now = Date.now();
  const isDouble = METHOD_MODAL_STATE.lastClickName === method && (now - METHOD_MODAL_STATE.lastClickTs) <= 2000;
  METHOD_MODAL_STATE.lastClickName = method;
  METHOD_MODAL_STATE.lastClickTs = now;
  selectMethod(method);
  if (isDouble) addMethodToWorkflow(method, false);
}

function parseRawMethodChain(input) {
  const s = (input || '').trim();
  if (!s.startsWith('`')) return null;
  let insideRaw = false;
  let rawEnd = -1;
  for (let i = 0; i < s.length; i++) {
    if (s[i] === '`') {
      insideRaw = !insideRaw;
      if (!insideRaw) { rawEnd = i; break; }
    }
  }
  if (rawEnd <= 0 || insideRaw) return null;
  const raw = s.slice(1, rawEnd);
  const suffix = s.slice(rawEnd + 1).trim();
  if (suffix && (!suffix.startsWith('.') || /\s/.test(suffix))) return null;
  return { raw, suffix };
}

function applyMethodToAllPatternText(method) {
  addMethodToWorkflow(method, false);
  return;
  const ta = document.getElementById('pattern');
  if (!ta) return;
  const current = ta.value || '';
  const trimmed = current.trim();

  // If input is already a raw literal chain, append method (nested chain support).
  const chain = parseRawMethodChain(trimmed);
  if (chain) {
    const base = '`' + chain.raw.replace(/`/g, '') + '`';
    const next = chain.suffix ? `${base}${chain.suffix}.${method}` : `${base}.${method}`;
    ta.value = next;
    ta.focus();
    ta.setSelectionRange(next.length, next.length);
    onPatternChange();
    closeMethodModal();
    return;
  }

  // Otherwise wrap full text as raw literal and start chain.
  if (trimmed) {
    const noBackticks = current.replace(/`/g, '');
    const replaced = '`' + noBackticks + '`.' + method;
    ta.value = replaced;
    ta.focus();
    ta.setSelectionRange(replaced.length, replaced.length);
    onPatternChange();
    closeMethodModal();
    return;
  }

  // Fallback: no existing text -> use regular insertion flow.
  insertMethod(method);
}

function renderMethodModal() {
  const grid = document.getElementById('method-grid');
  if (!grid) return;

  document.querySelectorAll('.method-side-item').forEach((btn) => {
    btn.classList.toggle('active', btn.dataset.cat === METHOD_MODAL_STATE.category);
  });

  const q = METHOD_MODAL_STATE.query;
  const filtered = METHOD_CATALOG.filter((m) => {
    const inCategory = METHOD_MODAL_STATE.category === 'all' || getMethodCategory(m.name) === METHOD_MODAL_STATE.category;
    if (!inCategory) return false;
    if (!q) return true;
    const hay = [m.insert, m.name, m.desc, ...m.aliases].join(' ').toLowerCase();
    return hay.includes(q);
  });

  if (!filtered.some(m => m.name === METHOD_MODAL_STATE.selected) && filtered.length) {
    METHOD_MODAL_STATE.selected = filtered[0].name;
  }

  if (!filtered.length) {
    grid.innerHTML = '<div class="method-empty">No methods found for this search/category.</div>';
  } else {
    grid.innerHTML = filtered.map((m) => {
      const active = m.name === METHOD_MODAL_STATE.selected ? ' active' : '';
      const details = METHOD_DETAILS[m.name];
      const longDesc = details ? details.long : m.desc;
      const ex = details ? details.ex : `input.${m.insert}`;
      const aliasList = (m.aliases || [])
        .filter(a => a !== m.name)
        .slice(0, 4)
        .map(a => `<span class="method-alias">${escapeHtml(a)}</span>`)
        .join('');
      const paramGuide = METHOD_PARAM_GUIDE[m.name]
        ? `<div class="method-param">${escapeHtml(METHOD_PARAM_GUIDE[m.name])}</div>`
        : '';
      return `<article class="method-card${active}" onclick="onMethodCardClick('${escapeHtml(m.name)}')">
        <div class="method-card-name">.${escapeHtml(m.insert)}</div>
        <div class="method-card-desc">${escapeHtml(longDesc)}</div>
        ${aliasList ? `<div class="method-card-meta">${aliasList}</div>` : ''}
        ${paramGuide}
        <div class="method-card-ex">${escapeHtml(ex)}</div>
      </article>`;
    }).join('');
  }

  const btn = document.getElementById('method-insert-btn');
  if (btn) {
    const has = !!METHOD_MODAL_STATE.selected;
    btn.disabled = !has;
    btn.textContent = has ? `Add .${METHOD_MODAL_STATE.selected}` : 'Add Method Node';
  }
}

function insertMethod(method) {
  const ta = document.getElementById('pattern');
  const startPos = ta.selectionStart;
  const endPos = ta.selectionEnd;
  const text = ta.value;

  // If user selected text, wrap it as raw literal and chain method.
  if (endPos > startPos) {
    const selected = text.slice(startPos, endPos).replace(/`/g, '');
    const insertSel = '`' + selected + '`.' + method;
    ta.value = text.slice(0, startPos) + insertSel + text.slice(endPos);
    const p = startPos + insertSel.length;
    ta.focus();
    ta.setSelectionRange(p, p);
    onPatternChange();
    closeMethodModal();
    return;
  }

  const before = text.slice(0, startPos);
  const tokenStart = Math.max(before.lastIndexOf(' '), before.lastIndexOf('\n'), before.lastIndexOf('\t')) + 1;
  const token = before.slice(tokenStart);
  const hasBase = token.replace(/\./g, '').trim().length > 0;
  const endsWithDot = token.endsWith('.');

  let insert;
  if (!hasBase) insert = '`text`.' + method;
  else if (endsWithDot) insert = method;
  else insert = '.' + method;

  ta.value = text.slice(0, startPos) + insert + text.slice(startPos);
  ta.focus();
  ta.setSelectionRange(startPos + insert.length, startPos + insert.length);
  onPatternChange();
  closeMethodModal();
}

function renderExamplesModal() {
  const grid = document.getElementById('examples-grid');
  if (!grid) return;
  document.querySelectorAll('.example-side-item').forEach((btn) => {
    btn.classList.toggle('active', btn.dataset.cat === EXAMPLES_MODAL_STATE.category);
  });

  const q = EXAMPLES_MODAL_STATE.query;
  const filtered = EXAMPLE_LIBRARY
    .map((ex, idx) => ({ ex, idx }))
    .filter(({ ex }) => {
      const cats = getExampleCategories(ex);
      const inCategory = EXAMPLES_MODAL_STATE.category === 'all' || cats.includes(EXAMPLES_MODAL_STATE.category);
      if (!inCategory) return false;
      if (!q) return true;
      const hay = [ex.name, ex.pattern, ex.output, getExampleNarrative(ex), ...cats, ...(ex.tags || [])].join(' ').toLowerCase();
      return hay.includes(q);
    });

  if (!filtered.some(f => f.idx === EXAMPLES_MODAL_STATE.selected) && filtered.length) {
    EXAMPLES_MODAL_STATE.selected = filtered[0].idx;
  }

  if (!filtered.length) {
    grid.innerHTML = '<div class="method-empty">No examples found for this search/category.</div>';
  } else {
    grid.innerHTML = filtered.map(({ ex, idx }) => {
      const tags = (ex.tags || []).map(tag => `<span class="example-tag">${escapeHtml(tag)}</span>`).join('');
      const cats = getExampleCategories(ex);
      const primaryCategory = getExampleCategoryLabel(cats[0] || 'pipelines');
      const options = ex.options || {};
      const methodsFromOptions = (options.methods || '')
        .split(';')
        .flatMap((chunk) => parseMethodCsv(chunk))
        .slice(0, 3)
        .map(m => `.${m}`);
      const methodsFromPattern = [...(ex.pattern || '').matchAll(/\.([a-zA-Z][a-zA-Z0-9_]*(?:\[[^\]]*\])?)/g)]
        .map(m => `.${m[1]}`)
        .slice(0, 3);
      const methods = methodsFromOptions.length ? methodsFromOptions : methodsFromPattern;
      const flowNodes = [
        { kind: 'Pattern', value: (ex.pattern || '').slice(0, 24) || 'pattern' },
        ...methods.map((m) => ({ kind: 'Method', value: m })),
        { kind: 'Output', value: (ex.output || '').split('\n')[0].slice(0, 24) || 'result' }
      ];
      const flowHtml = flowNodes.map((node, i) => {
        const nodeHtml = `<div class="example-flow-node"><b>${escapeHtml(node.kind)}</b><span>${escapeHtml(node.value)}</span></div>`;
        if (i === flowNodes.length - 1) return nodeHtml;
        return `${nodeHtml}<div class="example-flow-conn"></div>`;
      }).join('');
      const active = idx === EXAMPLES_MODAL_STATE.selected ? ' active' : '';
      const outputPreview = String(ex.output || '').split('\n').slice(0, 2).join(' | ');
      return `<article class="example-card example-tutorial-card${active}" onclick="onExampleCardClick(${idx})">
        <div class="example-tutorial-inner">
          <div>
            <div class="example-meta-line">
              <span class="example-badge">${escapeHtml(primaryCategory)}</span>
              <span class="example-blocks">${flowNodes.length} blocks</span>
            </div>
            <div class="example-main-title">${escapeHtml(ex.name)}</div>
            <div class="example-main-desc">${escapeHtml(getExampleNarrative(ex))}</div>
            <div class="example-io"><strong>Output Preview</strong>${escapeHtml(outputPreview || 'Generated output preview')}</div>
            <div class="example-tags">${tags}</div>
            <div class="example-cta-row">
              <button class="example-cta" type="button" onclick="event.stopPropagation();applyExampleConfig(${idx}, true)">Use This Example + Run</button>
              <button class="example-cta alt" type="button" onclick="event.stopPropagation();applyExampleConfig(${idx}, false)">Use This Example</button>
            </div>
          </div>
          <div class="example-flow-board">${flowHtml}</div>
        </div>
      </article>`;
    }).join('');
  }

  const insertBtn = document.getElementById('example-insert-btn');
  const insertRunBtn = document.getElementById('example-insert-run-btn');
  const selected = EXAMPLE_LIBRARY[EXAMPLES_MODAL_STATE.selected];
  if (insertBtn) {
    insertBtn.disabled = !selected;
    insertBtn.textContent = selected ? `Use: ${selected.name}` : 'Use Example';
  }
  if (insertRunBtn) insertRunBtn.disabled = !selected;
}

function extractMethodsFromExample(ex) {
  if (!ex) return [];
  const methods = [];
  const optionMethods = extractOptionMethodsFromExample(ex);
  const patternMethods = extractPatternMethodsFromExample(ex);
  methods.push(...optionMethods, ...patternMethods);
  const uniq = [];
  const seen = new Set();
  for (const m of methods) {
    if (seen.has(m)) continue;
    seen.add(m);
    uniq.push(m);
  }
  return uniq;
}

function extractOptionMethodsFromExample(ex) {
  if (!ex) return [];
  const options = ex.options || {};
  const methods = [];
  for (const chain of parseMethodCsv(String(options.methods || ''))) {
    const parts = CookParser.splitMethods('x.' + chain).slice(1);
    methods.push(...parts);
  }
  for (const entry of String(options.colmethods || '').split(';').map(s => s.trim()).filter(Boolean)) {
    const parts = entry.split(':');
    if (parts.length < 2) continue;
    const rhs = parts.slice(1).join(':');
    for (const m of rhs.split('.').map(s => s.trim()).filter(Boolean)) methods.push(m);
  }
  return methods;
}

function extractPatternMethodsFromExample(ex) {
  if (!ex) return [];
  return extractPatternMethodsFromText(ex.pattern || '');
}

function applyExampleConfig(index, shouldRun) {
  const ex = EXAMPLE_LIBRARY[index];
  if (!ex) return;
  const optionMethods = extractOptionMethodsFromExample(ex);
  const patternMethods = extractPatternMethodsFromExample(ex);
  const methods = [...new Set([...optionMethods, ...patternMethods])];
  document.getElementById('pattern').value = ex.pattern || '';
  onPatternChange();
  const paramsContainer = document.getElementById('param-rows');
  paramsContainer.innerHTML = '';
  for (const p of (ex.params || [])) addParamRow(p.name || '', p.value || '');

  const options = ex.options || {};
  document.getElementById('opt-mode').value = (options.mode === 'append' ? 'append' : 'permutation');
  document.getElementById('opt-min').value = Object.prototype.hasOwnProperty.call(options, 'min') ? (options.min || '') : '';
  document.getElementById('opt-methods').value = Object.prototype.hasOwnProperty.call(options, 'methods') ? (options.methods || '') : '';
  document.getElementById('opt-colmethods').value = Object.prototype.hasOwnProperty.call(options, 'colmethods') ? (options.colmethods || '') : '';
  document.getElementById('opt-append').value = Object.prototype.hasOwnProperty.call(options, 'append') ? (options.append || '') : '';
  updateModeUI();

  METHOD_FLOW_STATE.items = [];
  renderMethodFlow();
  updateWorkflowConnectors();
  const mutationAdded = ensureLegacyMutationNode(options, true);
  optionMethods.forEach((m) => addMethodNode(m, undefined, undefined, 'global'));
  patternMethods.forEach((m) => addMethodNode(m, undefined, undefined, 'pattern'));
  if (mutationAdded && (optionMethods.length + patternMethods.length === 0)) {
    layoutMethodNodes(false);
    renderMethodFlow();
    syncMethodFlowToInput();
    updateWorkflowConnectors();
  }
  syncMethodFlowToInput();
  validateInputs();
  const patternNode = document.querySelector('.node-pattern');
  if (patternNode) patternNode.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
  closeExamplesModal();
  clearSidebarSearch();
  if (methods.length) showToast(`Added ${methods.length} workflow node${methods.length > 1 ? 's' : ''}`);
  else showToast('Example applied (settings/variables)');
  if (shouldRun) startGenerate();
}

function applyRecipeConfig(index, shouldRun) {
  const recipe = RECIPE_LIBRARY[index];
  if (!recipe) return;
  const optionMethods = extractOptionMethodsFromExample(recipe);
  const patternMethods = extractPatternMethodsFromExample(recipe);
  const methods = [...new Set([...optionMethods, ...patternMethods])];
  document.getElementById('pattern').value = recipe.pattern || '';
  onPatternChange();
  const paramsContainer = document.getElementById('param-rows');
  paramsContainer.innerHTML = '';
  for (const p of (recipe.params || [])) addParamRow(p.name || '', p.value || '');

  const options = recipe.options || {};
  document.getElementById('opt-mode').value = (options.mode === 'append' ? 'append' : (options.mode === 'mutation' ? 'mutation' : 'permutation'));
  document.getElementById('opt-min').value = Object.prototype.hasOwnProperty.call(options, 'min') ? (options.min || '') : '';
  document.getElementById('opt-methods').value = Object.prototype.hasOwnProperty.call(options, 'methods') ? (options.methods || '') : '';
  document.getElementById('opt-colmethods').value = Object.prototype.hasOwnProperty.call(options, 'colmethods') ? (options.colmethods || '') : '';
  document.getElementById('opt-append').value = Object.prototype.hasOwnProperty.call(options, 'append') ? (options.append || '') : '';
  updateModeUI();

  METHOD_FLOW_STATE.items = [];
  renderMethodFlow();
  updateWorkflowConnectors();
  const mutationAdded = ensureLegacyMutationNode(options, true);
  optionMethods.forEach((m) => addMethodNode(m, undefined, undefined, 'global'));
  patternMethods.forEach((m) => addMethodNode(m, undefined, undefined, 'pattern'));
  if (mutationAdded && (optionMethods.length + patternMethods.length === 0)) {
    layoutMethodNodes(false);
    renderMethodFlow();
    syncMethodFlowToInput();
    updateWorkflowConnectors();
  }
  syncMethodFlowToInput();
  validateInputs();
  const patternNode = document.querySelector('.node-pattern');
  if (patternNode) patternNode.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
  closeDocsModal();
  clearSidebarSearch();
  if (methods.length) showToast(`Loaded recipe with ${methods.length} workflow node${methods.length > 1 ? 's' : ''}`);
  else showToast('Recipe loaded');
  if (shouldRun) startGenerate();
}

function getExampleCategoryLabel(cat) {
  const labels = {
    ranges: 'Ranges',
    wordlists: 'Wordlists',
    hashing: 'Hashing',
    encoding: 'Encoding',
    url: 'URL Parsing',
    regex: 'Regex',
    json: 'JSON',
    credentials: 'Credentials',
    filters: 'Filters',
    smart: 'Smart Transform',
    pipelines: 'Pipelines'
  };
  return labels[cat] || 'Workflow';
}

function getRecipeCategoryLabel(cat) {
  const labels = {
    bugbounty: 'Bug Bounty',
    secops: 'Security Operations',
    appsec: 'Application Security',
    identity: 'Identity & Access',
    intel: 'Threat Intel',
    wordlists: 'Wordlist Engineering'
  };
  return labels[cat] || 'Workflow';
}

function getRecipeLevel(recipe) {
  const explicit = String(recipe?.level || '').toLowerCase();
  if (explicit === 'simple' || explicit === 'intermediate' || explicit === 'advanced') return explicit;
  const name = String(recipe?.name || '').toLowerCase();
  if (name.startsWith('simple:')) return 'simple';
  if (name.startsWith('advanced:')) return 'advanced';
  return 'intermediate';
}

function getRecipeUseCaseCategories(ex) {
  const tags = new Set((ex.tags || []).map((t) => String(t).toLowerCase()));
  const pattern = String(ex.pattern || '').toLowerCase();
  const methods = extractMethodsFromExample(ex).map((m) => String(m).toLowerCase());
  const cats = new Set();

  const hasWebRecon = methods.some((m) => ['host','port','path','query','keys','value','domain','tld','subdomain','allsub','alldir','fragment','scheme'].includes(m))
    || tags.has('url')
    || pattern.includes('http://')
    || pattern.includes('https://');
  if (hasWebRecon) { cats.add('bugbounty'); cats.add('appsec'); }

  const hasCredentials = methods.some((m) => ['user', 'pass'].includes(m))
    || tags.has('credentials')
    || pattern.includes(':');
  if (hasCredentials) { cats.add('identity'); cats.add('secops'); }

  const hasHashing = methods.some((m) => ['md5','sha1','sha224','sha256','sha384','sha512'].includes(m)) || tags.has('hash');
  if (hasHashing) { cats.add('secops'); cats.add('intel'); }

  const hasFilters = methods.some((m) => ['contains','grep','grepv','awkn','starts','ends','minlength','maxlength'].includes(m)) || tags.has('filters');
  if (hasFilters) cats.add('secops');

  const hasExtraction = methods.includes('regex') || methods.includes('json') || tags.has('regex') || tags.has('json');
  if (hasExtraction) { cats.add('appsec'); cats.add('intel'); }

  const hasWordlistOps =
    tags.has('cross-product') ||
    tags.has('line-by-line') ||
    tags.has('mutation') ||
    tags.has('leet[1]') ||
    tags.has('smart') ||
    tags.has('range') ||
    tags.has('repeat') ||
    pattern.includes(',') ||
    /(^|[^0-9])\d+-\d+([^0-9]|$)/.test(pattern);
  if (hasWordlistOps) cats.add('wordlists');

  const hasEncoding = methods.some((m) => ['b64e','b64d','hexe','hexd','urle','urld','urlea','jsone','jsonu','xmle','xmlu','unicodee','unicoded','utf16','utf16be','charcode'].includes(m));
  if (hasEncoding) cats.add('appsec');

  if (!cats.size) cats.add('bugbounty');
  return [...cats];
}

function getExampleCategories(ex) {
  const tags = new Set((ex.tags || []).map(t => String(t).toLowerCase()));
  const pattern = String(ex.pattern || '').toLowerCase();
  const methods = extractMethodsFromExample(ex).map((m) => String(m).toLowerCase());
  const cats = new Set();

  if (/(^|[^0-9])\d+-\d+([^0-9]|$)/.test(pattern) || tags.has('range') || tags.has('repeat')) cats.add('ranges');
  if (tags.has('cross-product') || tags.has('line-by-line') || pattern.includes(',')) cats.add('wordlists');
  if (methods.some((m) => ['md5','sha1','sha224','sha256','sha384','sha512'].includes(m)) || tags.has('hash')) cats.add('hashing');
  if (methods.some((m) => ['b64e','b64d','hexe','hexd','urle','urld','urlea','jsone','jsonu','xmle','xmlu','unicodee','unicoded','utf16','utf16be','charcode'].includes(m)) || tags.has('encoding') || tags.has('encode/decode')) cats.add('encoding');
  if (methods.some((m) => ['host','port','path','query','keys','value','domain','tld','subdomain','allsub','alldir','fragment','scheme'].includes(m)) || tags.has('url')) cats.add('url');
  if (methods.includes('regex') || tags.has('regex')) cats.add('regex');
  if (methods.includes('json') || tags.has('json')) cats.add('json');
  if (methods.includes('user') || methods.includes('pass') || tags.has('advanced')) cats.add('credentials');
  if (tags.has('filters') || methods.some((m) => ['contains','grep','grepv','awkn','starts','ends','minlength','maxlength'].includes(m))) cats.add('filters');
  if (methods.some((m) => ['smart','smartjoin','leet'].includes(m)) || tags.has('smart') || tags.has('leet[1]')) cats.add('smart');
  if (methods.length >= 2 || tags.has('dot-chain') || tags.has('col methods')) cats.add('pipelines');

  if (!cats.size) cats.add('pipelines');
  return [...cats];
}

function getExampleNarrative(ex) {
  const options = ex.options || {};
  const mode = String(options.mode || 'permutation');
  const pattern = String(ex.pattern || '').toLowerCase();
  const rawMethods = extractMethodsFromExample(ex);
  const methods = rawMethods.map((m) => {
    const s = String(m || '').toLowerCase();
    const i = s.indexOf('[');
    return i >= 0 ? s.slice(0, i) : s;
  });
  const hasRange = /(^|[^0-9])\d+-\d+([^0-9]|$)/.test(pattern) || /\*/.test(pattern);
  const phrases = [];

  if (mode === 'append') phrases.push('pairs values line-by-line');
  else if (mode === 'mutation') phrases.push('builds base values then generates mutation variants');
  else if (pattern.includes(' ')) phrases.push('combines columns with cross-product permutations');
  else if (pattern.includes(',')) phrases.push('expands comma-separated values');

  if (hasRange) phrases.push('expands ranges and repeat syntax');

  const hashNames = [];
  if (methods.includes('md5')) hashNames.push('MD5');
  if (methods.includes('sha1')) hashNames.push('SHA-1');
  if (methods.includes('sha224')) hashNames.push('SHA-224');
  if (methods.includes('sha256')) hashNames.push('SHA-256');
  if (methods.includes('sha384')) hashNames.push('SHA-384');
  if (methods.includes('sha512')) hashNames.push('SHA-512');
  if (hashNames.length) phrases.push(`hashes results with ${hashNames.join(', ')}`);

  if (methods.includes('upper')) phrases.push('converts output to uppercase');
  if (methods.includes('lower')) phrases.push('converts output to lowercase');
  if (methods.includes('title')) phrases.push('applies title casing');
  if (methods.includes('reverse')) phrases.push('reverses characters');
  if (methods.includes('trim') || methods.includes('ltrim') || methods.includes('rtrim')) phrases.push('trims whitespace');
  if (methods.includes('replace')) phrases.push('replaces matching text segments');
  if (methods.includes('split') || methods.includes('splitindex')) phrases.push('splits values by delimiters');
  if (methods.includes('contains') || methods.includes('starts') || methods.includes('ends') || methods.includes('minlength') || methods.includes('maxlength')) phrases.push('filters values by match/length rules');
  if (methods.includes('unique')) phrases.push('keeps only first unique values');
  if (methods.includes('sort')) phrases.push('sorts results');
  if (methods.includes('sortu')) phrases.push('sorts and removes duplicates');
  if (methods.includes('regex')) phrases.push('extracts regex matches');
  if (methods.includes('json')) phrases.push('extracts JSON fields');
  if (methods.includes('user') || methods.includes('pass')) phrases.push('extracts credential components');
  if (methods.includes('leet')) phrases.push('generates leetspeak variants');
  if (methods.includes('smart') || methods.includes('smartjoin')) phrases.push('normalizes smart word tokens');
  if (methods.some((m) => ['b64e','b64d','hexe','hexd','urle','urld','urlea','jsone','jsonu','xmle','xmlu','unicodee','unicoded','utf16','utf16be','charcode'].includes(m))) {
    phrases.push('encodes or decodes text format');
  }
  if (methods.some((m) => ['scheme','host','port','path','query','keys','value','domain','tld','subdomain','allsub','alldir','fragment'].includes(m))) {
    phrases.push('parses URL/domain components');
  }

  const unique = [];
  const seen = new Set();
  for (const p of phrases) {
    if (!p || seen.has(p)) continue;
    seen.add(p);
    unique.push(p);
  }
  if (!unique.length) return 'Generates output from the configured workflow chain.';
  if (unique.length === 1) return unique[0].charAt(0).toUpperCase() + unique[0].slice(1) + '.';
  return unique[0].charAt(0).toUpperCase() + unique[0].slice(1) + ', then ' + unique.slice(1).join(', then ') + '.';
}

function filterExamples(query) {
  EXAMPLES_MODAL_STATE.query = (query || '').toLowerCase();
  renderExamplesModal();
}

function setExampleCategory(cat) {
  EXAMPLES_MODAL_STATE.category = cat;
  renderExamplesModal();
}

function onExampleCardClick(index) {
  const now = Date.now();
  const isDouble = EXAMPLES_MODAL_STATE.lastClickIndex === index && (now - EXAMPLES_MODAL_STATE.lastClickTs) <= 2000;
  EXAMPLES_MODAL_STATE.lastClickIndex = index;
  EXAMPLES_MODAL_STATE.lastClickTs = now;
  EXAMPLES_MODAL_STATE.selected = index;
  renderExamplesModal();
  if (isDouble) applyExampleConfig(index, true);
}

function insertSelectedExample(shouldRun) {
  if (EXAMPLES_MODAL_STATE.selected < 0) return;
  applyExampleConfig(EXAMPLES_MODAL_STATE.selected, !!shouldRun);
}

function openExamplesModal() {
  closeMethodModal();
  closeDocsModal();
  const search = document.getElementById('examples-search-input');
  if (search) search.value = EXAMPLES_MODAL_STATE.query;
  renderExamplesModal();
  document.getElementById('examples-modal').classList.add('open');
  if (search) setTimeout(() => search.focus(), 0);
}
function closeExamplesModal() { document.getElementById('examples-modal').classList.remove('open'); }

function renderDocsModal() {
  const main = document.getElementById('docs-main');
  if (!main) return;
  const activeTab = DOCS_STATE.tab === 'workflows' ? 'recipes' : DOCS_STATE.tab;
  DOCS_STATE.tab = activeTab;
  document.querySelectorAll('[data-docs-tab]').forEach((btn) => {
    btn.classList.toggle('active', btn.getAttribute('data-docs-tab') === activeTab);
  });
  if (activeTab === 'syntax') {
    const query = String(DOCS_STATE.syntaxQuery || '').trim().toLowerCase();
    const category = DOCS_STATE.syntaxCategory || 'all';
    const filtered = METHOD_CATALOG.filter((m) => {
      const inCategory = category === 'all' || getMethodCategory(m.name) === category;
      if (!inCategory) return false;
      if (!query) return true;
      const hay = [m.insert, m.name, m.desc, ...(m.aliases || [])].join(' ').toLowerCase();
      return hay.includes(query);
    });
    if (!filtered.some((m) => m.name === DOCS_STATE.syntaxSelected) && filtered.length) {
      DOCS_STATE.syntaxSelected = filtered[0].name;
    }
    const cards = filtered.map((m) => {
      const details = METHOD_DETAILS[m.name];
      const longDesc = details ? details.long : m.desc;
      const ex = details ? details.ex : `input.${m.insert}`;
      const aliasList = (m.aliases || [])
        .filter((a) => a !== m.name)
        .slice(0, 4)
        .map((a) => `<span class="method-alias">${escapeHtml(a)}</span>`)
        .join('');
      const paramGuide = METHOD_PARAM_GUIDE[m.name]
        ? `<div class="method-param">${escapeHtml(METHOD_PARAM_GUIDE[m.name])}</div>`
        : '';
      const activeCls = DOCS_STATE.syntaxSelected === m.name ? ' active' : '';
      return `<article class="method-card${activeCls}" onclick="onDocsSyntaxMethodClick('${escapeHtml(m.name)}')">
        <div class="method-card-name">.${escapeHtml(m.insert)}</div>
        <div class="method-card-desc">${escapeHtml(longDesc)}</div>
        ${aliasList ? `<div class="method-card-meta">${aliasList}</div>` : ''}
        ${paramGuide}
        <div class="method-card-ex">${escapeHtml(ex)}</div>
        <div class="docs-row-actions">
          <button class="docs-btn" type="button" onclick="event.stopPropagation();addSyntaxMethod('${escapeHtml(m.name)}', false)">Add Node</button>
          <button class="docs-btn alt" type="button" onclick="event.stopPropagation();addSyntaxMethod('${escapeHtml(m.name)}', true)">Add + Run</button>
        </div>
      </article>`;
    }).join('');
    main.innerHTML = `<section class="docs-hero">
      <h4>Syntax & Method Reference</h4>
      <p>Same method-browser experience: search, filter by category, and insert directly to workflow.</p>
    </section>
    <div class="method-top-search" style="padding:0 0 10px;border:0;background:transparent">
      <input type="text" id="docs-syntax-search" class="method-search" placeholder="Search methods (e.g. .md5, .regex, .split)..." value="${escapeHtml(DOCS_STATE.syntaxQuery || '')}" oninput="filterDocsSyntax(this.value)" />
    </div>
    <div class="method-shell" style="min-height:min(66vh,640px)">
      <aside class="method-sidebar">
        <button class="method-side-item${category === 'all' ? ' active' : ''}" data-cat="all" onclick="setDocsSyntaxCategory('all')">All Methods</button>
        <div class="method-side-title">Categories</div>
        <button class="method-side-item${category === 'string' ? ' active' : ''}" data-cat="string" onclick="setDocsSyntaxCategory('string')">String</button>
        <button class="method-side-item${category === 'hashing' ? ' active' : ''}" data-cat="hashing" onclick="setDocsSyntaxCategory('hashing')">Hashing</button>
        <button class="method-side-item${category === 'encoding' ? ' active' : ''}" data-cat="encoding" onclick="setDocsSyntaxCategory('encoding')">Encoding</button>
        <button class="method-side-item${category === 'web' ? ' active' : ''}" data-cat="web" onclick="setDocsSyntaxCategory('web')">Web</button>
        <button class="method-side-item${category === 'regex' ? ' active' : ''}" data-cat="regex" onclick="setDocsSyntaxCategory('regex')">Regex</button>
      </aside>
      <main class="method-panel">
        <div class="method-grid">${cards || '<div class="method-empty">No methods found for this search/category.</div>'}</div>
      </main>
    </div>`;
    return;
  }
  if (activeTab === 'recipes') {
    const query = String(DOCS_STATE.recipeQuery || '').trim().toLowerCase();
    const recipeCategory = DOCS_STATE.recipeCategory || 'all';
    const list = RECIPE_LIBRARY.filter((recipe) => {
      const category = String(recipe.category || '').toLowerCase();
      const inCategory = recipeCategory === 'all' || category === recipeCategory;
      if (!inCategory) return false;
      if (!query) return true;
      const hay = [
        recipe.name || '',
        recipe.summary || '',
        recipe.pattern || '',
        recipe.output || '',
        recipe.category || '',
        getRecipeLevel(recipe),
        recipe.options?.methods || '',
        recipe.options?.colmethods || '',
        recipe.options?.mode || ''
      ].join(' ').toLowerCase();
      return hay.includes(query);
    });
    if (!list.some((r) => RECIPE_LIBRARY.indexOf(r) === DOCS_STATE.recipeSelected) && list.length) {
      DOCS_STATE.recipeSelected = RECIPE_LIBRARY.indexOf(list[0]);
    }
    const cards = list.map((recipe) => {
      const idx = RECIPE_LIBRARY.indexOf(recipe);
      const tags = [
        `<span class="example-tag">${escapeHtml(getRecipeCategoryLabel(recipe.category || 'wordlists'))}</span>`,
        `<span class="example-tag">level:${escapeHtml(getRecipeLevel(recipe))}</span>`,
        recipe.options?.mode ? `<span class="example-tag">mode:${escapeHtml(recipe.options.mode)}</span>` : '',
        recipe.options?.methods ? `<span class="example-tag">methods:${escapeHtml(recipe.options.methods.split(',').slice(0, 2).join(','))}</span>` : ''
      ].filter(Boolean).join('');
      const primaryCategory = getRecipeCategoryLabel(recipe.category || 'bugbounty');
      const options = recipe.options || {};
      const methodsFromOptions = (options.methods || '')
        .split(';')
        .flatMap((chunk) => parseMethodCsv(chunk))
        .slice(0, 3)
        .map((m) => `.${m}`);
      const methodsFromPattern = [...(recipe.pattern || '').matchAll(/\.([a-zA-Z][a-zA-Z0-9_]*(?:\[[^\]]*\])?)/g)]
        .map((m) => `.${m[1]}`)
        .slice(0, 3);
      const methods = methodsFromOptions.length ? methodsFromOptions : methodsFromPattern;
      const flowNodes = [
        { kind: 'Pattern', value: (recipe.pattern || '').replace(/\n/g, ' ').slice(0, 34) || 'pattern' },
        ...methods.map((m) => ({ kind: 'Method', value: m })),
        { kind: 'Output', value: (recipe.output || '').split('\n')[0].slice(0, 34) || 'result' }
      ];
      const flowHtml = flowNodes.map((node, i) => {
        const nodeHtml = `<div class="example-flow-node"><b>${escapeHtml(node.kind)}</b><span>${escapeHtml(node.value)}</span></div>`;
        if (i === flowNodes.length - 1) return nodeHtml;
        return `${nodeHtml}<div class="example-flow-conn"></div>`;
      }).join('');
      const outputPreview = String(recipe.output || '').split('\n').slice(0, 2).join(' | ');
      const activeCls = DOCS_STATE.recipeSelected === idx ? ' active' : '';
      return `<article class="example-card example-tutorial-card${activeCls}" data-recipe-index="${idx}" onclick="onRecipeCardClick(${idx})">
        <div class="example-tutorial-inner">
          <div>
            <div class="example-meta-line">
              <span class="example-badge">${escapeHtml(primaryCategory)}</span>
              <span class="example-blocks">${flowNodes.length} blocks</span>
            </div>
            <div class="example-main-title">${escapeHtml(recipe.name)}</div>
            <div class="example-main-desc">${escapeHtml(recipe.summary || 'Practical workflow recipe.')}</div>
            <div class="example-io"><strong>Output Preview</strong>${escapeHtml(outputPreview || 'Generated output preview')}</div>
            <div class="example-tags">${tags}</div>
            <div class="example-cta-row">
              <button class="example-cta" type="button" onclick="event.stopPropagation();applyRecipeConfig(${idx}, true)">Use This Recipe + Run</button>
              <button class="example-cta alt" type="button" onclick="event.stopPropagation();applyRecipeConfig(${idx}, false)">Use This Recipe</button>
            </div>
          </div>
          <div class="example-flow-board">${flowHtml}</div>
        </div>
      </article>`;
    }).join('');
    const syntaxMatches = query
      ? METHOD_CATALOG.filter((m) => {
          const hay = [m.name || '', m.insert || '', m.desc || '', ...(m.aliases || [])].join(' ').toLowerCase();
          return hay.includes(query);
        }).slice(0, 18)
      : [];
    const syntaxCards = syntaxMatches.map((m) => {
      const details = METHOD_DETAILS[m.name];
      const longDesc = details ? details.long : m.desc;
      return `<article class="method-card" onclick="onDocsSyntaxMethodClick('${escapeHtml(m.name)}')">
        <div class="method-card-name">.${escapeHtml(m.insert)}</div>
        <div class="method-card-desc">${escapeHtml(longDesc)}</div>
      </article>`;
    }).join('');
    main.innerHTML = `<section class="docs-hero">
      <h4>Recipes</h4>
      <p>All workflows in one place. Search shows both recipes and matching methods.</p>
    </section>
    <section class="docs-block" style="padding:10px">
      <div class="examples-top-search" style="padding:0;border:0;background:transparent">
        <input type="text" class="method-search" id="docs-recipe-search" placeholder="Search recipes (bug bounty, secops, host, grep, json...)" value="${escapeHtml(DOCS_STATE.recipeQuery || '')}" oninput="filterDocsRecipes(this.value)" />
      </div>
      <div style="margin-top:8px;color:var(--muted);font-size:12px">${list.length} recipe${list.length === 1 ? '' : 's'} found</div>
    </section>
    <section class="docs-block" style="margin-bottom:10px">
      <h4 style="margin-bottom:8px">Matching Ingredients ${query ? `(${syntaxMatches.length})` : ''}</h4>
      ${query
        ? `<div class="method-grid" style="max-height:220px;overflow:auto">${syntaxCards || '<div class="method-empty">No matching methods.</div>'}</div>`
        : '<div class="method-empty">Type in search to filter both recipes and ingredients together.</div>'
      }
    </section>
    <section class="examples-shell" style="height:min(68vh,680px)">
      <aside class="examples-sidebar">
        <button class="example-side-item${recipeCategory === 'all' ? ' active' : ''}" type="button" onclick="setDocsRecipeCategory('all')">All Recipes</button>
        <div class="method-side-title">Use Cases</div>
        <button class="example-side-item${recipeCategory === 'bugbounty' ? ' active' : ''}" type="button" onclick="setDocsRecipeCategory('bugbounty')">Bug Bounty</button>
        <button class="example-side-item${recipeCategory === 'secops' ? ' active' : ''}" type="button" onclick="setDocsRecipeCategory('secops')">Security Operations</button>
        <button class="example-side-item${recipeCategory === 'appsec' ? ' active' : ''}" type="button" onclick="setDocsRecipeCategory('appsec')">Application Security</button>
        <button class="example-side-item${recipeCategory === 'identity' ? ' active' : ''}" type="button" onclick="setDocsRecipeCategory('identity')">Identity & Access</button>
        <button class="example-side-item${recipeCategory === 'intel' ? ' active' : ''}" type="button" onclick="setDocsRecipeCategory('intel')">Threat Intel</button>
        <button class="example-side-item${recipeCategory === 'wordlists' ? ' active' : ''}" type="button" onclick="setDocsRecipeCategory('wordlists')">Wordlist Engineering</button>
      </aside>
      <main class="examples-panel">
        <div class="examples-grid">
          ${cards || '<div class="method-empty">No recipes found for this search/category.</div>'}
        </div>
      </main>
    </section>`;
    return;
  }
  DOCS_STATE.tab = 'recipes';
  renderDocsModal();
}

function filterDocsRecipes(query) {
  DOCS_STATE.recipeQuery = String(query || '');
  renderDocsModal();
}

function setDocsRecipeCategory(category) {
  DOCS_STATE.recipeCategory = String(category || 'all');
  renderDocsModal();
}

function selectRecipeCardDom(index) {
  document.querySelectorAll('.example-card.example-tutorial-card').forEach((el) => {
    el.classList.remove('active');
  });
  const target = document.querySelector(`.example-card.example-tutorial-card[data-recipe-index="${index}"]`);
  if (target) target.classList.add('active');
}

function onRecipeCardClick(index) {
  const now = Date.now();
  const isDouble = DOCS_STATE.recipeLastClickIndex === index && (now - DOCS_STATE.recipeLastClickTs) <= 2000;
  DOCS_STATE.recipeLastClickIndex = index;
  DOCS_STATE.recipeLastClickTs = now;
  DOCS_STATE.recipeSelected = index;
  selectRecipeCardDom(index);
  if (isDouble) applyRecipeConfig(index, true);
}

function filterDocsSyntax(query) {
  DOCS_STATE.syntaxQuery = String(query || '');
  renderDocsModal();
  const s = document.getElementById('docs-syntax-search');
  if (s) {
    s.focus();
    const p = s.value.length;
    try { s.setSelectionRange(p, p); } catch {}
  }
}

function setDocsSyntaxCategory(category) {
  DOCS_STATE.syntaxCategory = String(category || 'all');
  renderDocsModal();
}

function addSyntaxMethod(methodName, shouldRun) {
  addMethodToWorkflow(methodName, !!shouldRun);
  closeDocsModal();
}

function onDocsSyntaxMethodClick(methodName) {
  const now = Date.now();
  const isDouble = DOCS_STATE.syntaxLastClickName === methodName && (now - (DOCS_STATE.syntaxLastClickTs || 0)) <= 2000;
  DOCS_STATE.syntaxLastClickName = methodName;
  DOCS_STATE.syntaxLastClickTs = now;
  DOCS_STATE.syntaxSelected = methodName;
  if (isDouble) {
    addSyntaxMethod(methodName, false);
    return;
  }
  renderDocsModal();
}

function loadDocsScenario(key, shouldRun) {
  const pattern = document.getElementById('pattern');
  if (!pattern) return;
  const setBasics = () => {
    document.getElementById('opt-mode').value = 'permutation';
    document.getElementById('opt-min').value = '';
    document.getElementById('opt-methods').value = '';
    document.getElementById('opt-colmethods').value = '';
    document.getElementById('opt-append').value = '';
    METHOD_FLOW_STATE.items = [];
  };
  setBasics();
  if (key === 'url') {
    pattern.value = 'https://api.example.com/v1\nhttps://cdn.example.com/assets\nhttps://api.example.com/login';
    document.getElementById('opt-methods').value = 'host,unique,sortu';
  } else if (key === 'creds') {
    pattern.value = 'alice:Secret123\nbob:Welcome2026\nguest:Summer2025';
    document.getElementById('opt-methods').value = 'user,unique,sortu';
  } else if (key === 'mutation') {
    pattern.value = 'admin,test';
    addMutationNode('balanced', 'corp,secure');
    document.getElementById('opt-methods').value = 'upper,unique,sortu';
  } else if (key === 'hashrange') {
    pattern.value = '01-20';
    document.getElementById('opt-methods').value = 'md5';
  } else if (key === 'apifilter') {
    pattern.value = '/login\n/api/v1/users\n/assets/logo.png\n/api/v2/admin';
    document.getElementById('opt-methods').value = 'contains[/api/],unique,sortu';
  } else if (key === 'usernorm') {
    pattern.value = 'Admin_User\nadmin-user\nADMINUSER\nadmin user';
    document.getElementById('opt-methods').value = 'lower,replace[ :_],replace[-:_],unique,sortu';
  }
  updateModeUI();
  onPatternChange();
  syncMethodFlowFromInput(true);
  validateInputs();
  if (shouldRun) startGenerate();
  closeDocsModal();
}

function setDocsTab(tab) {
  const next = tab === 'workflows'
    ? 'recipes'
    : (tab === 'faq' ? 'syntax' : (tab === 'start' ? 'recipes' : (tab || 'recipes')));
  DOCS_STATE.tab = next;
  renderDocsModal();
}

function openDocsModal(defaultTab) {
  closeMethodModal();
  closeExamplesModal();
  if (defaultTab) setDocsTab(defaultTab);
  renderDocsModal();
  document.getElementById('docs-modal').classList.add('open');
}

function closeDocsModal() {
  const modal = document.getElementById('docs-modal');
  if (modal) modal.classList.remove('open');
}

// ── Theme toggle ──
function applyTheme(theme) {
  document.documentElement.setAttribute('data-theme', theme);
  localStorage.setItem('cook-theme', theme);
  updateThemeIcons(theme);
}
function toggleTheme() {
  const next = document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
  applyTheme(next);
}
function updateThemeIcons(theme) {
  document.getElementById('icon-sun').style.display = theme === 'dark' ? 'none' : '';
  document.getElementById('icon-moon').style.display = theme === 'dark' ? '' : 'none';
}
function chooseTheme(theme) {
  applyTheme(theme);
  document.getElementById('theme-chooser').classList.remove('open');
  if (ONBOARDING_STATE.pendingAfterTheme) {
    ONBOARDING_STATE.pendingAfterTheme = false;
    setTimeout(() => startOnboarding(false), 120);
  }
}

function onboardingSteps() {
  return [
    {
      title: 'Welcome to COOKED',
      body: 'In this tour: paste input, add one method, run, and verify output. Follow each step in order.',
      showFlow: true
    },
    {
      selector: '.node-pattern',
      title: '1) Input Text Area',
      body: 'Paste your raw list here (URLs, combos, ranges, words). Everything starts from this box.',
      actionLabel: 'Load URL wordlist sample',
      action: () => {
        const p = document.getElementById('pattern');
        p.value = '`https://api.example.com/v1\nhttps://cdn.example.com/assets\nhttps://api.example.com/login`';
        onPatternChange();
        validateInputs();
        p.focus();
      }
    },
    {
      selector: '#pattern',
      title: '2) Dot Methods In Input',
      body: 'Use inline chains directly on pasted blocks. Example: add .host to extract hosts from URLs.',
      actionLabel: 'Show .host inline chain',
      action: () => {
        const p = document.getElementById('pattern');
        if (!p) return;
        ONBOARDING_STATE.dotRestore = p.value;
        p.value = '`https://api.example.com/v1\nhttps://cdn.example.com/assets\nhttps://api.example.com/login`.host';
        p.focus();
        p.setSelectionRange(p.value.length, p.value.length);
        updateAutocomplete(p);
        setTimeout(() => updateAutocomplete(p), 30);
      },
      exit: () => {
        hideAutocomplete();
        const p = document.getElementById('pattern');
        if (p && ONBOARDING_STATE.dotRestore !== null) p.value = ONBOARDING_STATE.dotRestore;
        ONBOARDING_STATE.dotRestore = null;
        onPatternChange();
      }
    },
    {
      selector: '#step-preview-input',
      title: '3) Input Expansion Preview',
      body: 'Each node preview shows what changed at that step so you can debug chains quickly.',
      actionLabel: 'Preview range expansion',
      action: () => {
        const p = document.getElementById('pattern');
        if (!p) return;
        p.value = '01-10';
        onPatternChange();
        validateInputs();
      }
    },
    {
      selector: '.toolbox-search',
      title: '4) Left Library Search',
      body: 'Search actions fast: methods, examples, docs, and mutation node insertion.',
      actionLabel: 'Search for docs',
      action: () => {
        const s = document.querySelector('.toolbox-search');
        if (!s) return;
        s.value = 'docs';
        s.dispatchEvent(new Event('input', { bubbles: true }));
        s.focus();
      },
      exit: () => clearSidebarSearch()
    },
    {
      selector: '#opt-mode',
      title: '5) Choose Combine Mode',
      body: 'Cross-product combines columns broadly. Line-by-line pairs row by row. Choose based on your data shape.',
      actionLabel: 'Switch to Line-by-line',
      action: () => {
        const mode = document.getElementById('opt-mode');
        mode.value = 'append';
        updateModeUI();
        validateInputs();
      }
    },
    {
      selector: '#opt-methods',
      title: '6) Add Global Methods',
      body: 'Methods here run left to right on the generated output. Use this for cleanup and normalization.',
      actionLabel: 'Apply host cleanup chain',
      action: () => {
        const input = document.getElementById('opt-methods');
        input.value = 'trim,unique,sortu';
        syncMethodFlowFromInput();
        validateInputs();
      }
    },
    {
      selector: '#tool-open-methods',
      title: '7) Open Ingredients',
      body: 'Ingredients is your method library. Use it to add transforms to the workflow.',
      actionLabel: 'Open Ingredients',
      action: () => openMethodModal()
    },
    {
      selector: '#method-search-input',
      title: '8) Search in Methods',
      body: 'Search by use-case quickly: hash, regex, user/pass parsing, URL parsing, encoding.',
      enter: () => openMethodModal(),
      actionLabel: 'Search user',
      action: () => {
        const s = document.getElementById('method-search-input');
        if (!s) return;
        s.value = 'user';
        filterMethods('user');
        s.focus();
      }
    },
    {
      selector: '#tool-open-learn',
      title: '9) Open Receipes',
      body: 'Receipes contains ready workflows. Pick one and run to understand results fast.',
      enter: () => closeMethodModal(),
      actionLabel: 'Open Receipes',
      action: () => openDocsModal('recipes')
    },
    {
      selector: '#docs-recipe-search',
      title: '10) Search Recipes',
      body: 'Find workflows by method, tag, or use-case and load them instantly.',
      enter: () => { openDocsModal('recipes'); filterDocsRecipes(''); },
      actionLabel: 'Search credentials',
      action: () => {
        const s = document.getElementById('docs-recipe-search');
        if (!s) return;
        s.value = 'credential';
        filterDocsRecipes('credential');
        s.focus();
      }
    },
    {
      selector: '#tool-add-mutation-node',
      title: '11) Mutation Node',
      body: 'Mutation is now a real node with profile and extra words. You can place it anywhere in the workflow.',
      enter: () => closeDocsModal(),
      actionLabel: 'Add Mutation Node',
      action: () => addMutationNode('balanced', 'corp,secure')
    },
    {
      selector: '#btn-generate',
      title: '12) Run Generation',
      body: 'Generate runs the full chain and fills Results Pane. Use this after each change to validate output.',
      actionLabel: 'Generate now',
      enter: () => { closeMethodModal(); closeDocsModal(); },
      action: () => startGenerate()
    },
    {
      selector: '#output-card',
      title: '13) Review Output',
      body: 'Check output here. Use Open Full for large sets, Copy All to clipboard, or Download.',
      actionLabel: 'Copy output',
      action: () => copyOutput()
    },
    {
      selector: '#tool-open-learn',
      title: '14) Receipes',
      body: 'Use Receipes for practical workflow templates, then tweak methods to fit your target.',
      actionLabel: 'Open Receipes',
      action: () => openDocsModal('recipes')
    },
    {
      selector: '[data-docs-tab="recipes"]',
      title: '15) Workflow Recipes',
      body: 'Choose a recipe, load it, and run. Then edit one method at a time to adapt it to your target.',
      enter: () => { openDocsModal('recipes'); setDocsTab('recipes'); },
      actionLabel: 'Open recipes',
      action: () => setDocsTab('recipes')
    },
    {
      selector: '#mode-toggle-btn',
      title: '16) Simplified vs Advanced',
      body: 'Use Simplified Mode for quick one-off generation. Use Advanced for node workflows and step debugging.',
      actionLabel: 'Try Simplified Mode',
      action: () => toggleSimplifiedMode()
    },
    {
      title: 'You are ready',
      body: 'Start with a Receipe, inspect the output, then adjust one method at a time. This keeps workflows understandable and reproducible.',
      showFlow: true,
      final: true
    }
  ];
}

function positionOnboardingSpotlight() {
  if (!ONBOARDING_STATE.open) return;
  const overlay = document.getElementById('onboarding-overlay');
  const spotlight = document.getElementById('onboarding-spotlight');
  if (!overlay || !spotlight) return;
  const step = onboardingSteps()[ONBOARDING_STATE.step];
  if (!step || !step.selector) {
    overlay.classList.remove('has-target');
    return;
  }
  const target = document.querySelector(step.selector);
  if (!target) {
    overlay.classList.remove('has-target');
    return;
  }
  const rect = target.getBoundingClientRect();
  if (rect.width < 2 || rect.height < 2 || rect.bottom < 0 || rect.top > window.innerHeight || rect.right < 0 || rect.left > window.innerWidth) {
    overlay.classList.remove('has-target');
    return;
  }
  const pad = step.selector === '#output-card' ? 10 : 8;
  spotlight.style.left = Math.max(8, rect.left - pad) + 'px';
  spotlight.style.top = Math.max(8, rect.top - pad) + 'px';
  spotlight.style.width = Math.min(window.innerWidth - 16, rect.width + pad * 2) + 'px';
  spotlight.style.height = Math.min(window.innerHeight - 16, rect.height + pad * 2) + 'px';
  overlay.classList.add('has-target');
}

function startOnboardingFollow() {
  stopOnboardingFollow();
  const tick = () => {
    if (!ONBOARDING_STATE.open) return;
    positionOnboardingSpotlight();
    ONBOARDING_STATE.followRaf = requestAnimationFrame(tick);
  };
  ONBOARDING_STATE.followRaf = requestAnimationFrame(tick);
}

function stopOnboardingFollow() {
  if (!ONBOARDING_STATE.followRaf) return;
  cancelAnimationFrame(ONBOARDING_STATE.followRaf);
  ONBOARDING_STATE.followRaf = 0;
}

function renderOnboardingStep() {
  const steps = onboardingSteps();
  const step = steps[ONBOARDING_STATE.step];
  if (!step) return;
  const stepEl = document.getElementById('onboarding-step');
  const titleEl = document.getElementById('onboarding-title');
  const bodyEl = document.getElementById('onboarding-body');
  const nextBtn = document.getElementById('onboarding-next');
  const backBtn = document.getElementById('onboarding-back');
  const tryBtn = document.getElementById('onboarding-try');
  const flow = document.getElementById('onboarding-flow');
  stepEl.textContent = `Quick Tour ${ONBOARDING_STATE.step + 1}/${steps.length}`;
  titleEl.textContent = step.title;
  bodyEl.textContent = step.body;
  nextBtn.textContent = ONBOARDING_STATE.step >= steps.length - 1 ? 'Finish' : 'Next';
  backBtn.disabled = ONBOARDING_STATE.step === 0;
  backBtn.style.opacity = ONBOARDING_STATE.step === 0 ? '.55' : '1';
  if (step.action) {
    tryBtn.style.display = '';
    tryBtn.textContent = step.actionLabel || 'Try this step';
  } else {
    tryBtn.style.display = 'none';
  }
  flow.style.display = step.showFlow ? '' : 'none';
  if (ONBOARDING_STATE.enteredStep !== ONBOARDING_STATE.step && typeof step.enter === 'function') {
    ONBOARDING_STATE.enteredStep = ONBOARDING_STATE.step;
    step.enter();
  }
  if (step.selector) {
    const el = document.querySelector(step.selector);
    if (el && el.scrollIntoView) el.scrollIntoView({ behavior: 'auto', block: 'center', inline: 'nearest' });
  }
  setTimeout(positionOnboardingSpotlight, 30);
  requestAnimationFrame(positionOnboardingSpotlight);
}

function startOnboarding(force) {
  if (ONBOARDING_STATE.open) return;
  if (!force) {
    try {
      if (localStorage.getItem(ONBOARDING_KEY) === 'done') return;
    } catch {}
  }
  closeMethodModal();
  closeExamplesModal();
  closeDocsModal();
  const chooserOpen = document.getElementById('theme-chooser')?.classList.contains('open');
  if (chooserOpen && !force) {
    ONBOARDING_STATE.pendingAfterTheme = true;
    return;
  }
  ONBOARDING_STATE.open = true;
  ONBOARDING_STATE.startedManually = !!force;
  ONBOARDING_STATE.step = 0;
  ONBOARDING_STATE.enteredStep = -1;
  if (document.body.classList.contains('simplified-mode') && !shouldForceSimplifiedViewport()) applySimplifiedMode(false);
  const overlay = document.getElementById('onboarding-overlay');
  if (!overlay) return;
  overlay.classList.add('open');
  overlay.setAttribute('aria-hidden', 'false');
  startOnboardingFollow();
  renderOnboardingStep();
}

function closeOnboarding(markDone) {
  runOnboardingStepExit(ONBOARDING_STATE.step);
  ONBOARDING_STATE.open = false;
  const overlay = document.getElementById('onboarding-overlay');
  if (!overlay) return;
  overlay.classList.remove('open', 'has-target');
  overlay.setAttribute('aria-hidden', 'true');
  stopOnboardingFollow();
  if (markDone) {
    try { localStorage.setItem(ONBOARDING_KEY, 'done'); } catch {}
  }
}

function nextOnboardingStep() {
  const steps = onboardingSteps();
  if (ONBOARDING_STATE.step >= steps.length - 1) {
    closeOnboarding(true);
    showToast('Tutorial completed');
    return;
  }
  runOnboardingStepExit(ONBOARDING_STATE.step);
  ONBOARDING_STATE.step++;
  renderOnboardingStep();
}

function prevOnboardingStep() {
  if (ONBOARDING_STATE.step <= 0) return;
  runOnboardingStepExit(ONBOARDING_STATE.step);
  ONBOARDING_STATE.step--;
  renderOnboardingStep();
}

function skipOnboarding() {
  closeOnboarding(true);
}

function runOnboardingAction() {
  const step = onboardingSteps()[ONBOARDING_STATE.step];
  if (!step || !step.action) return;
  step.action();
  setTimeout(positionOnboardingSpotlight, 80);
}

function runOnboardingStepExit(idx) {
  const step = onboardingSteps()[idx];
  if (!step || typeof step.exit !== 'function') return;
  step.exit();
}

function updateModeToggleLabel() {
  const btn = document.getElementById('mode-toggle-btn');
  if (!btn) return;
  const simple = document.body.classList.contains('simplified-mode');
  btn.textContent = simple ? 'Advanced Mode' : 'Simplified Mode';
}

function applySimplifiedMode(enabled, persist) {
  const shouldPersist = persist !== false;
  document.body.classList.toggle('simplified-mode', !!enabled);
  if (shouldPersist) {
    try { localStorage.setItem('cook-ui-mode', enabled ? 'simplified' : 'advanced'); } catch {}
  }
  updateModeToggleLabel();
  applyWorkflowScale();
  scheduleWorkflowFit(false);
  updateWorkflowConnectors();
}

function toggleSimplifiedMode() {
  if (shouldForceSimplifiedViewport()) {
    applySimplifiedMode(true, false);
    showToast('Simplified mode is used on smaller screens');
    return;
  }
  const next = !document.body.classList.contains('simplified-mode');
  applySimplifiedMode(next, true);
}

function resetSimplifiedMode() {
  clearAllWorkflowData(false);
  const outputCard = document.getElementById('output-card');
  if (outputCard) outputCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

function applyPerformanceProfile(mode) {
  const low = mode === 'low';
  document.body.classList.toggle('low-power', low);
  try { localStorage.setItem('cook-performance-mode', low ? 'low' : 'balanced'); } catch {}
}

function initPerformanceProfile() {
  let mode = 'low';
  try {
    const saved = localStorage.getItem('cook-performance-mode');
    if (saved === 'balanced' || saved === 'low') mode = saved;
  } catch {}

  // Default to low-power for smoother laptop thermals; auto-upgrade to balanced on stronger devices.
  const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  const cpu = navigator.hardwareConcurrency || 4;
  const mem = navigator.deviceMemory || 4;
  if (!prefersReduced && cpu >= 8 && mem >= 8 && mode !== 'low') mode = 'balanced';
  if (prefersReduced) mode = 'low';
  applyPerformanceProfile(mode);
}

function setFlowLink(linkEl, fromEl, toEl, canvasRect) {
  if (!linkEl || !fromEl || !toEl || !canvasRect) return;
  const from = fromEl.getBoundingClientRect();
  const to = toEl.getBoundingClientRect();
  const x1 = (from.right - canvasRect.left);
  const y1 = (from.top + from.height / 2 - canvasRect.top);
  const x2 = (to.left - canvasRect.left);
  const y2 = (to.top + to.height / 2 - canvasRect.top);
  const dx = x2 - x1;
  const dy = y2 - y1;
  const len = Math.hypot(dx, dy);
  const angle = Math.atan2(dy, dx) * 180 / Math.PI;
  linkEl.style.left = `${x1}px`;
  linkEl.style.top = `${y1}px`;
  linkEl.style.width = `${Math.max(0, len)}px`;
  linkEl.style.transform = `rotate(${angle}deg)`;
  linkEl.style.transformOrigin = '0 50%';
  linkEl.style.setProperty('--flow-len', `${Math.max(0, len)}px`);
}

let _flowConnectorRaf = 0;
function _requestConnectorFrame() {
  if (_flowConnectorRaf) return;
  _flowConnectorRaf = requestAnimationFrame(() => {
    _flowConnectorRaf = 0;
    updateWorkflowConnectorsNow();
  });
}

const DEFAULT_WORKFLOW_LAYOUT = {
  pattern: { left: 70, top: 142 },
  options: { left: 580, top: 168 }
};
const DEFAULT_WORKFLOW_SCALE = 0.9;
const MOBILE_SIMPLE_BREAKPOINT = 900;
const WORKFLOW_VIEW = { scale: DEFAULT_WORKFLOW_SCALE, userLocked: false };
let WORKFLOW_FIT_TIMER = 0;

function isMobileViewport() {
  return window.matchMedia(`(max-width: ${MOBILE_SIMPLE_BREAKPOINT}px)`).matches;
}

function shouldForceSimplifiedViewport() {
  const w = window.innerWidth || 0;
  const h = window.innerHeight || 0;
  if (w <= MOBILE_SIMPLE_BREAKPOINT) return true;
  if (h <= 620) return true;
  if (w <= 1180 && h <= 700) return true;
  return false;
}

function updateDynamicNodeScale() {
  const canvas = document.querySelector('.workflow-canvas');
  const stage = document.getElementById('workflow-stage');
  if (!canvas || !stage) return;
  if (window.matchMedia('(max-width: 1020px)').matches || document.body.classList.contains('simplified-mode')) {
    stage.style.setProperty('--node-scale', '1');
    stage.style.setProperty('--node-vscale', '1');
    stage.classList.remove('workflow-tight');
    return;
  }
  const w = canvas.clientWidth || 0;
  const h = canvas.clientHeight || 0;
  const byW = w > 0 ? (w / 1180) : 1;
  const byH = h > 0 ? (h / 760) : 1;
  const scaleX = Math.max(0.78, Math.min(1.08, byW));
  const scaleY = Math.max(0.72, Math.min(1.05, byH));
  const scale = Math.max(0.75, Math.min(1.06, Math.min(scaleX, scaleY)));
  stage.style.setProperty('--node-scale', String(+scale.toFixed(3)));
  stage.style.setProperty('--node-vscale', String(+scaleY.toFixed(3)));
  stage.classList.toggle('workflow-tight', scaleY < 0.93);
}

function scheduleWorkflowFit(force) {
  if (WORKFLOW_FIT_TIMER) window.clearTimeout(WORKFLOW_FIT_TIMER);
  WORKFLOW_FIT_TIMER = window.setTimeout(() => fitWorkflowScale(force), 60);
}

function fitWorkflowScale(force) {
  updateDynamicNodeScale();
  if (document.body.classList.contains('simplified-mode')) return;
  if (window.matchMedia('(max-width: 1020px)').matches) return;
  if (WORKFLOW_VIEW.userLocked && !force) return;
  const canvas = document.querySelector('.workflow-canvas');
  const stage = document.getElementById('workflow-stage');
  if (!canvas || !stage) return;
  const nodes = [...stage.querySelectorAll('.node-pattern, .node-options, .method-node')];
  if (!nodes.length) return;
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const node of nodes) {
    const left = parseFloat(node.style.left) || 0;
    const top = parseFloat(node.style.top) || 0;
    const width = node.offsetWidth || 0;
    const height = node.offsetHeight || 0;
    minX = Math.min(minX, left);
    minY = Math.min(minY, top);
    maxX = Math.max(maxX, left + width);
    maxY = Math.max(maxY, top + height);
  }
  if (!Number.isFinite(minX) || !Number.isFinite(maxX)) return;
  const pad = 22;
  const contentW = Math.max(1, (maxX - minX) + pad * 2);
  const contentH = Math.max(1, (maxY - minY) + pad * 2);
  const fitW = canvas.clientWidth / contentW;
  const fitH = canvas.clientHeight / contentH;
  const next = Math.max(0.72, Math.min(1, Math.min(fitW, fitH)));
  if (!Number.isFinite(next)) return;
  const rounded = +next.toFixed(2);
  if (Math.abs(rounded - WORKFLOW_VIEW.scale) < 0.01) return;
  WORKFLOW_VIEW.scale = rounded;
  applyWorkflowScale();
}

function applyResponsiveModePolicy() {
  const forcedSimple = shouldForceSimplifiedViewport();
  document.body.classList.toggle('viewport-forced-simple', forcedSimple);
  if (forcedSimple) {
    applySimplifiedMode(true, false);
    updateDynamicNodeScale();
    return;
  }
  let saved = 'advanced';
  try { saved = localStorage.getItem('cook-ui-mode') || 'advanced'; } catch {}
  applySimplifiedMode(saved === 'simplified', false);
  updateDynamicNodeScale();
}

function applyWorkflowLayout(layout) {
  const pattern = document.querySelector('.node-pattern');
  const options = document.querySelector('.node-options');
  updateDynamicNodeScale();
  if (pattern && layout.pattern) { pattern.style.left = `${layout.pattern.left}px`; pattern.style.top = `${layout.pattern.top}px`; }
  if (options && layout.options) { options.style.left = `${layout.options.left}px`; options.style.top = `${layout.options.top}px`; }
  layoutMethodNodes(true);
  renderMethodFlow();
  scheduleWorkflowFit(false);
}

function applyWorkflowScale() {
  const stage = document.getElementById('workflow-stage');
  if (!stage) return;
  if (window.matchMedia('(max-width: 1020px)').matches || document.body.classList.contains('simplified-mode')) {
    stage.style.transform = 'none';
    stage.style.width = 'auto';
    stage.style.height = 'auto';
    updateWorkflowConnectors();
    return;
  }
  stage.style.transform = `scale(${WORKFLOW_VIEW.scale})`;
  stage.style.width = `${100 / WORKFLOW_VIEW.scale}%`;
  stage.style.height = `${100 / WORKFLOW_VIEW.scale}%`;
  updateWorkflowConnectors();
}

function zoomWorkflow(delta) {
  pushWorkflowUndo(captureWorkflowSnapshot());
  WORKFLOW_VIEW.userLocked = true;
  WORKFLOW_VIEW.scale = Math.max(0.7, Math.min(1.25, +(WORKFLOW_VIEW.scale + delta).toFixed(2)));
  applyWorkflowScale();
}

function saveWorkflowLayout() {
  const pattern = document.querySelector('.node-pattern');
  const options = document.querySelector('.node-options');
  if (!pattern || !options) return;
  const layout = {
    pattern: { left: parseFloat(pattern.style.left) || DEFAULT_WORKFLOW_LAYOUT.pattern.left, top: parseFloat(pattern.style.top) || DEFAULT_WORKFLOW_LAYOUT.pattern.top },
    options: { left: parseFloat(options.style.left) || DEFAULT_WORKFLOW_LAYOUT.options.left, top: parseFloat(options.style.top) || DEFAULT_WORKFLOW_LAYOUT.options.top }
  };
  localStorage.setItem('cook-workflow-layout-v2', JSON.stringify(layout));
}

function loadWorkflowLayout() {
  try {
    const raw = localStorage.getItem('cook-workflow-layout-v2');
    if (!raw) return DEFAULT_WORKFLOW_LAYOUT;
    const parsed = JSON.parse(raw);
    return parsed && parsed.pattern && parsed.options ? parsed : DEFAULT_WORKFLOW_LAYOUT;
  } catch { return DEFAULT_WORKFLOW_LAYOUT; }
}

function resetWorkflowLayout() {
  const ok = window.confirm('Reset workflow layout to default positions?');
  if (!ok) return;
  pushWorkflowUndo(captureWorkflowSnapshot());
  localStorage.removeItem('cook-workflow-layout-v2');
  applyWorkflowLayout(DEFAULT_WORKFLOW_LAYOUT);
  WORKFLOW_VIEW.userLocked = false;
  WORKFLOW_VIEW.scale = DEFAULT_WORKFLOW_SCALE;
  applyWorkflowScale();
  scheduleWorkflowFit(true);
  updateWorkflowConnectors();
}

function autoArrangeWorkflow() {
  pushWorkflowUndo(captureWorkflowSnapshot());
  applyWorkflowLayout(loadWorkflowLayout());
  layoutMethodNodes(false);
  renderMethodFlow();
  syncMethodFlowToInput();
  WORKFLOW_VIEW.userLocked = false;
  WORKFLOW_VIEW.scale = DEFAULT_WORKFLOW_SCALE;
  applyWorkflowScale();
  scheduleWorkflowFit(true);
  updateWorkflowConnectors();
  showToast('Workflow auto-arranged');
}

function applyStarterTemplate(kind) {
  const pattern = document.getElementById('pattern');
  const optMethods = document.getElementById('opt-methods');
  const optMode = document.getElementById('opt-mode');
  const paramRows = document.getElementById('param-rows');
  if (!pattern || !optMethods || !optMode || !paramRows) return;
  paramRows.innerHTML = '';
  document.getElementById('file-rows').innerHTML = '';
  document.getElementById('opt-colmethods').value = '';
  document.getElementById('opt-append').value = '';
  document.getElementById('opt-min').value = '';
  optMode.value = 'permutation';
  updateModeUI();

  if (kind === 'hash') {
    pattern.value = 'admin,root _,- pass,secret';
    optMethods.value = 'upper,sha256';
  } else if (kind === 'url') {
    pattern.value = '`https://api.example.com/v1/users?id=7`.host.tld';
    optMethods.value = '';
  } else if (kind === 'creds') {
    pattern.value = '`alice:123\\nbob:secret123`.user';
    optMethods.value = '';
  }
  syncMethodFlowFromInput();
  onPatternChange();
  validateInputs();
  pattern.focus();
  pattern.setSelectionRange(pattern.value.length, pattern.value.length);
  showToast('Starter template applied');
}

function initWorkflowDrag() {
  const canvas = document.querySelector('.workflow-canvas');
  const stage = document.getElementById('workflow-stage');
  if (!canvas || !stage) return;
  applyWorkflowLayout(loadWorkflowLayout());
  applyWorkflowScale();
  let active = null;
  let offsetX = 0, offsetY = 0;
  let dragStartSnapshot = null;
  let dragMoved = false;
  function paintMethodSelection() {
    stage.querySelectorAll('.method-node').forEach((el) => {
      const id = parseInt(el.dataset.id || '-1', 10);
      el.classList.toggle('selected', METHOD_SELECTION.has(id));
    });
  }

  canvas.addEventListener('mousedown', (e) => {
    if (document.body.classList.contains('simplified-mode')) return;
    const head = e.target.closest('.node-head');
    const block = e.target.closest('.flow-node');
    if (!head || !block) return;
    if (window.matchMedia('(max-width: 1020px)').matches) return;
    const tag = (e.target.tagName || '').toLowerCase();
    if (tag === 'button' || tag === 'input' || tag === 'textarea' || e.target.closest('button')) return;
    if (block.classList.contains('method-node')) {
      const id = parseInt(block.dataset.id || '-1', 10);
      const multi = e.metaKey || e.ctrlKey;
      if (multi) {
        if (METHOD_SELECTION.has(id)) METHOD_SELECTION.delete(id);
        else METHOD_SELECTION.add(id);
      } else {
        METHOD_SELECTION.clear();
        METHOD_SELECTION.add(id);
      }
      // Do not re-render here; it can detach the active drag target.
      paintMethodSelection();
    }
    e.preventDefault();
    active = block;
    active.classList.add('dragging');
    dragMoved = false;
    dragStartSnapshot = captureWorkflowSnapshot();
    const rect = active.getBoundingClientRect();
    offsetX = (e.clientX - rect.left) / WORKFLOW_VIEW.scale;
    offsetY = (e.clientY - rect.top) / WORKFLOW_VIEW.scale;
  });

  window.addEventListener('mousemove', (e) => {
    if (!active) return;
    const canvasRect = canvas.getBoundingClientRect();
    const blockRect = active.getBoundingClientRect();
    const maxLeft = stage.clientWidth - (blockRect.width / WORKFLOW_VIEW.scale);
    const maxTop = Math.max(0, stage.clientHeight - (blockRect.height / WORKFLOW_VIEW.scale));
    let left = (e.clientX - canvasRect.left) / WORKFLOW_VIEW.scale - offsetX;
    let top = (e.clientY - canvasRect.top) / WORKFLOW_VIEW.scale - offsetY;

    // Snap to grid.
    const grid = 12;
    left = Math.round(left / grid) * grid;
    top = Math.round(top / grid) * grid;

    // Magnetic align with neighboring node centers and connector distances.
    const activeW = blockRect.width / WORKFLOW_VIEW.scale;
    const activeH = blockRect.height / WORKFLOW_VIEW.scale;
    const others = [...stage.querySelectorAll('.flow-node')].filter(n => n !== active);
    for (const other of others) {
      const ol = parseFloat(other.style.left) || 0;
      const ot = parseFloat(other.style.top) || 0;
      const ow = other.offsetWidth;
      const oh = other.offsetHeight;
      const activeCy = top + activeH / 2;
      const otherCy = ot + oh / 2;
      if (Math.abs(activeCy - otherCy) < 18) top = otherCy - activeH / 2;
      const nearRightChain = ol + ow + 78;
      if (Math.abs(left - nearRightChain) < 24) left = nearRightChain;
    }

    const pad = 4;
    left = Math.max(pad, Math.min(maxLeft - pad, left));
    top = Math.max(pad, Math.min(maxTop - pad, top));
    dragMoved = true;
    active.style.left = `${left}px`;
    active.style.top = `${top}px`;
    if (active.classList.contains('method-node')) {
      const id = parseInt(active.dataset.id || '-1', 10);
      const found = METHOD_FLOW_STATE.items.find(m => m.id === id);
      if (found) { found.x = left; found.y = top; syncMethodFlowToInput(); }
    }
    updateWorkflowConnectors();
  });

  window.addEventListener('mouseup', () => {
    if (!active) return;
    if (active.classList.contains('method-node')) {
      const id = parseInt(active.dataset.id || '-1', 10);
      const current = METHOD_FLOW_STATE.items.find((m) => m.id === id);
      const activeRect = active.getBoundingClientRect();
      const targetEl = [...stage.querySelectorAll('.method-node')]
        .filter((n) => parseInt(n.dataset.id || '-1', 10) !== id)
        .find((n) => _rectsOverlap(activeRect, n.getBoundingClientRect(), 8));
      if (current && targetEl) {
        const targetId = parseInt(targetEl.dataset.id || '-1', 10);
        const target = METHOD_FLOW_STATE.items.find((m) => m.id === targetId);
        if (target) {
          const tx = target.x, ty = target.y;
          target.x = current.x; target.y = current.y;
          current.x = tx; current.y = ty;
          renderMethodFlow();
        }
      } else if (current) {
        const w = METHOD_NODE_UI.width;
        const h = METHOD_NODE_UI.rowHeight;
        const pos = resolveMethodNodeCollision(id, current.x, current.y, w, h);
        current.x = pos.left;
        current.y = pos.top;
        renderMethodFlow();
      }
      syncMethodFlowToInput();
    }
    active.classList.remove('dragging');
    active = null;
    if (dragMoved && dragStartSnapshot) pushWorkflowUndo(dragStartSnapshot);
    dragMoved = false;
    dragStartSnapshot = null;
    saveWorkflowLayout();
    updateWorkflowConnectors();
  });
}

function updateWorkflowConnectors() {
  _requestConnectorFrame();
}

function updateWorkflowConnectorsNow() {
  const stage = document.getElementById('workflow-stage');
  if (!stage) return;
  const layer = document.getElementById('flow-links');
  if (!layer) return;
  // Preview7: connector lines are intentionally disabled for a cleaner canvas.
  layer.innerHTML = '';
  stage.classList.add('compact-links');
  return;
  const nodePattern = stage.querySelector('.node-pattern');
  const nodeOptions = stage.querySelector('.node-options');
  const rect = stage.getBoundingClientRect();
  const methodNodes = [...METHOD_FLOW_STATE.items]
    .sort((a, b) => (a.x - b.x) || (a.y - b.y))
    .map(m => stage.querySelector(`.method-node[data-id="${m.id}"]`))
    .filter(Boolean);
  const chain = [nodePattern, nodeOptions, ...methodNodes].filter(Boolean);

  // In compact/stacked layouts, straight connector lines look broken and cluttered.
  const compactViewport = window.matchMedia('(max-width: 1280px)').matches;
  let stacked = false;
  for (let i = 0; i < chain.length - 1; i++) {
    const a = chain[i].getBoundingClientRect();
    const b = chain[i + 1].getBoundingClientRect();
    const dx = Math.abs(b.left - a.left);
    const dy = Math.abs((b.top + b.height / 2) - (a.top + a.height / 2));
    if (dy > 72 || dx < 120) { stacked = true; break; }
  }
  const hideLinks = compactViewport || stacked;
  stage.classList.toggle('compact-links', hideLinks);
  if (hideLinks) {
    layer.innerHTML = '';
    return;
  }

  const linksNeeded = Math.max(0, chain.length - 1);

  while (layer.children.length < linksNeeded) {
    const div = document.createElement('div');
    div.className = 'flow-link';
    layer.appendChild(div);
  }
  while (layer.children.length > linksNeeded) layer.removeChild(layer.lastChild);

  [...layer.children].forEach((linkEl, i) => {
    setFlowLink(linkEl, chain[i], chain[i + 1], rect);
  });
}
function updateModeUI() {
  const mode = document.getElementById('opt-mode')?.value || 'permutation';
  const appendInput = document.getElementById('opt-append');
  const modeHelp = document.getElementById('mode-help-text');
  if (appendInput) {
    appendInput.disabled = false;
  }
  if (modeHelp) {
    if (mode === 'append') {
      modeHelp.innerHTML = 'Line-by-line pairs values by index.<br><code>admin,root</code> + <code>123,456</code> -> <code>admin123</code>, <code>root456</code>';
    } else {
      modeHelp.innerHTML = 'Cross-product generates all combinations.<br><code>admin,root</code> + <code>123,456</code> -> <code>admin123</code>, <code>admin456</code>, <code>root123</code>, <code>root456</code>';
    }
  }
  const metricMode = document.getElementById('metric-mode');
  if (metricMode) metricMode.textContent = getModeLabel(mode);
}

(function initTheme() {
  try {
    const saved = localStorage.getItem('cook-theme');
    if (saved) {
      document.documentElement.setAttribute('data-theme', saved);
      updateThemeIcons(saved);
    } else {
      // First visit: show chooser instead of silently locking to dark.
      document.documentElement.setAttribute('data-theme', 'dark');
      updateThemeIcons('dark');
      const chooser = document.getElementById('theme-chooser');
      if (chooser) chooser.classList.add('open');
    }
  } catch {
    document.documentElement.setAttribute('data-theme', 'dark');
    updateThemeIcons('dark');
    const chooser = document.getElementById('theme-chooser');
    if (chooser) chooser.classList.add('open');
  }
})();
function initUXEnhancements() {
  initPerformanceProfile();
  applyResponsiveModePolicy();
  const inputs = ['pattern', 'opt-methods', 'opt-colmethods'].map(id => document.getElementById(id));
  inputs.forEach((el) => {
    el.addEventListener('keydown', (e) => {
      if (handleAutocompleteKey(e)) return;
    });
    el.addEventListener('input', () => { updateAutocomplete(el); validateInputs(); });
    el.addEventListener('click', () => updateAutocomplete(el));
    el.addEventListener('blur', () => setTimeout(hideAutocomplete, 120));
    if (el.id === 'opt-methods') {
      el.addEventListener('input', syncMethodFlowFromInput);
    }
  });
  const patternInput = document.getElementById('pattern');
  if (patternInput) {
    patternInput.addEventListener('paste', () => {
      // After browser paste completes, normalize multiline input as a single raw literal block.
      setTimeout(() => {
        autoWrapPatternPasteLiteral();
        onPatternChange();
      }, 0);
    });
  }
  document.getElementById('opt-mode').addEventListener('change', validateInputs);
  document.getElementById('opt-mode').addEventListener('change', () => {
    const currentMode = document.getElementById('opt-mode').value;
    const metricMode = document.getElementById('metric-mode');
    if (metricMode) metricMode.textContent = getModeLabel(currentMode);
    updateModeUI();
  });
  document.getElementById('opt-min').addEventListener('input', validateInputs);
  document.getElementById('opt-append').addEventListener('input', validateInputs);
  document.addEventListener('click', (e) => {
    const previewEl = e.target && e.target.closest ? e.target.closest('.node-step-preview') : null;
    if (previewEl) {
      copyNodePreviewFromElement(previewEl);
      return;
    }
    const box = document.getElementById('ac-box');
    if (!box) return;
    if (!box.contains(e.target) && e.target.id !== 'pattern' && e.target.id !== 'opt-methods' && e.target.id !== 'opt-colmethods') hideAutocomplete();
  });
  window.addEventListener('scroll', positionAutocomplete, true);
  window.addEventListener('resize', positionAutocomplete);
  window.addEventListener('resize', () => {
    applyResponsiveModePolicy();
    layoutMethodNodes(true);
    renderMethodFlow();
    scheduleWorkflowFit(false);
    updateWorkflowConnectors();
    positionOnboardingSpotlight();
  });
  window.addEventListener('scroll', positionOnboardingSpotlight, true);
  refreshPresetSelect('');
  initMethodFlowBuilder();
  initToolboxSearch();
  bindPrimaryActionButtons();
  initWorkflowDrag();
  clearStepPreviews();
  updateModeUI();
  validateInputs();
  scheduleWorkflowFit(true);
  LAST_PATTERN_TEXT_FOR_UNDO = String(document.getElementById('pattern')?.value || '');
  scheduleStepPreviewUpdate(260);
  setTimeout(() => startOnboarding(false), 260);
  setTimeout(updateWorkflowConnectors, 0);
  setTimeout(updateWorkflowConnectors, 150);
  const autoRestore = localStorage.getItem(PRESET_AUTORESTORE_KEY) === '1';
  const chk = document.getElementById('preset-autorestore');
  chk.checked = autoRestore;
  if (autoRestore) {
    const last = localStorage.getItem(PRESET_LAST_KEY);
    if (last) loadSelectedPreset(last, true);
  }
}
try {
  initUXEnhancements();
} catch (err) {
  console.error('initUXEnhancements failed:', err);
  const m = document.getElementById('tool-open-methods');
  const l = document.getElementById('tool-open-learn');
  const mu = document.getElementById('tool-add-mutation-node');
  const c = document.getElementById('tool-clear-all');
  if (m) m.onclick = () => safeOpenMethodsSidebar();
  if (l) l.onclick = () => safeOpenLearnSidebar();
  if (mu) mu.onclick = () => addMutationNode('balanced', '');
  if (c) c.onclick = () => clearAllAndSidebarSearch();
}


if (new URLSearchParams(window.location.search).has('test')) {
  (async function runTests() {
    const results = [];
    let pass = 0, fail = 0;

    async function test(name, patternArr, expected, opts = {}) {
      try {
        const engine = new CookEngine(patternArr, opts.params || {}, {
          methodsForAll: opts.methodsForAll || '',
          methodParam: opts.methodParam || '',
          appendParam: opts.appendParam || '',
          min: opts.min || -1,
        });
        if (opts.fileParams) engine.fileParams = opts.fileParams;
        const got = await engine.generateAsync();
        const ok = expected === undefined ? true : JSON.stringify(got) === JSON.stringify(expected);
        results.push({ name, ok, got, expected });
        if (ok) pass++; else fail++;
      } catch (e) {
        results.push({ name, ok: false, got: ['ERROR: ' + e.message], expected });
        fail++;
      }
    }

    await test('literal', ['test'], ['test']);
    await test('comma values', ['a,b,c'], ['a', 'b', 'c']);
    await test('permutation 2 cols', ['a,b,c', '1,2,3'], ['a1','a2','a3','b1','b2','b3','c1','c2','c3']);
    await test('vertical repeat **', ['r**5'], ['r','r','r','r','r']);
    await test('horizontal repeat *', ['r*5'], ['rrrrr']);
    await test('numeric range', ['1-5'], ['1','2','3','4','5']);
    await test('char range a-z', ['a-z'], 'abcdefghijklmnopqrstuvwxyz'.split(''));
    await test('range + permutation', ['1-5', 'a,b,c'], ['1a','1b','1c','2a','2b','2c','3a','3b','3c','4a','4b','4c','5a','5b','5c']);
    await test('params', ['p'], ['test','vest'], { params: { p: 'test,vest' } });
    await test('zero-padded range', ['01-05'], ['01','02','03','04','05']);
    await test('zero-padded range 001-010', ['001-010'], ['001','002','003','004','005','006','007','008','009','010']);
    await test('repeat range *2-4', ['r*2-4'], ['rr','rrr','rrrr']);
    await test('upper method', ['p.upper'], ['HELLO'], { params: { p: 'hello' } });
    await test('lower method', ['p.lower'], ['hello'], { params: { p: 'HELLO' } });
    await test('title method', ['p.title'], ['Hello World'], { params: { p: 'hello world' } });
    await test('reverse method', ['p.reverse'], ['olleh'], { params: { p: 'hello' } });
    await test('b64 encode', ['p.b64e'], [btoa('hello')], { params: { p: 'hello' } });
    await test('b64 roundtrip', ['p.b64e.b64d'], ['hello'], { params: { p: 'hello' } });
    await test('hex encode', ['p.hexe'], ['68656c6c6f'], { params: { p: 'hello' } });
    await test('url encode', ['p.urle'], ['hello%20world'], { params: { p: 'hello world' } });
    await test('md5', ['p.md5'], ['5d41402abc4b2a76b9719d911017c592'], { params: { p: 'hello' } });
    await test('sha256', ['p.sha256'], ['2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824'], { params: { p: 'hello' } });
    await test('chained upper.md5', ['p.upper.md5'], [_md5('HELLO')], { params: { p: 'hello' } });
    await test('charcode', ['p.charcode'], ['&#104&#101&#108&#108&#111'], { params: { p: 'hello' } });
    const testUrl = 'https://user:pass@sub.example.com:8080/path/to?key=val&k2=v2#frag';
    await test('url scheme', ['p.scheme'], ['https'], { params: { p: testUrl } });
    await test('url host', ['p.host'], ['sub.example.com'], { params: { p: testUrl } });
    await test('url port', ['p.port'], ['8080'], { params: { p: testUrl } });
    await test('url path', ['p.path'], ['/path/to'], { params: { p: testUrl } });
    await test('url fragment', ['p.fragment'], ['frag'], { params: { p: testUrl } });
    await test('url user', ['p.user'], ['user'], { params: { p: testUrl } });
    await test('url pass', ['p.pass'], ['pass'], { params: { p: testUrl } });
    await test('raw creds user', ['p.user'], ['alice'], { params: { p: 'alice:s3cr3t' } });
    await test('raw creds pass', ['p.pass'], ['s3cr3t'], { params: { p: 'alice:s3cr3t' } });
    await test('raw creds username alias', ['p.username'], ['alice'], { params: { p: 'alice:s3cr3t' } });
    await test('raw creds password alias', ['p.password'], ['s3cr3t'], { params: { p: 'alice:s3cr3t' } });
    await test('raw creds multiline user', ['p.user'], ['alice','bob'], { params: { p: 'alice:123\nbob:secret123' } });
    await test('raw creds multiline pass', ['p.pass'], ['123','secret123'], { params: { p: 'alice:123\nbob:secret123' } });
    await test('smart camelCase', ['p.smart'], ['camel', 'Case'], { params: { p: 'camelCase' } });
    await test('smart snake_case', ['p.smart'], ['snake', 'case'], { params: { p: 'snake_case' } });
    await test('smart kebab-case', ['p.smart'], ['kebab', 'case'], { params: { p: 'kebab-case' } });
    await test('raw string', ['`hello,world`'], ['hello,world']);
    await test('sort', ['p.sort'], ['a','b','c'], { params: { p: 'c,b,a' } });
    await test('sortu', ['p.sortu'], ['a','b','c'], { params: { p: 'c,b,a,b,c' } });
    await test('replace', ['p.replace[l:r]'], ['herro'], { params: { p: 'hello' } });
    await test('trim', ['p.trim'], ['hello'], { params: { p: '  hello  ' } });
    await test('contains', ['p.contains[admin]'], ['admin-panel','admin-api'], { params: { p: 'admin-panel,user-home,admin-api' } });
    await test('starts', ['p.starts[api-]'], ['api-v1','api-v2'], { params: { p: 'api-v1,web-v1,api-v2' } });
    await test('ends', ['p.ends[.json]'], ['a.json','c.json'], { params: { p: 'a.json,b.txt,c.json' } });
    await test('minlength', ['p.minlength[5]'], ['admin123','guest01'], { params: { p: 'root,admin123,guest01' } });
    await test('maxlength', ['p.maxlength[4]'], ['root'], { params: { p: 'root,admin123,guest01' } });
    await test('unique', ['p.unique'], ['a','b','c'], { params: { p: 'a,b,a,c,b' } });
    await test('split', ['p.split[,]'], ['a','b','c'], { params: { p: 'a,b,c' } });
    await test('json field', ['p.json[name]'], ['alice'], { params: { p: '`{"name":"alice","age":30}`' } });
    await test('regex', ['p.regex[[0-9]+]'], ['123','456'], { params: { p: 'abc123def456' } });
    await test('leet[0]', ['p.leet[0]'], undefined, { params: { p: 'hello' } });
    await test('xmle', ['p.xmle'], ['&lt;b&gt;hi&lt;/b&gt;'], { params: { p: '<b>hi</b>' } });
    await test('-m upper', ['a,b'], ['A','B'], { methodsForAll: 'upper' });
    await test('sha1', ['p.sha1'], ['aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d'], { params: { p: 'hello' } });
    await test('sha384', ['p.sha384'], ['59e1748777448c69de6b800d7a33bbfb9ff1b463e44354c3553bcdb9c666fa90125a3c79f90397bdf5f6a13de828684f'], { params: { p: 'hello' } });
    await test('sha512', ['p.sha512'], ['9b71d224bd62f3785d96d46ad3ea3d73319bfbc2890caadae2dff72519673ca72323c3d99ba5c11d7c7acc6e14b8c5da0c4663475c2e5c3adef46f73bcdec043'], { params: { p: 'hello' } });
    await test('sha224', ['p.sha224'], ['ea09ae9cc6768c50fcee903ed054556e5bfc8347907f12598aa24193'], { params: { p: 'hello' } });
    await test('methodsForAll bracket-comma parse', ['`administrator,alice,ops,dev-team`'], ['alice','ops'], { methodsForAll: 'split[,],maxlength[6]' });
    try {
      const mut = generateMutationWordlist(['admin'], { profile: 'balanced', extraWords: ['corp'] });
      const ok = mut.includes('admin1') && mut.includes('corpadmin');
      results.push({ name: 'mutation generator balanced', ok, got: mut.slice(0, 20), expected: ['admin1', 'corpadmin'] });
      if (ok) pass++; else fail++;
    } catch (e) {
      results.push({ name: 'mutation generator balanced', ok: false, got: ['ERROR: ' + e.message], expected: ['admin1', 'corpadmin'] });
      fail++;
    }

    async function runExampleEngine(ex) {
      const patternCols = splitPatternColumns(ex.pattern || '');
      const params = {};
      for (const p of (ex.params || [])) {
        if (!p || !p.name) continue;
        params[p.name] = p.value || '';
      }
      const options = ex.options || {};
      let appendParam = options.append || '';
      if (options.mode === 'append') {
        const cols = [];
        for (let i = 1; i < patternCols.length; i++) cols.push(String(i));
        appendParam = cols.join(',');
      }
      const engine = new CookEngine(patternCols, params, {
        methodsForAll: options.methods || '',
        methodParam: options.colmethods || '',
        appendParam,
        min: Number.isFinite(parseInt(options.min, 10)) ? parseInt(options.min, 10) : -1,
      });
      let out = await engine.generateAsync();
      if (options.mode === 'mutation' || options.mutationNode) {
        const profile = options.mutationNode?.profile || options.mutateProfile || 'balanced';
        const words = options.mutationNode?.words || options.mutateWords || '';
        out = generateMutationWordlist(out, {
          profile,
          extraWords: parseMutationWords(words)
        });
      }
      return out;
    }

    function hasOutputPlaceholder(out) {
      const s = String(out || '');
      return s.includes('...') || s.includes('…');
    }

    const known = new Set(METHOD_CATALOG.map(m => m.name).concat(Object.keys(METHOD_ALIASES)));
    for (let i = 0; i < EXAMPLE_LIBRARY.length; i++) {
      const ex = EXAMPLE_LIBRARY[i];
      const exName = `example/${i + 1}: ${ex.name}`;
      try {
        const methods = extractMethodsFromExample(ex);
        const unknownMethods = methods
          .map((m) => (m.includes('[') ? m.slice(0, m.indexOf('[')) : m))
          .filter((base) => !known.has(base));
        if (unknownMethods.length) {
          results.push({ name: `${exName} methods-known`, ok: false, got: unknownMethods, expected: [] });
          fail++;
          continue;
        } else {
          results.push({ name: `${exName} methods-known`, ok: true, got: methods, expected: methods });
          pass++;
        }

        applyExampleConfig(i, false);
        const uiPattern = document.getElementById('pattern').value;
        const uiNodes = METHOD_FLOW_STATE.items.length;
        const extraMutationNode = (ex.options && ex.options.mode === 'mutation') ? 1 : 0;
        const expectedNodes = methods.length + extraMutationNode;
        const uiOk = uiPattern === (ex.pattern || '') && uiNodes === expectedNodes;
        results.push({ name: `${exName} ui-apply`, ok: uiOk, got: { uiPattern, uiNodes }, expected: { pattern: ex.pattern || '', nodes: expectedNodes } });
        if (uiOk) pass++; else fail++;

        const out = await runExampleEngine(ex);
        let outOk = out.length > 0;
        if (String(ex.output || '').trim() && !hasOutputPlaceholder(ex.output)) {
          const firstExpected = String(ex.output).split('\n').find(Boolean) || '';
          if (firstExpected) outOk = outOk && out.join('\n').includes(firstExpected);
        }
        results.push({ name: `${exName} output`, ok: outOk, got: out.slice(0, 5), expected: ex.output || '(non-empty output)' });
        if (outOk) pass++; else fail++;
      } catch (e) {
        results.push({ name: exName, ok: false, got: ['ERROR: ' + e.message], expected: 'No errors' });
        fail++;
      }
    }

    try {
      const jsonExIdx = EXAMPLE_LIBRARY.findIndex((e) => e.name === 'JSON + Upper');
      if (jsonExIdx >= 0) {
        applyExampleConfig(jsonExIdx, false);
        await startGenerate();
        const ok = Array.isArray(fullResults) && fullResults.includes('ALICE');
        results.push({ name: 'ui regression: JSON + Upper example run', ok, got: fullResults.slice(0, 5), expected: ['ALICE'] });
        if (ok) pass++; else fail++;
      }
    } catch (e) {
      results.push({ name: 'ui regression: JSON + Upper example run', ok: false, got: ['ERROR: ' + e.message], expected: ['ALICE'] });
      fail++;
    }

    window._testResults = { passed: pass, total: pass + fail, failures: results.filter(r => !r.ok).map(r => r.name + ': got=' + JSON.stringify(r.got) + ' exp=' + JSON.stringify(r.expected)) };
    window._testsDone = true;

    const container = document.getElementById('test-results');
    let html = `<div class="tr-head">Tests: <span class="test-pass">${pass} passed</span> / <span class="${fail ? 'test-fail' : ''}">${fail} failed</span> / ${pass + fail} total</div>`;
    for (const r of results) {
      if (r.expected === undefined) {
        html += `<div class="test-item"><span class="test-pass">PASS</span> ${r.name}</div>`;
        continue;
      }
      const icon = r.ok ? '<span class="test-pass">PASS</span>' : '<span class="test-fail">FAIL</span>';
      html += `<div class="test-item">${icon} ${r.name}`;
      if (!r.ok) html += `<br>&nbsp;&nbsp;got: ${JSON.stringify(r.got)}<br>&nbsp;&nbsp;exp: ${JSON.stringify(r.expected)}`;
      html += `</div>`;
    }
    container.innerHTML = html;
    container.classList.add('test-results');
  })();
}

</script>
</body>
</html>
